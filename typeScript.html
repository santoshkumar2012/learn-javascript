<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="custom.css" rel="stylesheet">
    <title> TypeScript </title>
  </head>
  <body>
   <div class="container-fluid">
    <ul class="index">
      <li> <a href="#typescript"> TypeScript </a> </li>
      <li> <a href="#typeannotations"> Type Annotations </a> </li>
      <li> <a href="#boolean"> Type Boolean </a> </li>
      <li> <a href="#any"> ANY vs UNKOWN Types </a> </li>
      <li> <a href="#function"> Function Types </a> </li>
      <li> <a href="#inference"> Type Inference </a> </li>
      <li> <a href="#array"> Type Array </a> </li>
      <li> <a href="#arraymethod"> Array Method </a> </li>
      <li> <a href="#map-filter"> Map Filter </a> </li>
      <li> <a href="#typescriptObjects"> TypScript Object </a> </li>
      <li> <a href="#alias"> Alias </a> </li>
      <li> <a href="#callsignatures"> Call Signature </a> </li>
      <li> <a href="#enums"> Enums </a> </li>
      <li> <a href="#tuples"> Tuples </a> </li>
      <li> <a href="#unions-intersections"> Unions (|) and Intersections (&)  </a> </li>
      <li> <a href="#generics"> Generics </a></li>
      <li> <a href="#classes"> Classes </a></li>
      <li> <a href="#interface"> Interface , types vs. interfaces </a></li>
      <li> <a href="#inheritance"> Inheritance </a></li>
      <li> <a href="#public"> Access Modifiers Public </a></li>
      <li> <a href="#protected"> Protected </a></li>
      <li> <a href="#private"> Private </a></li>
    </ul>

<div class="box shadow p-2 mb-3 mt-4" id="typescript">
<h2> WHAT IS THE TYPESCRIPT? </h2>
<p> TypeScript is a superset of JavaScript that adds static typing and other features to enhance JavaScript development. It was developed by Microsoft on oct 1, 2012, and is now an opensource project with a large community of contributors.   </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
h1 id="message">Hello, World! h1
document.getElementById('message').innerHTML = 'Hello from JavaScript!';
---
function sum(a: number, b: number):number {
    return a + b
}
console.log(sum(5,10))
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="typeannotations">
<h2> Type Annotations  </h2>
<p> TypeScript is a superset of JavaScript that adds static typing and other features to enhance JavaScript development. It was developed by Microsoft on oct 1, 2012, and is now an opensource project with a large community of contributors.   </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
h1 id="message">Hello, World! h1
document.getElementById('message').innerHTML = 'Hello from JavaScript!';
---
function sum(a: number, b: number):number {
    return a + b
}
console.log(sum(5,10))
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="boolean">
<h2 class="mt-4"> <strong> boolean type and Bigint Types </strong>   </h2>
<p> <strong> boolean </strong>In TypeScript, the boolean data type is used to represent true/false values. </p>
<p> let isMyNameSantosh:boolean = true <br> let isDone:boolean = true </p>

<p class="mt-2"> <strong> BigInt </strong>  is a built-in type that allows you to work with numbers that are larger than the range supported by the regular number type. <br> BigInt literals are written by appending the n suffix to an integer Literal. </p>
<ul>
  <li> Introduced in ES2020 </li>
  <li> Not supported in JSON.stringify() </li>
  <li> Use ** for exponentiation, not Math.pow() with bigint </li>
</ul>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
let num: number = 42;
let big: bigint = 42n;
let sum = BigInt(num) + big;
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="any">
<h2 class="mt-4"> <strong> Differences ANY vs UNKOWN Types  </strong>   </h2>
<p> The any type is the most flexible type in TypeScript. It essentially turns of all type checking for the variables it is applied to.  
<br>
<strong> Example - </strong>  <br>
let myFavNum:any = 5 <br>
myFavNum:any = "Santosh"
</p>

<p> <strong> The unknown type </strong> is a safer alternative to any because it still enforces type checking and type safety. <br>
// Variable of type unknown can hold values of any type, but you must perform type checks or type assertions before using them in specific ways. </p>

any = "I give up" <br>
unknown = "I accept anything, but I’ll check before using it"
<br>
<ul class="mt-4">
  <li> <strong> any </strong> </li>
  <li> No type safety (unsafe) </li>
  <li> Assign anything	 </li>
  <li> No runtime checks required </li>
   <li> <strong> unknown </strong> </li>
   <li> Type-safe </li>
   <li> When you want to accept any type safely, but still enforce checks before usage </li>
</ul>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
let value: any = "hello";
value.toFixed(); // ✅ No error, but will crash at runtime!
---
let value: unknown = "hello";
value.toFixed(); // ❌ Error: Object is of type 'unknown'
if (typeof value === 'string') {
  console.log(value.toUpperCase()); // ✅ Safe
}
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="function">
<h2 class="mt-4"> <strong> Function Declaration (Definition)  </strong>   </h2>
<p> A function is declared with a name, parameters, and an optional return type:  </p>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
function greet(name: string): string {
  return `Hello, ${name}`;
}
//name: string → parameter with type
//: string → return type
</code>
</pre>
<h2 class="mt-4"> Optional and Default Parameters </h2>
Optional Parameter (?) <br>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
//Optional Parameter (?)
function greetUser(name?: string): string {
  return `Hi, ${name ?? 'Guest'}`;
}
//Default Parameter
function multiply(a: number, b: number = 2): number {
  return a * b;
}
//Arow Function 
const add = (a: number, b: number) => a + b

// Declaration 
function greet(name: string): string
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="inference">
<h2 class="mt-4"> <strong> Type Inference in TypeScript  </strong>   </h2>
<p> TypeScript uses type inference to determine the type of variables, functions, and expressions when types are not explicitly declared. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
let name = "Santosh"; // inferred as string
let age = 30;          // inferred as number
let isAdmin = true;    // inferred as boolean
</code>
</pre>

<p class="mt-4"> <strong> Why is it a bad idea to rely on inference for function parameters? </strong></p>
<p class="m-0 p-0"> Function parameters are not inferred by default. If you don't declare them explicitly, they default to any, which defeats the purpose of using TypeScript's safety features. </p>

<p class="mt-4"> <strong> How does TypeScript infer types from context? </strong></p>
<p> Contextual typing happens when TypeScript uses how a variable is used to infer its type, such as inside callbacks or DOM events. </p>

</div>

<div class="box shadow p-2 mb-3 mt-4" id="array">
<h2 class="mt-4"> <strong> Type Array in TypeScript  </strong>   </h2>
<p> In TypeScript, you can create and initialize arrays using various approaches. </p>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
  // Using square brakets:
const numbers: number[] = [1,2,3,4,5,6,7]

//Using the array constructor:
const numbers1: number[] = new Array(1,2,3,4,5,6,7);

//Using array of method:
const names: string[] = Array.of("santosh", "Pragyansh", "Nityansh")

// console.log(names[2]);
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="arraymethod">
<h2 class="mt-4"> <strong> Type Array in TypeScript Methods and Iterations  </strong>   </h2>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
const fruits: string[] = ["apple", "banana", "orange", "mango"];
const newUpdatesFruits = fruits.push("Kiwi")
console.log(newUpdatesFruits)
console.log(fruits)
================

const value4 = [true, false, true];

const arr = [1,2,3,4];
//for...in (iterates over indices)
for (const index in arr) {
console.log(index); // Output:0,1,2,3,4
}

//for..of loop (iterates over values)
for (const value of arr) {
 console.log(value); // Output: 1,2,3,4
}

</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="map-filter">
<h2 class="mt-4"> <strong> Type Array Map and Filter Methods  </strong>   </h2>
<p> <strong> Map Method </strong> The map method creates a new array by applying a provided function to each element of the original array. It transforms each element and returns a new array with the transformed values. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
// Double each number 
const numbers: number[] = [1,2,3,4,5];
const doubleData:number[] = numbers.map((curVal:number) => curVal * 2 )
console.log(doubleData);

// Converting numbers to string
const numberToString:string[] = numbers.map((curElm:number) => curElm.toString() )
console.log(numberToString);
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="typescriptObjects">
<h2 class="mt-4"> <strong> TypeScript Objects  </strong>   </h2>
<p> In TypeScript, objects are used to represent data with key-value pairs, Each key in the object is a string (or a symbol in ES6) that maps to a value. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
    const person: {
    name:string;
    age:number;
    isStudent:boolean;
    address:{city:string; country:string}
  } = {
    name:'Santosh Kumar',
    age:35,
    isStudent:true,
    address: {
      city: "Pune",
      country:'India'
    }
  }

  //access
  console.log(person.address.country)
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="alias">
<h2 class="mt-4"> <strong>  Type Alias </strong></h2>
<p> A Type Alias is a way to give a custom name to a type in TypeScript. It helps in making complex types reusable and improves code readability. </p>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
//Basic 
type Age = number;
let myAge: Age = 30;

//Object Type 
type User = {
  name: string;
  age: number;
};

const user1: User = {
  name: 'Alice',
  age: 25
};

</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="callsignatures">
<h2 class="mt-4"> <strong> Call Signatures in TypeScript </strong>   </h2>
<p> A call signature defines the shape of a function type — specifically, it tells what parameters a function accepts and what it returns. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
 //Basic Syntax (Using Type Alias):

type Greet = (name: string) => string;

//Using Call Signature Inside an Object Type: 
type Logger = {
  (message: string): void; // call signature
  logLevel: 'info' | 'error';
};

const consoleLogger: Logger = (msg: string) => {
  console.log(msg);
};
consoleLogger.logLevel = 'info';

//With Interfaces:
interface Add {
  (a: number, b: number): number; // call signature
}
const addNumbers: Add = (x, y) => x + y;
<code>
</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="enums">
<h2 class="mt-4"><strong> Enums in Typescript </strong></h2>
<p>Enums in typeScript are commonly used when I want to represet a set of related values and choose one value from multiple options. Enums provide a convenient way to define a set of named values and associate them with specific meanings. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>

enum Roles {
  user = "user", 
  admin = "admin"
}

type LoginDetails = {
  name?:string;
  email:string;
  password:string;
  role:Roles
}

const user1:LoginDetails = {
  name:"Santosh",
  email:"web.santo2012@gmail.com",
  password:"websanto",
  role:Roles.admin
}

const user2:LoginDetails = {
  email:"iamsantosh.develooper@gmail.com",
  password:"santo",
  role:Roles.user 
}

const isAdmin : (user: LoginDetails) => void = (user:LoginDetails) : string => {
  const {name, email, role} = user;
  return role === "admin" ? `${name} is allow to edit the website` : `${name} is allow to edit the website`
}

console.log(..data: isAdmin(user:user1))
console.log(..data: isAdmin(user:user2))

</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="tuples">
<h2 class="mt-4"><strong> TypeScript Tuples </strong></h2>
<p> A tuple is a fixed-length array where each element has a specific type and position. It's useful when you want to group multiple values with different types. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
//Basic Tuple Syntax:
let user: [string, number];
user = ['Alice', 30]; // ✅ Correct
// user = [30, 'Alice']; ❌ Error - type order matters

//Tuple with Labels (for clarity):
type User = [name: string, age: number];
let user1: User = ['Bob', 28];

//Optional Tuple Elements:
let config: [string, number?];
config = ['timeout'];       // ✅ valid
config = ['timeout', 3000]; // ✅ valid

//Tuple with Rest Elements:
let rgb: [number, ...number[]];
rgb = [255];           // ✅ valid
rgb = [255, 100, 50];  // ✅ valid

//Tuple Use Case: Returning Multiple Values
function getUser(): [string, number] {
  return ['Charlie', 35];
}

const [name, age] = getUser(); // Destructuring

</code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="unions-intersections">
<h2 class="mt-4"><strong> TypeScript: Unions (|) and Intersections (&) </strong></h2>
<p>  These two are powerful type composition tools in TypeScript — they help you combine or narrow down types. </p>
<h2> Unions (|) </h2>
<p> Union types allow you to specify that a variable can hold values of multiple types. You use the | (pipe) symbol to define a union type. </p>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
1. A value can be one of several types.

type StringOrNumber = string | number;

let value: StringOrNumber;
value = "Hello"; // ✅ valid
value = 42;      // ✅ valid
value = true;    // ❌ Error
----------

function printId(id: string | number) {
  console.log("Your ID is: " + id);
}
</code>
</pre>

<h2 class="mt-4"> Intersection Types (&) </h2>
<p> Definition: A value must satisfy all types involved. </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
type User = { name: string };
type Admin = { role: string };

type AdminUser = User & Admin;

const admin: AdminUser = {
  name: "Alice",
  role: "superadmin",
}; // ✅ valid

/// When you want a type that has all the properties of multiple types.

function createAdmin(user: User & Admin) {
  console.log(`${user.name} is an ${user.role}`);
}

</code>
</pre>

</div>


<div class="box shadow p-2 mb-3 mt-4" id="generics">
<h2 class="mt-4"><strong> Generics </strong></h2>
<p> Generics in TypeScript allow you to create reusable component or functions that can work with multiple data type. </p>

<pre>
  <code>
1. T> is a type parameter (you can name it anything).

function identityT>(value: T): T {
  return value;
}

const num = identitynumber>(10);   // T is number
const str = identity("Hello");      // T inferred as string

//Generic with Arrays

function getFirstElementT>(arr: T[]): T {
  return arr[0];
}
const first = getFirstElement([1, 2, 3]); // T inferred as number

//Generic Interfaces 

interface BoxT> {
  value: T;
}

const stringBox: Box string> = { value: "Hello" };
const numberBox: Box number> = { value: 100 };

//Generic Classes 
class DataStore<T> {
  private data: T[] = [];

  add(item: T) {
    this.data.push(item);
  }

  getAll(): T[] {
    return this.data;
  }
}

const store = new DataStore<string>();
store.add("Item1");

  </code>
</pre>

<h2 class="mt-4"><strong> Generics Multilple type </strong></h2>

<pre>
  <code>
    interface Products {
      name:string; 
      price:number;
      quantity:number;
    }

    const product1:Products = {
      name:"santosh",
      price:1000,
      quantity: 5
    }

    const calculateTotalPrice: (product: Products) => number = (product: Products) : number => {

      const {price, quantity} = product;
      return price * quantity

    }

    console.log(...data: calculateTotalPrice(product: product1));
  </code>
</pre>
</div>


<div class="box shadow p-2 mb-3 mt-4" id="classes">
<h2 class="mt-4"><strong> Classes in TypeScript </strong></h2>
<p> A class is a blueprint to create objects. It encapsulates properties (fields) and methods (functions). </p>

<pre>
  <code>
    class Persons {
      name: string = 'Santosh';
      age: number = 29;
      hobbies: string[] = ["reading", "painting"]; 

      constructor(name: string, age: number, hobbies: string[]) {
        this.name = name; 
        this.age = age;
        this.hobbies = hobbies; 
      }
    }

    const person1: Persons = new Persons(name: "santosh", age:35, hobbies:["reading", "painting"]);
    const person2: Persons = new Persons(name: "kumar", age:35, hobbies:["reading", "painting"]);
    const person3: Persons = new Persons(name: "singh", age:35, hobbies:["reading", "painting"]);

    console.log(...data: person3);

  </code>
</pre>

</div>

<div class="box shadow p-2 mb-3 mt-4" id="interface">
<h2 class="mt-4"><strong> TypeScript Interface </strong></h2>
<p> In TypeScript, an interface is used to define the shape of an object, specifying the names and types of its properties. Interfaces are helpful in providing structure, enforcing type safety, and enabling consistent coding practices—especially in large projects. </p>

<p> <strong> types vs. interfaces </strong></p>
<p> Both type and interface in TypeScript are used to describe the shape of an object — meaning what properties and methods it has. </p>
<ul>
  <li> <strong> interface </strong></li>
  <li> Can be extended (extends) and also implement multiple interfaces	 </li>
  <li> Yes — If you declare an interface with the same name twice, they merge	 </li>
  <li> Best for object shapes and class contracts	 </li>
  <li> Easier to read for OOP-style code	 </li>
  <li> <strong> type </strong></li>
  <li> Can extend other types via intersections (&) </li>
  <li> No — Two types with the same name will cause an error </li>
  <li> Works for any type (primitive, union, tuple, etc.) </li>
  <li> More flexible for complex types </li>
</ul>
<pre>
  <code>
types vs. interfaces Examples 

type UserType = {
  name: string;
  age: number;
}

interface UserInterface {
  name: string;
  age: number;
}
  </code>
</pre>

<pre>
  <code>
   //Basic Syntax of an Interface

interface Person {
  name: string;
  age: number;
  isStudent: boolean;
}

const user: Person = {
  name: "Santosh",
  age: 30,
  isStudent: false
};

//Optional Properties
interface Product {
  id: number;
  name: string;
  description?: string; // optional
}


//Readonly Properties
//Use readonly to prevent changes after the object is created:
interface User {
  readonly id: number;
  name: string;
}

  </code>
</pre>

2.  Function Type Interface

<pre>
  <code>
    interface Greet {
  (name: string): string;
}

const sayHello: Greet = (name) => {
  return `Hello, ${name}`;
};
  </code>
</pre>

3. Interface for Arrays (Indexable Types)

<pre>
  <code>
    interface StringArray {
  [index: number]: string;
}

let fruits: StringArray = ["Apple", "Banana", "Mango"];

  </code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="inheritance">
<h2 class="mt-4"><strong> Inheritance in TypeScript </strong></h2>
<p> Inheritance allow a class to reuse the functionlity of an existing class without rewriting it. </p>
<pre>
  <code>
class Person {
constructor(public name: string) {}
greet() { return `Hi, I'm ${this.name}`; }
}

class Employee extends Person {
  constructor(name: string, public id: number) {
    super(name); // must call super() before using `this`
  }
  // method override (TS 4.3+)
  override greet() { 
    return `${super.greet()} and my employee id is ${this.id}`;
  }
}

const e = new Employee('Asha', 101);
console.log(e.greet());

  </code>
</pre>
</div>

<div class="box shadow p-2 mb-3 mt-4" id="public">
<p> <strong> Access modifiers </strong> are keywords used to control the visibility (scope) of class properties and methods — determining whether they can be accessed from inside the class, its subclasses, or from anywhere in the program. </p>
 
<h2 class="mt-4"><strong> Public (default) </strong></h2>
<ol>
  <li> Accessible anywhere: inside the class, in subclasses, and outside the class (instances). </li>
  <li> </li>
</ol>
<pre>
  <code>
    class Person {
  public name: string;  // public is default
  constructor(name: string) {
    this.name = name;
  }
  public greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

const p = new Person("John");
console.log(p.name);    // ✅ Accessible
p.greet();              // ✅ Accessible
  </code>
</pre>
</div>


<div class="box shadow p-2 mb-3 mt-4" id="protected">
<h2 class="mt-4"><strong> Protected </strong></h2>
<ol>
  <li> Accessible inside the class and subclasses (child classes). </li>
  <li> NOT accessible from outside the class or instance. </li>
</ol>
<pre>
  <code>
    class Employee {
  protected department: string;
  constructor(dept: string) {
    this.department = dept;
  }
}

class Manager extends Employee {
  getDept() {
    return this.department;   // ✅ Accessible in subclass
  }
}

const m = new Manager("Sales");
console.log(m.getDept());     // ✅ Accessible via method
// console.log(m.department); // ❌ Error: cannot access protected member
  </code>
</pre>
</div>


<div class="box shadow p-2 mb-3 mt-4" id="private">
<h2 class="mt-4"><strong> Private </strong></h2>
<ol>
  <li> Accessible only inside the same class. </li>
  <li> NOT accessible in subclasses or from outside. </li>
</ol>
<pre>
  <code>
    class BankAccount {
  private balance: number = 0;

  deposit(amount: number) {
    this.balance += amount;     // ✅ Accessible inside the class
  }
  getBalance() {
    return this.balance;
  }
}

class SavingsAccount extends BankAccount {
  show() {
    // console.log(this.balance); // ❌ Error: private not accessible in subclass
  }
}

const acc = new BankAccount();
acc.deposit(100);
console.log(acc.getBalance());  // ✅ Accessible via method
// console.log(acc.balance);     // ❌ Error: private not accessible outside

  </code>
</pre>
</div>

<button id="toTopBtn" title="Go to top">↑</button>
<script src="script.js"></script>
</body>
</html>