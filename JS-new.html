<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <title> JS </title>
    <style>
		body{ font-size:1.2rem; }
	pre code { font-size:1.2rem !important; }
      #toTopBtn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: #333;
  color: white;
  cursor: pointer;
  padding: 0;
  border-radius: 50%;
  font-size: 18px;
  display: none; /* Hidden by default */
  transition: background-color 0.3s;
  width: 30px;
  height: 30px;
}

#toTopBtn:hover {
  background-color: #555;
}
h2 { font-size: 18px; font-weight: 600;}
pre {
    display: block;
    margin-top: 0;
    margin-bottom: 0;
    overflow: auto;
    font-size: .875em;
    background: #eeeeee;
}
.index { padding: 0; margin: 0;}
.index li {     
    list-style: none;
    display: inline-block;
    border: #ccc solid 1px;
    padding: 0px 5px;
    margin: 3px 0; 
  }
.index li a {     text-decoration: none;
    color: #000;
    font-weight: 600; 
    text-transform: capitalize;
  }
  .borderline { display: block; width: 100%; border: none !important;} 
  .borderline li { border: none;}
    </style>
  </head>
  <body>
   <div class="container-fluid">

    <ul class="index">
      <li> <a href="#js"> javascript </a> </li>
      <li> <a href="#d3"> D3, canvas, svg </a> </li>
      <li> <a href="#es6"> Es6 </a> </li>
	    <li> <a href="#arrow"> Arrow Function vs Normal Function: this Behavior </a> </li>
      <li> <a href="#async"> Async </a> </li>
      <li> <a href="#default"> Default Paramerter </a> </li>
      <li> <a href="#generators"> Generators </a> </li>
      <li> <a href="#destructruing"> Destructruing </a> </li>
      <li> <a href="#classes"> classes </a> </li>
      <li> <a href="#map"> map and set, forEach, filter </a> </li>
      <li> <a href="#prototype"> prototype </a> </li>
      <li> <a href="#closure"> closure, Lexical </a> </li>
      <li> <a href="#foreach"> foreach </a> </li>
      <li> <a href="#event"> <strong> event </strong> </a> </li>
      <li> <a href="#dom"> dom </a> </li>
      <li> <a href="#currying"> currying </a> </li>
      <li> <a href="#debounce"> debounce </a> </li>
      <li> <a href="#deep"> Deep copy and shallow copy </a> </li>
      <li> <a href="#objectclone"> Object Clone </a> </li>
      <li> <a href="#arraymethod"> Array Method </a> </li>
      <li> <a href="#infinityloop"> Infinity Loop </a> </li>
      <li> <a href="#hash"> hash </a> </li>
      <li> <a href="#hoisting"> Hoisting </a> </li>
      <li> <a href="#this"> This </a> </li>
      <li> <a href="#promise"> Promise </a> </li>
      <li> <a href="#operator"> Rest, Spread Operator </a> </li>
      <li> <a href="#function"> function statement and function expression </a></li>
      <li> <a href="#primitive"> Primitive Data Types / Null, Undefined </a></li>
      <li> <a href="#method"> Method(call(),apply(),bind() ) </a></li>
      <li> <a href="#break-continue">  Break and Continue  </a></li>
      <li> <a href="#synchronous">  synchronous and asynchronous  </a></li>

      <li class="borderline"> <a href="#hoisting"> </a> </li>
      <li> <a href="#filter"> filter </a> </li>
      <li> <a href="#largestnumber"> largestnumber </a> </li>
	   <li> <a href="#secondlargestnumber"> Second largestnumber </a> </li>
      <li> <a href="#duplicatenumber"> duplicatenumber </a> </li>
      <li> <a href="#find"> find sum number </a> </li>
      <li> <a href="#sum"> sum - 123456 </a> </li>
      <li> <a href="#count"> word count </a> </li>
      <li> <a href="#vowel"> Vowel </a> </li>
      <li> <a href="#sumnumber"> sumnumber </a> </li>
      <li> <a href="#triangle"> Triangle Pattern </a> </li>
      <li> <a href="#palindrome"> Palindrome </a> </li>
      <li> <a href="#booble"> Booble sort </a> </li>
      <li> <a href="#reverse"> Reverse </a> </li>
      <li> <a href="#factorial"> Factorial </a></li>
      <li> <a href="#median"> Median logic </a></li>
      <li> <a href="#digitalroot"> Digital Root repeatedly </a></li>
	    <li> <a href="#true"> True and False </a></li>
      <li> <a href="#dpstring">  Remove duplicate string </a></li>
      <li> <a href="#primenumber">  Finding Prime Numbers </a></li>
      <li> <a href="#fibonacci">  Fibonacci Sequence </a></li>
      <li> <a href="#secondHighestsalarys"> Second Highest Salary (Angular)</a></li>

      <li class="borderline"> <a href="#hoisting"> </a> </li>
      <li> <a href="#html"> HTML </a> </li>
      <li> <a href="#less"> Less, Sass, Scss </a> </li>
      <li> <a href="#position"> Position style </a> </li>
      <li> <a href="#semantic"> Semantic </a> </li>
      <li> <a href="#position"> Position style </a> </li>
      <li> <a href="#html5"> HTML5 </a> </li>
      <li> <a href="#gridFlex"> Gridflex </a> </li>
      <li> <a href="#sse"> SSE </a></li>
      <li> <a href="#debugging">  Debugging </a></li>
      <li> <a href="#frontend">  Frontend Performance </a></li>
	  <li> <a href="#database">  Database Mysql </a></li>
     <h5 class="mt-4"> HTML AND JAVASCRIPT</h5>
     <li> <a href="#htmljs"> HTMLJS, Tabs, Add & Remove, Sidebar Menu, Toggle </a></li>
      <li> <a href="#formvalidation"> Form Validation </a></li>
      <li> <a href="#increasevalue"> Increase & decrease value </a></li>
      <li> <a href="#cartbtn"> Update Cart Button </a></li>
      <li> <a href="#outoffinput"> Display text outof input </a></li>
     <hr>
     <li> <a href="#typescript"> TypeScript </a> </li>
     <li> <a href="#enums"> Enums </a> </li>
     <li> <a href="#typeguards"> Type Guards </a></li>
     <li> <a href="#readonly"> readonly </a></li>
     <li> <a href="#never"> never </a></li>
     <li> <a href="#union"> Union </a></li>
     <li> <a href="#classes"> classes </a></li>
     <li> <a href="#casting"> casting </a></li>
    <hr>
    <hr>
    <h5> MSQL  </h5>
    <li> <a href="#sql">  difference between DELETE, TRUNCATE, and DROP </a></li>
    <li> <a href="#acid">   ACID properties of a transaction </a></li>
    <li> <a href="#clustered">   clustered index, non-clustered index </a></li>
    <li> <a href="#normalization"> normalization  </a></li>
    <li> <a href="#key">  foreign key </a></li>
    <li> <a href="#join">  INNER JOIN and LEFT JOIN </a></li>
    <li> <a href="#view">  view </a></li>
    <li> <a href="#procedure"> stored procedure  </a></li>
    <li> <a href="#cte"> use of CTE  </a></li>
    <li> <a href="#tables">  tables </a></li>
    <li> <a href="#trigger"> trigger  </a></li>
    <li> <a href="#execution">  execution plan </a></li>
    <li> <a href="#indexing"> indexing  </a></li>
    <li> <a href="#deadlock"> deadlock  </a></li>
    <li> <a href="#clause"> WHERE and HAVING clause </a></li>
    <li> <a href="#wfunctions">  window functions? </a></li>
    <li> <a href="#transaction"> transaction log </a></li>
    <li> <a href="#isnull"> ISNULL() and COALESCE() </a></li>
    <li> <a href="#union"> UNION and UNION ALL </a></li>
    <li> <a href="#optimize"> optimize a SQL query </a></li>
    </ul>


<div class="box shadow p-2 mb-3 mt-4" id="js">
 <h2 id="component"> WHAT IS THE JAVASCRIPT? </h2>
<p> JavaScript (JS) is a high-level, interpreted programming language used to create interactive and dynamic web pages. It is the core language of the web, allowing developers to manipulate HTML, CSS. </p>
<h2> HOW WORK ON BROWSER  </h2>
<p> When a user opens a web page, the browser loads HTML, CSS, and JavaScript. The JavaScript Engine inside the browser processes JavaScript code.  </p>
<pre>
    <code>
        h1 id="message">Hello, World! h1
        document.getElementById('message').innerHTML = 'Hello from JavaScript!';
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="d3">
    <h2 id="component"> D3.js and Canvas Rendering </h2>
<p> D3.js (Data-Driven Documents) is a powerful JavaScript library used for creating dynamic and interactive data visualizations in web browsers. It leverages SVG (Scalable Vector Graphics) and Canvas for rendering charts, graphs, and complex visualizations. </p>
<ol>
    <li> Data binding (connects data with DOM elements) </li>
    <li> Transitions and animations </li>
    <li> Scalability with SVG & Canvas </li>
    <li> Works with various data formats (JSON, CSV, etc.) </li>
    <li> Dashboard UI </li>
</ol>
<h2>  SVG vs. Canvas Rendering </h2>
<p> D3.js primarily uses SVG but can also work with Canvas for better performance. </p>
<p> ** Canvas is better for performance-intensive rendering. </p>
<p> ** Canvas (HTML5) </p>
<ol>
    <li> Uses pixel-based rendering </li>
    <li> Fast for large datasets </li>
    <li> Manual event handling required </li>
    <li> Large datasets, real-time rendering </li>
</ol>
<h2> Using D3 with Canvas </h2>
<pre>
    <code>
  const canvas = d3.select("body")
  .append("canvas")
  .attr("width", 500)
  .attr("height", 300)
  .node();

const ctx = canvas.getContext("2d");

// Draw a circle
ctx.beginPath();
ctx.arc(100, 100, 50, 0, 2 * Math.PI);
ctx.fillStyle = "blue";
ctx.fill(); 
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="arrow">
  <h2> Arrow Function vs Normal Function : this Behavior </h2>
<div class="row">
  <div class="col-lg-6"> 
    <ul>
      <strong> Normal Function </strong>
      <li> syntax difference , function keyword </li>
      <li> Dynamic (runtime-bound) </li>
      <li> Best for	Object methods, constructors </li>
      <li> Gets hoisted (can call before it's defined). </li>
      <li> Has its own arguments </li>
    </ul>
  </div>
  <div class="col-lg-6"> 
    <ul>
      <strong> Arrow Function </strong>
      <li> syntax difference , => </li>
      <li> Lexical (inherits from parent) </li>
      <li> Callbacks, short functions </li>
      <li> Is not hoisted (must define before calling). </li>
      <li> Does NOT have its own arguments </li>
    </ul>
  </div>
</div>

<h2> The this Keyword Behavior </h2>
<p> Normal functions: this is dynamic, depends on how the function is called
<br>
  Arrow functions: this is lexical, inherits from the parent scope </p>

<h2> 1: this in a regular function </h2>
<pre><code>
  const user = {
    name: "Alice",
    sayHi: function () {
      console.log("Hi, I'm " + this.name);
    }
  };
  
  user.sayHi();  // "Hi, I'm Alice"  
</code>
</pre>
<h2> this in an arrow function </h2>
<pre>
  <code>
    const user = {
      name: "Bob",
      sayHi: () => {
        console.log("Hi, I'm " + this.name);
      }
    };
    
    user.sayHi(); // "Hi, I'm undefined"
    
  </code>
</pre>
<h2> Use case where arrow function is helpful: </h2>
<pre>
  <code>
    function Person() {
      this.age = 0;
    
      setInterval(() => {
        this.age++;  // `this` refers to the Person instance
        console.log(this.age);
      }, 1000);
    }
    
    new Person();
    
  </code>
</pre>
  </div>

<div class="box shadow p-2 mb-3" id="es6">
<h2> ES6 2015 </h2>
<p> <strong> let, const, Arrow Function, Destructuring, spread and rest operator, class, promise </strong></p>
<p> <strong> ARROW FUNCTION </strong> - An arrow function is a shorter syntax for writing functions in JavaScript. Introduced in ES6, </p>
<p> <strong> Normal Function: </strong> Gets hoisted (can call before it's defined). </p>
<p> <strong> Arrow Function: </strong> Is not hoisted (must define before calling). </p>
<p> <strong> Normal Function: </strong> Has its own arguments </p>
<p> <strong> Arrow Function: </strong> Does NOT have its own arguments </p> 
<p> <strong> Destructuring </strong></p>
<pre>
    <code>
        for loop examples 
        const numbers = [10, 20, 30];
    for (let num of numbers) {
      console.log(num); // 10, 20, 30
    }
    </code>
</pre>

<h2 class="mt-3"> ES2020 </h2>
<p> <strong> Nullish Coalescing Operator ( ?? ) </strong> </p>
The Nullish Coalescing operator in JavaScript is represented two question marks (??). <br> 
It takes two operands and returns the first operand if it is not null or undefined. <br> 
Otherwise, it returns the second operand. It is a logical operator introduced in ES2020.


<h2 class="mt-3"> ES2022 </h2>
<p> <strong> await , Class Fields & Private Methods ( # ), </strong> </p>
<pre>
    <code>
        const data = await fetch("https://api.example.com/data").then(res => res.json());
        console.log(data);
    </code>
</pre>
<h2> ES2023 </h2>
<p><strong>  Array.prototype.findLast() & findLastIndex() </strong></p>
<pre>
    <code>
            const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            console.log(numbers.findLast(n => n % 2 === 0)); // 8
            console.log(numbers.findLastIndex(n => n % 2 === 0)); // 7
    </code>
</pre>
<p> <strong> Array.prototype.toSorted(), toSpliced(), toReversed() (ES2023) </strong></p>
<pre>
    <code>
const arr = [3, 1, 4, 2];
console.log(arr.toSorted()); // [1, 2, 3, 4] (original array unchanged)
console.log(arr.toReversed()); // [2, 4, 1, 3]
console.log(arr.toSpliced(1, 2, 99)); // [3, 99, 2]
console.log(arr); // Original remains unchanged: [3, 1, 4, 2]
    </code>
</pre>
  
<p> <strong> ES 2024  </strong></p>
<pre>
    <code>
    Object.groupBy()
    Map.groupBy()
    Temporal.PlainDate()
</code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="async">
<h2> What is Async / Await </h2>
<p>  Async is used to declare a function that returns a Promise. await is used inside a function wait for promise.
</p>
<pre>
    <code>
	async function myDisplay() {
  let myPromise = new Promise(function(resolve, reject) {
    resolve("Promise is resolved");
  });

  let result = await myPromise;
  console.log(result);
}
myDisplay();
	
	...................
	
	
        Always returns a Promise.
        async function sayHello() {
      return "Hello!";
    }
    sayHello().then(console.log); // Output: Hello!

    => await Keyword
    Can only be used inside an async function.

    async function fetchData() {
  let response = await fetch('https://api.example.com/data');
  let data = await response.json();
  console.log(data);
}
    </code>
</pre>
<h2> Traditional Promise vs async/await </h2>
<pre>
    <code>
        with promise 
    fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
    </code>
</pre>
<h2> With async/await </h2>
<pre>
    <code>
        async function getData() {
            try {
              let response = await fetch('https://api.example.com/data');
              let data = await response.json();
              console.log(data);
            } catch (error) {
              console.error(error);
            }
          }
          getData();
    </code>
</pre>
<h2> Error Handling <br> use try...catch to handle errors in async functions. </h2>
<pre>
    <code>
        async function example() {
            try {
              let result = await someAsyncTask();
              console.log(result);
            } catch (err) {
              console.error('Error:', err);
            }
          }
    </code>
</pre>
  
<h2> Combining with Promise.all <br> You can still use Promise.all with async/await for parallel async operations: </h2>
<pre>
    <code>
        async function loadMultiple() {
            const [user, posts] = await Promise.all([
                  fetch('/api/user').then(res => res.json()),
                  fetch('/api/posts').then(res => res.json())
                ]);
                console.log(user, posts);
              }
    </code>
</pre>

</div>


<div class="box shadow p-2 mb-3" id="default">
<h2> DEFAULT PARAMETER </h2>
<p> Assigns default values to function parameters </p>
<pre>
    <code>
        function greet(name = "Guest") {
            console.log(`Hello, ${name}!`);
          }
          greet(); // Hello, Guest!
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="method">
<h2> Call, Bind, Apply </h2>
<p> call() - The call() method in JavaScript allows us to invoke a function with a specified value for this keyword and arguments provided individually. </p>
<p> apply() - The apply() method in JavaScript is a function method that allows a function to be called with a specified this value and arguments provided as an array or an array-like object. </p>
<p> The apply() method is similar to the call() method, but the call() method accepts arguments individually rather than as an array. </p>
<p> 
Different between <br>
Use <strong> **call** </strong> when you want to immediately invoke a function and pass arguments one by one. <br>
Use <strong> **apply** </strong> when you want to immediately invoke a function but pass arguments as an array. <br>
Use <strong> **bind** </strong> when you want to create a new function with this permanently set, but not execute it immediately. <br>
</p>

<pre>
  <code>
const person = {
name: 'Alice'
};

function greet(greeting, punctuation) {
  console.log(`${greeting}, I'm ${this.name}${punctuation}`);
}


call()/////////

greet.call(person, 'Hello', '!'); 
// Output: Hello, I'm Alice!


apply()////

greet.apply(person, ['Hi', '...']); 
// Output: Hi, I'm Alice...


bind()//
const greetAlice = greet.bind(person, 'Hey', '!');
greetAlice(); 
// Output: Hey, I'm Alice!

  </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="primitive">
  <h2> Primitive Data Types </h2>
  <p> Primitive are the basic, immutable data types. They hold simple values and are not objects. </p>
  <ul>
    <li> String → 'Hello' </li>
    <li> Number → 42, 3.14, -1 </li>
    <li> BigInteger - 123n (for very large integers) </li>
    <li> Boolean → true / false </li>
    <li> Undefined → variable declared but not assigned </li>
    <li> Null → represents intentional absence of value </li>
    <li> Symbol → unique identifiers (used in advanced use cases) </li>
  </ul>
<h2> Benefits of Primitive Data Types </h2>
<ul>
  <li> Fast access: Stored directly in memory (stack), which is faster than objects (which use heap). </li>
  <li> Immutable: Values cannot be changed directly (any modification creates a new value). </li>
  <li> Less memory: They take up minimal memory, which improves performance. </li>
  <li> Value-based comparison: Two primitive values are equal if their values match, not their references. </li>
  <pre>
    <code> 
      let a = 5;
let b = 5;
console.log(a === b); // true
    </code>
  </pre>
</ul>

<h2> Non-Primitive (Reference) Data Types </h2>
<ol>
  <li> Objects </li>
  <li> Arrays </li>
  <li> Functions </li>
  <li> Dates, RegExps, etc. </li>
</ol>

<h2> Null and Undefined </h2>
<p> In JavaScript, both null and undefined represent the absence of a value, but they are used in slightly different <br> 
Null is an assignment value that represents the intentional absence of any object value. <br>
 It represents an absence of value, the typeof operator returns "object" for values that are null <br>
 A variable has been declared but not yet assigned a value.
</p>

  </div>  


<div class="box shadow p-2 mb-3" id="generators">
<h2> GENERATORS </h2>
<p> Functions that can pause and resume execution <br>
    Generator Examples </p>
<pre>
    <code>
        function* generator() {
            yield 1;
            yield 2;
            yield 3;
          }
          const gen = generator();
          console.log(gen.next().value); // 1
          console.log(gen.next().value); // 2
          console.log(gen.next().value); // 3
    </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="destructruing">
<h2> DESTRUCTURING </h2>
<p> <strong>   Ans. Destructuring in JavaScript is a shorthand syntax for extracting values from arrays or properties from objects and assigning them to variables. 
</strong></p>
<strong> Array Destructuring </strong>
<pre>
    <code>
        const arr = [1, 2, 3];
        const [a, b] = arr;
        console.log(a); // 1
        console.log(b); // 2
    </code>
</pre>

<h2> Data Structural </h2>
<p> JavaScript provides various data structures to handle different use cases.
    Array, Object, Map, Set, Data Types </p>
</div>


<div class="box shadow p-2 mb-3" id="classes">
<h2> CLASSES </h2>
<p> Classes - class is a blueprint for creating objects with properties and methods. </p>
<pre><code>
    class Person {
        constructor(name, age) {
          this.name = name;
          this.age = age;
        }
        greet() {
          console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
        }
      }
      const person1 = new Person("John", 25);
      person1.greet(); // Output: Hello, my name is John and I am 25 years old.
</code></pre>
</div>


<div class="box shadow p-2 mb-3" id="map">
<h2> Map Method </h2>
<p> The map() method creates a new array by calling a callback function on each element of the original array.
It does not modify the original array. </p>
<pre>
<code>
const numbers = [1, 2, 3, 4];
const squared = numbers.map(num => num * num);
console.log(squared); // [1, 4, 9, 16]
</code>
</pre>

<h2> Map and Set  </h2>
<p> * Map and Set ( Map Stores key-value pairs, Set is a collection of unique values. ) </p>
<pre>
    <code>
        let myMap=new Map();
    myMap.set('name', 'Santosh');
    console.log(myMap);
  --------------------
  let myArray = [1,2,3]
  let obj = new Set(myArray);
  console.log(obj)
    </code>
</pre>

<h2> Different between forEach, map, filter </h2>

forEach - Retuns No array <br>
map - Returns new array <br>
filter - Returns new array <br>
----------------<br>
forEach - Just loops through the array <br>
map - Transforms each element <br>
filter - Keeps elements that match a condition <br>

<pre>
<code> 
ForEach
const numbers = [1, 2, 3];
numbers.forEach(num => {
  console.log(num * 2);  // Just prints, no new array
});
---------
Map 
const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6]
-----------
Filter
const numbers = [1, 2, 3, 4];
const even = numbers.filter(num => num % 2 === 0);
console.log(even); // [2, 4]

</code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="prototype">
<h2> PROTOTYPE  </h2>
<p> Prototype is like a templeate in javascript. It helps object to share the properties and methods. <br> Instead of duplicating code everywhere, we can define method or property once and then can easily share with other instances of an object. </p>

<p> <strong> Types of Prototype in JavaScript </strong> </p>
<ul>
<li> <strong> Object Prototype </strong> <p> The object prototype is foundational template to all objects in JavaScript. This template is available in every object we create by default. </p> </li>
<li> Constructor Function Prototype </li>
<li> Function Prototype </li>
<li> Built-in Prototype </li>
</ul>

<p> Object Examples </p>
<pre>
<code>
let obj = {
   name: "John",
   age: 21
};
console.log(obj);
console.log(obj.toString());  // [object Object]

</code>
</pre>
<p> // In above example, we have created an object named obj with properties name and age. We also have used toString() method which is available by default in object prototype. </p>

<pre>
<code>
<strong> Built-in Prototype </strong>
let arr = [1, 2, 3, 4, 5];
console.log(arr);
console.log(arr.toString());  // 1,2,3,4,5
console.log(arr.join("-"));  // 1-2-3-4-5
console.log(arr.reverse());  // [ 5, 4, 3, 2, 1 ]
</code>
</pre>
<p> In above example, we have created an array named arr. We also have used toString(), join(), and reverse() methods which are available by default in array prototype. </p>

<h2 Class="mt-5"> Prototype Chain </h2>
<p> Every object has an internal link to its prototype, which forms a prototype chain. </p>

<h2> Why Use Prototypes? </h2>
<p> 1. Methods are shared across instances., 2. Enables objects to inherit behavior., 3. You can add methods to existing constructors even after objects are created.</p>

<pre>
    <code>
        function Person(name, age) {
            this.name = name;
            this.age = age;
        }
        // Adding a method to the prototype
        Person.prototype.sayHello = function() {
            return `Hello, my name is ${this.name}`;
        };
        const person1 = new Person("Santosh", 30);
        console.log(person1.sayHello()); // Output: Hello, my name is Santosh   
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="closure">
<h2> CLOSURE  </h2>
<p> A closure in JavaScript is a function that has access to variables in its parent scope. 
    Inner function retain access to the variable. </p>
<pre>
    <code>
        function outerFunction() {
            let count = 0;  // count is in the lexical scope of innerFunction
        
            function innerFunction() {
                count++;  // innerFunction remembers 'count'
                console.log(count);
            }
        
            return innerFunction;  // Returns the inner function
        }
        
        const counter = outerFunction();  // outerFunction executes and returns innerFunction
        counter(); // Output: 1
        counter(); // Output: 2
        counter(); // Output: 3    
    </code>
</pre>

<h2> Hoisting  </h2>
<p> <strong> Hoisting is JavaScript's default behavior of moving declarations (variables and functions) to the top of their scope before the code executes. </strong></p>
<h2> Callback </h2>
<p> Callback Function - A callback is a function passed as an argument to another function. </p>

<h2> Lexical Scope </h2>
<p> In JavaScript, "lexical" refers to how things are organized and scoped based on the structure of the code when it's written (at compile time), rather than when it's executed (runtime).</p> 

<pre>
<code>
function outer() {
  let name = "ChatGPT";

  function inner() {
    console.log(name); // has access to 'name' due to lexical scope
  }

  inner();
}
outer();

//Here, inner() has access to name because of lexical scope — it’s defined inside outer().
</code>
</pre>

</div>

<div class="box shadow p-2 mb-3" id="foreach">
<h2> ForEach  </h2>
<p> ForEach method is used to iterate over arrays and execute a provided function once for each element. </p>
<p> ForEach is faster because it doesn’t create a new array. </p>
<p> map is slightly slower because it returns a new array. </p>
<pre>
    <code>
        let numbers = [10, 20, 30, 40];
let sum = 0;
numbers.forEach(num => {
    sum += num;
});
console.log(sum); //100
    </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="event">
<h2> Event  </h2>
<p> An event in JavaScript is an action in the browser, user clicking a button, typing in an input field, or scrolling a page. JavaScript can detect these events and execute functions accordingly. </p>
<pre>
    <code>
button onclick="alert('Button clicked!')" Click Me button
--------------------
button id="btn">Click Me button
script
    document.getElementById("btn").addEventListener("click", function() {
        alert("Button Clicked!");
    });
script
--------------------
input type="text" id="textInput" placeholder="Type something...">

 script -   let input = document.getElementById("textInput");

    input.addEventListener("keydown", (event) => {
        console.log("Key Pressed:", event.key);
    });

    input.addEventListener("keyup", () => {
        console.log("Key Released");
    });

    </code>
</pre>

<h2> Event Loop </h2>
<p> The event loop is a component of the JavaScript engine that manages the execution of code, collecting and processing events.  <br> It makes asynchronous programming (like setTimeout, Promises, and async/await) 
</p>
<h2> How it works (step by step):</h2>
<ol>
<li> Call Stack -  Executes your code line-by-line </li>
<li> Web APIs / Node APIs - setTimeout, DOM events, or fetch are handled outside the stack by the browser </li>
<li> Callback Queue (or Task Queue) - Stores callbacks (like setTimeout or resolved Promises) that are waiting to run. </li>
<li> Event Loop - Keeps checking the stack. If it's empty, it pushes the next task from the queue to the stack. </li> 
</ol>

<strong> Examples </strong>
<pre><code>
console.log("Start");

setTimeout(() => {
  console.log("Timeout callback");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise callback");
});

console.log("End");

</code></pre>
output - <br>
Start <br>
End <br>
Promise callback <br>
Timeout callback <br>
</div>

<div class="box shadow p-2 mb-3" id="dom">
<h2> DOM </h2>
<P> Document Object Model allows JavaScript to interact with HTML dynamically. </P>

<pre>
    <code>
        let heading = document.getElementById("heading");
        console.log(heading.textContent);  // Output: "Hello, World!"

        ---------------------------------------
let paragraphs = document.getElementsByClassName("text");
console.log(paragraphs[0].textContent); // Output: "This is a paragraph."
--------------------------------
document.getElementById("heading").innerHTML = "span style='color: red;'>Updated! span";

    </code>
</pre>

<p> <strong> The getElementById Method </strong> The most common way to access an HTML element is to use the id of the element. </p>
<p> <strong> The innerHTML Property </strong> The easiest way to get the content of an element is by using the innerHTML property. </p>

<pre>
  <code>
p id="demo"> /p>
document.getElementById("demo").innerHTML = "Hello World!";
  </code>
</pre>

<p> <strong> document.getElementById(id)	</strong> Find an element by element id </p>
<p> <strong> document.getElementsByTagName(name)	</strong> Find elements by tag name </p>
<p> <strong> document.getElementsByClassName(name)	</strong> Find elements by class name </p>

<pre>
  <code>
h2> JavaScript can Change HTML /h2>
p id="p1">Hello World!  /p>
document.getElementById("p1").innerHTML = "New Changes";
  </code>
</pre>

<h2> Form validation </h2>
<pre>
  <code>
    function validateForm() {
  let x = document.forms["myForm"]["fname"].value;
  if (x == "") {
    alert("Name must be filled out");
    return false;
  }
}

form name="myForm" action="/action_page.php" onsubmit="return validateForm()" method="post">
  Name: input type="text" name="fname">
  input type="submit" value="Submit">
/form>

  </code>
</pre>

===
<pre>
  <code>
    <p>Changing the HTML style:</p>


p id="p1">Hello World! /p>
p id="p2">Hello World! /p>


document.getElementById("p2").style.color = "blue";
document.getElementById("p2").style.fontFamily = "Arial";
document.getElementById("p2").style.fontSize = "larger";


  </code>
</pre>

<h2> Onclick Attribute </h2>

<pre>
  <code>

h2 onclick="changeText(this)">Click on this text! /h2>

function changeText(id) {
  id.innerHTML = "Ooops!";
}

  </code>
</pre>

<h2> addEvent Listener </h2>

<pre>
  <code>
button id="myBtn"> Try it /button>

document.getElementById("myBtn").addEventListener("click", myFunction);
function myFunction() {
  alert ("Hello World!");
}
  </code>
</pre>

<h2>  From DOM Text Content </h2>

<pre>
  <code>
p id="para">This is a paragraph. /p>

let text = document.getElementById("para").textContent;
console.log(text); // Output: This is a paragraph.
  </code>
</pre>

</div>


<div class="box shadow p-2 mb-3" id="currying">
<h2> CURRYING </h2>
<p>   Transforming a function with multiple arguments into a sequence of functions. </p>
<pre>
    <code>
        function add(a) {
            return function(b) {
                return a + b;
            };
        }
        console.log(add(5)(3)); // Output: 8
    </code>
</pre>
</div>

 
<div class="box shadow p-2 mb-3" id="debounce">
<h2> Debouncing & Throttling </h2>
<p> Debouncing limits the execution of a function until after a certain delay. <br> 
    Throttling ensures a function runs at most once in a specified interval. </p>
<pre>
    <code>
        function debounce(func, delay) {
            let timer;
            return function (...args) {
              clearTimeout(timer);
              timer = setTimeout(() => func.apply(this, args), delay);
            };
          }
          
          // Function to be executed
          function searchQuery(e) {
            console.log("Searching for:", e.target.value);
          }
          
          // Applying debounce to input event
          const input = document.getElementById("search");
          input.addEventListener("keyup", debounce(searchQuery, 500));
    </code>
</pre>

<h2> Trhotting Examples </h2>
<pre><code>
    function throttle(func, interval) {
        let lastExecutedTime = 0;
        return function (...args) {
          let now = Date.now();
          if (now - lastExecutedTime >= interval) {
            func.apply(this, args);
            lastExecutedTime = now;
          }
        };
      }
      
      // Function to be executed
      function handleScroll() {
        console.log("Scroll event triggered:", new Date().toLocaleTimeString());
      }
      
      // Applying throttle to scroll event
      window.addEventListener("scroll", throttle(handleScroll, 1000));
</code></pre>
</div>


<div class="box shadow p-2 mb-3" id="deep">
<h2> DEEP COPY AND SHALLOW COPY </h2>
<p> Shallow Copy – Creates a new object but copies references to nested objects. <br>
Deep Copy – Creates a new object and recursively copies all values, ensuring no references remain. </p>
Difference
<p> sh - References copied (not duplicated), deep - Entire structure duplicated </p>
<p> sh - Changes in the copy affect the original, deep - Changes in the copy do NOT affect the original </p>
<p>  sh - Faster (less memory used)	, deep - Slower (more memory used) </p>
<p> <strong> shallow examples </strong></p>
<pre><code>  let obj1 = { name: "John", details: { age: 25 } };
    let obj2 = obj1; // Copies reference
    obj2.details.age = 30;
    console.log(obj1.details.age); // Output: 30 (Changes reflect in obj1) </code></pre>

<p> <strong> Deep examples </strong></p>
<pre>
    <code>
        let obj1 = { name: "John", details: { age: 25 } };
        let obj2 = structuredClone(obj1);
        obj2.details.age = 30;
        console.log(obj1.details.age); // Output: 25 (Unaffected)
    </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="break-continue">
    <h2> Break Continue  </h2>
    <p> The break statement stops the current loop completely and exits it. </p>
<pre>
  <code>
for (let i = 1; i <= 5; i++) {
  if (i === 3) {
    break; // stops the loop when i is 3
  }
  console.log(i); // Output: 1, 2
}
  </code>
</pre>

<p> The continue statement skips the current iteration of the loop and moves to the next iteration. </p>

<pre>
  <code>
    for (let i = 1; i <= 5; i++) {
  if (i === 3) {
    continue; // skips only when i is 3
  }
  console.log(i); // Output: 1, 2, 4, 5
}

  </code>
</pre>
</div>



<div class="box shadow p-2 mb-3" id="synchronous">
    <h2> Synchronous and Asynchronous  </h2>
<p> <strong>  synchronous and asynchronous refer to how code is executed — whether one line waits for the previous one to finish (synchronous) or not (asynchronous). </strong></p>

<h2> Synchronous (Blocking) </h2>
<ul>
  <li>Executes code line by line, in order. </li>
  <li> Each operation waits for the previous one to complete. </li>
</ul>

<pre>
  <code>
    console.log("1");
    console.log("2");
    console.log("3");
  </code>
</pre>

<h2> Asynchronous (Non-blocking) </h2>
<ul>
  <li> Executes without waiting for previous tasks. </li>
  <li> Useful for tasks that take time, like API calls, reading files, timers. </li>
  <li> Uses: setTimeout, fetch, Promises, async/await. </li>
</ul>

<pre>
  <code>
    console.log("1");
setTimeout(() => {
  console.log("2");
}, 1000);
console.log("3");

  </code>
</pre>

</div>

<div class="box shadow p-2 mb-3" id="this">
    <h2> This </h2>
    <p> In JavaScript, this is a keyword that refers to an object. The value of this depends on how the function or code where it's used is called. </p>
    <pre>
        <code>
            Global Scope
            console.log(this); // In browsers, this === window
--------------
Inside Object Method

const user = {
    name: "Alice",
    getName: function () {
      return this.name; // `this` refers to `user`
    },
  };
  console.log(user.getName()); // Alice
  --------------
  Inside a Function

  function sayHi() {
    console.log(this);
  }
  sayHi(); // In non-strict mode, this === window. In strict mode, it's undefined.
  
        </code>
    </pre>
    </div>

    

    <div class="box shadow p-2 mb-3" id="promise">
    
        <strong> Promise -- </strong>  
// Promise excute immediately when create promises. <br>
// Pomise emit single value. Promise don't have operator . <br>
// Promise cann't be cancel  <br>
<strong> Observable -- </strong> 
// Observable does not start untill subscription. <br> 
// Observable emit multiple value.<br>
// Observable operator like map, filter, reduce. <br>
// Observable can be cancel using unscribe method <br>

<h2 class="mt-4"> * Promises - A Promise in JavaScript represents a value that may be available now, in the future, or never. </h2>
<pre>
  <code>
    let myPromise = new Promise((resolve, reject) => {
      let success = true; // Change this to false to see the reject case
      setTimeout(() => {
        if (success) {
          resolve("Operation Successful!");
        } else {
          reject("Something went wrong!");
        }
      }, 2000);
    });
    myPromise
      .then(result => console.log(result)) // Runs when promise is resolved
      .catch(error => console.log(error)); // Runs when promise is rejected  
  </code>
</pre>

<p> <strong> Observable is a stream of data that can emit multiple values over time. You can subscribe to an Observable to receive these values. </strong></p>

<pre><code>
  myObservable: Observable<number>;
    ngOnInit() {
      this.myObservable = new Observable(observer => {
        let count = 1;
        setInterval(() => {
          observer.next(count++); // Emits a value every second
        }, 1000);
  
      });
      this.myObservable.subscribe(value => {
        console.log('Received:', value);
      });
    }
</code></pre>


    </div>



<div class="box shadow p-2 mb-3" id="objectclone">
<h2> OBJECT CLONE </h2>
<pre>
    <code>   
        const personss = { first_name: "Santosh", last_name: "Kumar", age: 25 };
        const clone1 = { ...persons };
        console.log(clone1); 
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="arraymethod">
<h2> ARRAY METHOD  </h2>

<h2> Iteration / Looping </h2>

<strong> Method	Description </strong> <br> 
<ul>
  <li> forEach()	Executes a function for each element (no return value) </li>
  <li> map()	Transforms each element and returns a new array </li>
  <li> filter()	Filters elements based on a condition and returns a new array </li>
  <li> some()	Returns true if any element matches the condition </li>
  <li> every()	Returns true if all elements match the condition </li>
  <li> find()	Returns the first matching element </li>
  <li> findIndex()	Returns the index of the first matching element </li>
  <li> flatMap()	Maps and flattens results into a new array </li>
</ul>

<strong class="mt-3"> Combining / Slicing </strong> <br>
<ul>
  <li> concat()	Merges arrays into a new array </li>
  <li> slice()	Returns a part of the array without modifying the original </li>
  <li> join()	Converts array to string using a separator </li>
  <li> toString()	Converts entire array to a comma-separated string </li>
</ul>

 <strong class="mt-3"> Searching </strong>
<ul> 
<li> includes()	Checks if array contains a value </li>
<li> indexOf()	Returns index of first match </li>
<li> lastIndexOf()	Returns index of last match </li>
</ul>

<pre>
    <code>
	
1. push() – Add to the end
let fruits = ["apple", "banana"];
fruits.push("orange");
console.log(fruits); // ["apple", "banana", "orange"]
------------------------

2. pop() – Remove from the end
let fruits = ["apple", "banana", "orange"];
fruits.pop();
console.log(fruits); // ["apple", "banana"]

-------------------------------

3. shift() – Remove from the beginning
let fruits = ["apple", "banana"];
fruits.shift();
console.log(fruits); // ["banana"]

------------------------------

4. unshift() – Add to the beginning
let fruits = ["banana"];
fruits.unshift("apple");
console.log(fruits); // ["apple", "banana"]

----------------------------------

5. map() – Transform each element
let nums = [1, 2, 3];
let doubled = nums.map(n => n * 2);
console.log(doubled); // [2, 4, 6]

-----------------

6. filter() – Keep elements that match a condition
let nums = [1, 2, 3, 4];
let evens = nums.filter(n => n % 2 === 0);
console.log(evens); // [2, 4]

-----------------

7. forEach() – Loop through each element
let fruits = ["apple", "banana", "orange"];
fruits.forEach(fruit => console.log(fruit));
// Prints each fruit one by one

--------------------

8. find() – Find the first match
let nums = [10, 20, 30];
let found = nums.find(n => n > 15);
console.log(found); // 20

---------------------

9. includes() – Check if value exists
let fruits = ["apple", "banana"];
console.log(fruits.includes("banana")); // true

----------------------

10. slice() – Copy a portion
let nums = [1, 2, 3, 4, 5];
let part = nums.slice(1, 4); // from index 1 to 3
console.log(part); // [2, 3, 4]

-------------------

11. splice() – Add/remove elements at specific index
let nums = [1, 2, 3, 4];
nums.splice(2, 1, 99); // remove 1 element at index 2, insert 99
console.log(nums); // [1, 2, 99, 4]

----------------------

12. reduce() – Combine elements into one value
let nums = [1, 2, 3, 4];
let total = nums.reduce((sum, n) => sum + n, 0);
console.log(total); // 10

----------------------

1. charAt() – Get the character at a specific index
let str = "JavaScript";
console.log(str.charAt(0)); // "J"
console.log(str.charAt(4)); // "S"
console.log(str.charAt(10)); // "" (empty string, because there's no character at index 10)

--------------------

2. join() – Join array elements into a string
let fruits = ["apple", "banana", "cherry"];
let result = fruits.join(", "); // Join with a comma and a space
console.log(result); // "apple, banana, cherry"

----------------------

3. concat() – Merge two or more arrays or strings
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4, 5, 6]

-----------------

let greeting = "Hello";
let name = "World";
let message = greeting.concat(", ", name, "!");
console.log(message); // "Hello, World!"
-------------

1. split() – Split a string into an array
let sentence = "JavaScript is awesome";
let words = sentence.split(" ");
console.log(words); // ["JavaScript", "is", "awesome"]

---------------

4. reverse() – Reverse an array
let numbers = [1, 2, 3, 4];
numbers.reverse();
console.log(numbers); // [4, 3, 2, 1]

---------

5. indexOf() – Find the first index of an element
let arr = [10, 20, 30, 40];
console.log(arr.indexOf(30)); // 2
console.log(arr.indexOf(50)); // -1

-------------

let text = "Hello, world!";
console.log(text.indexOf("world")); // 7
console.log(text.indexOf("universe")); // -1

-------------
6. sort() – Sort the elements of an array
let nums = [10, 5, 8, 1];
nums.sort();
console.log(nums); // [1, 10, 5, 8] (alphabetically sorted, not numerically)

let numbers = [10, 5, 8, 1];
numbers.sort((a, b) => a - b); // Sort numerically
console.log(numbers); // [1, 5, 8, 10]

-------------------

7. slice() – Extract part of an array or string
let fruits = ["apple", "banana", "cherry", "date"];
let selectedFruits = fruits.slice(1, 3);
console.log(selectedFruits); // ["banana", "cherry"]

-------------

let text = "Hello, World!";
let part = text.slice(7, 12);
console.log(part); // "World"

-----------------------------

8. some() – Check if at least one element satisfies a condition
let nums = [1, 2, 3, 4];
let hasEven = nums.some(n => n % 2 === 0);
console.log(hasEven); // true (because 2 and 4 are even)

--------------

9. every() – Check if all elements satisfy a condition
let nums = [2, 4, 6, 8];
let allEven = nums.every(n => n % 2 === 0);
console.log(allEven); // true (because all elements are even)

---------------

10. replace() – Replace part of a string
let text = "Hello, World!";
let newText = text.replace("World", "JavaScript");
console.log(newText); // "Hello, JavaScript!"

----------
	
/ Filter

const websantos = [2,3,4,5,6,7,8,9]
const santo = websantos.filter((x) => x % 2 )
console.log (santo); // output [ 3, 5, 7, 9 ] odd value

const san = [2,3,4,5,6,7,8,9]
const anjsanto = san.filter((y) => y % 2 === 0 )
console.log (anjsanto); // output [ 2, 4, 6, 8 ] Eveb value

// Reduce reduce an array to a single value by applying a function to each element and 
// accumulating the result.

const numbersss = [1, 2, 3, 4];

const doubled = numbersss.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8]

const evens = numbersss.filter(num => num % 2 === 0);
console.log(evens); // [2, 4]

let arraynumner = [10,24,3,4,55,6,7,8,9]
const sum = arraynumner.reduce((a,b) => a + b)
console.log(sum) // 126

// Find

//Sorting an Array  method sorts an array alphabetically
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort(); // output Apple, Banana, Mango, Orange

// Ascending
let array = [10,24,3,4,55,6,7,8,9]
array.sort((a,b) => a - b)
console.log(array) // 3,  4,  6,  7, 8, 9, 10, 24, 55

//Descending
let array1 = [10,24,3,4,55,6,7,8,9]
array1.sort((a,b) => b - a)
console.log(array1) // 55, 24, 10, 9, 8, 7,  6,  4, 3

//MaxNumber
let array2 = [10,24,3,4,55,6,7,8,9]
array2.sort((a,b) => b - a)
let maxnumber = array2[0]
console.log(maxnumber) // 55


//forEach forEach() method performs an action on every item in a list.

let numbers = [10, 20, 30, 40];
let sum = 0;
numbers.forEach(num => {
    sum += num;
});
console.log(sum);
    </code>
</pre>

</div>


<div class="box shadow p-2 mb-3" id="infinityloop">
<h2> INFINITY LOOP  </h2>
<pre>
    <code>
        while (true) {
            console.log("This will run forever!");
          }
          stop Loop
          let count = 0;
        while (true) {
          console.log(count);
          if (count >= 5) break; // Stops after 5 iterations
          count++;
        }
    </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="hash">
<h2> HASH FUNCTION IN JAVASCRIPT  </h2>
<p>  -- A hash function in JavaScript is a function that takes an input (string, number, or object) and returns a fixed-size string or number (hash). Hash functions are commonly used for hashing passwords. </p>
<pre>
    <code>
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (hash << 5) - hash + str.charCodeAt(i);
                hash |= 0; // Convert to 32-bit integer
            }
            return hash;
          }
          console.log(simpleHash("hello")); // Example output: 99162322
          
    </code>
</pre>
<p>Custom Hash Function for Objects (Key-Value Hashing) </p>
<p>hash objects (since objects don’t have a native hash function), you can convert them into strings and then hash the string. </p>
<pre>
    <code>
        function objectHash(obj) {
            return simpleHash(JSON.stringify(obj));
            }
            console.log(objectHash({ name: "John", age: 30 })); // Example output: -487240083
    </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="hoisting">
<h2> HOISTING </h2>
<p> "Hoisting is JavaScript's default behavior of moving declarations (variables and functions) to the top of their scope before the code executes. </p>
<pre>
    <code>
        greet(); // Output: Hello, World!
function greet() {
  console.log("Hello, World!");
}
    </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="largestnumber">
<h2> LARGEST NUMBER </h2>
<pre>
    <code>
    numbers = [3,4,5,6,2,34,54,23,63,18,46]
    argest = numbers[0]
    for(let i = 1; i < numbers.length; i++) {
    if(numbers[i] > largest){
    largest = numbers[i]
     }
    }
    console.log(largest);
</code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="secondlargestnumber">
<h2> Second LARGEST NUMBER </h2>
<pre>
    <code>
numbers = [3,4,5,6,2,34,54,23,63,18,46]

  largest = numbers[0]
  secondLargest = numbers[0]
    
  for(let i = 1; i < numbers.length; i++) {
      
   if (numbers[i] > largest) {
    secondLargest = largest; // update secondLargest before largest
    largest = numbers[i];
    
   } else if (numbers[i] > secondLargest && numbers[i] !== largest) {
    secondLargest = numbers[i];
  }
     
    }
    
console.log("Largest:", largest);
console.log("Second Largest:", secondLargest);
</code>
</pre>
</div>



<div class="box shadow p-2 mb-3" id="duplicatenumber">
    <h2> Find DUPLICATE NUMBER</h2>
    <pre>
        <code>
        function findDuplicates(arr) {
            arr.sort((a, b) => a - b);
            let duplicates = [];
          
            for (let i = 0; i < arr.length - 1; i++) {
              if (arr[i] === arr[i + 1] && !duplicates.includes(arr[i])) {
                duplicates.push(arr[i]);
              }
            }
          
            return duplicates;
          }
          // Example
          console.log(findDuplicates([1, 2, 3, 4, 2, 5, 6, 3, 8, 1])); // [1, 2, 3]  
    </code>
</pre>

<h2> Remove Duplicates from an Array </h2>

<pre>
  <code>
    function removeDuplicatesFilter(arr) {
  return arr.filter((value, index, self) => {
    return self.indexOf(value) === index;
  });
}

// Test cases
console.log(removeDuplicatesFilter([1, 2, 2, 3, 4, 4, 5])); // Output: [1, 2, 3, 4, 5]
console.log(removeDuplicatesFilter(["apple", "banana", "apple", "orange"])); // Output: ["apple", "banana", "orange"]
console.log(removeDuplicatesFilter([])); // Output: []
  </code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="find">
        <h2> FIND SUM NUMBER </h2>
        <pre>
            <code>
            const findsum = [2,5,43,76,10]
            const totalFind = (findsum) => {
                let sum = 0 ;
                for(let i=0; i < findsum.length; i++){
                sum += findsum[i]
                }
                return sum
            }
            console.log(totalFind(findsum))

        </code>
    </pre>
   </div>


   <div class="box shadow p-2 mb-3" id="sum">
    <h2> Sum Number  </h2>
    <pre>
        <code>
            let number = 45678123465;
            let numStr = number.toString();
            let sum = 0;
            for (let i = 0; i < numStr.length; i++) {
                sum += Number(numStr[i]);
            }
            console.log(sum)
        </code>
    </pre>
    </div>

<div class="box shadow p-2 mb-3" id="count">
<h2> Count Word Fequency in a string  </h2>
<pre>
    <code>
    function wordCount(str) {
            let words = str.split(' ');
            let map = {};
            for (let word of words) {
                map[word] = (map[word] || 0) + 1;
            }
            return map;
        }
        console.log(wordCount("the quick brown fox jumps over the lazy dog the")); 
        // the: 3, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1
    </code>
</pre>

<h2> Counting Character Occurrences </h2>

<pre>
  <code>
function countCharacters(str) {
  const charCount = {};
  for (const char of str) {
    charCount[char] = (charCount[char] || 0) + 1;
  }
  return charCount;
}

// Test cases
console.log(countCharacters("hello")); // Output: { h: 1, e: 1, l: 2, o: 1 }
console.log(countCharacters("Mississippi")); // Output: { M: 1, i: 4, s: 4, p: 2 }
console.log(countCharacters("")); // Output: {}
  </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="filter">
<h2> Filter  </h2>
<pre>
    <code>
      const objects = [
  { name: "Alice", age: 30, city: "New York" },
  { name: "Bob", age: 25, city: "Los Angeles" },
  { name: "Charlie", age: 35, city: "Chicago" },
  { name: "David", age: 40, city: "Houston" },
  { name: "Eve", age: 28, city: "Miami" }
];

const citiesAbove30 = objects
  .filter(person => person.age > 30)
  .map(person => person.city);

console.log(citiesAbove30);

    </code>
</pre>
</div>



<div class="box shadow p-2 mb-3" id="function">
<h2> Function Statement and Function Expression </h2>
<p> function statement(Declaration) and function expression are two different ways to define functions </p>
<h2> Function Statement (Declaration )</h2>
<p> Function Statement defines a named using the function keywords, <br> Function declaration are hoisted to the top of their scope. Means we can calll the function even before and defined the code. </p>
<pre>
  <code>
    // declare name only
    function greet() {
      console.log("Hello!");
    }

  // after hoisted top 

  sayHi(); // Works, even before definition
  function sayHi() {
    console.log("Good Morning");
  }
  </code>
</pre>

<h2> Function Expression </h2>
<p>  function expression defines a function and assigns it to a variable. <br>
   Not hoisted: Function expressions are not hoisted. </p>

<pre>
  <code>
    const greet = function(){
      console.log("Good Morning")
    }
    greet()
  </code>
</pre>


  

</div>


<div class="box shadow p-2 mb-3" id="vowel">
<h2> VOWEL </h2>
<pre>
    <code>
        let str = "Hey JS you are AMAZING"
const vowels = ['a','e','i','o','u']

function countVowels(data){
let count = 0;
data.toLowerCase().split("").forEach((ch) => {
  vowels.includes(ch) && count++;
})
return count;
}

const numOfVowels = countVowels(str)
console.log(numOfVowels)
    </code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="sumnumber">
    <h2> SUM NUMBER </h2>
    <pre>
        <code>
            let array = [2,3,5,6,5]
            let sum = 0
            for (let i = 0; i < array.length; i++){
                 sum += array[i]
            }
            console.log(sum)
        </code>
    </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="factorial">
      <h2> Factorial Calculation </h2>
      <pre>
          <code>
            let n = 5;
            let result = 1;
            
            for (let i = 1; i <= n; i++) {
              result *= i;
            }
            
            console.log(result); // Output: 120
            
            </code>
            </pre>
            </div>

     <div class="box shadow p-2 mb-3" id="median">
      <h2> Median Logic </h2>
      <pre>
          <code>
           function findMedian(arr) {
            arr.sort((a, b) => a - b);
            let mid = Math.floor(arr.length / 2);

            return arr.length % 2 !== 0
              ? arr[mid]
              : (arr[mid - 1] + arr[mid]) / 2;
          }

          // Example:
          console.log(findMedian([5, 2, 1]));      // 2
          console.log(findMedian([4, 2, 1, 3]));   // 2.5
            </code>
            </pre>
            </div>


    <div class="box shadow p-2 mb-3" id="digitalroot">
      <h2> Digital Root repeatedly adding its digits</h2>
      <pre>
          <code>
          
            function toSingleDigit(num) {
                while (num >= 10) {
                  num = num.toString().split('').reduce((sum, digit) => sum + Number(digit), 0);
                }
                return num;
              }

              // Example:
              console.log(toSingleDigit(38)); // 2
              console.log(toSingleDigit(123456)); // 3


              // How to Works

              Converts number to string → "38"
              Splits it → ["3", "8"]
              Converts back to numbers and adds → 3 + 8 = 11
              Repeats if the result is still more than 9

            </code>
            </pre>
            </div>


  <div class="box shadow p-2 mb-3" id="dpstring">
  <h2> Remove Dublicate </h2>
  <pre>
    <code>
    const killers = [
      "Laziness kills Consistency",
      "Comfort kills Consistency",
      "Doubt kills Consistency",
      "Fear kills Consistency"
    ];
    const result = killers.map(killer => killer.split(" kills Consistency")[0]);
    console.log(result);
    </code>
  </pre>
  </div>



  <div class="box shadow p-2 mb-3" id="primenumber">
  <h2> Finding Prime Numbers  </h2>
  <pre>
    <code>
   function isPrime(n) {
  if (n <= 1) return false;
  if (n === 2) return true;
  if (n % 2 === 0) return false;

  const sqrt = Math.sqrt(n);
  for (let i = 3; i <= sqrt; i += 2) {
    if (n % i === 0) return false;
  }
  return true;
}

console.log(isPrime(7));  // true
console.log(isPrime(10)); // false
    </code>
  </pre>

  <h2> Primes Up to a Limit </h2>
  <pre>
    <code>
      function generatePrimesUpTo(limit) {
  const sieve = new Array(limit + 1).fill(true);
  sieve[0] = sieve[1] = false;
  
  for (let i = 2; i <= Math.sqrt(limit); i++) {
    if (sieve[i]) {
      for (let j = i * i; j <= limit; j += i) {
        sieve[j] = false;
      }
    }
  }
  
  return sieve
    .map((isPrime, num) => isPrime ? num : null)
    .filter(num => num !== null);
}

// Usage:
console.log(generatePrimesUpTo(30)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    </code>
  </pre>
  </div>



  <div class="box shadow p-2 mb-3" id="fibonacci">
  <h2>  Fibonacci Sequence  </h2>

  <pre>
    <code>
      function fibonacciSequence(n) {
  if (n <= 0) {
    return [];
  }
  if (n === 1) {
    return [0];
  }
  let sequence = [0, 1];
  for (let i = 2; i < n; i++) {
    sequence.push(sequence[i - 1] + sequence[i - 2]);
  }
  return sequence;
}

// Test cases
console.log(fibonacciSequence(0)); // Output: []
console.log(fibonacciSequence(1)); // Output: [0]
console.log(fibonacciSequence(5)); // Output: [0, 1, 1, 2, 3]
console.log(fibonacciSequence(10)); // Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

    </code>
  </pre>

  </div>



			
    <div class="box shadow p-2 mb-3" id="true">
      <h2> True and False Logic </h2>
      <pre>
          <code>
           
1 == '1'         // true  (type coercion happens)
1 === '1'        // false (number !== string)

0 == false       // true  (false becomes 0)
0 === false      // false


null == undefined // true (special rule)
null === undefined // false


[] == false      // true  ([] becomes '')
[] === false     // false

[] == ![]       // true


0 == '0'    // true (string '0' is coerced to number 0)
0 === '0'   // false (number !== string)


1. 0 == '0'             // true
2. 0 === '0'            // false
3. null == undefined    // true 
4. null === undefined   // false ( Because null datatype is null and undefined datatype is object )
5. ' \t\r\n' == 0       // true
6. false == 'false'     // false
7. [] == 0              // true
8. {} == {}             // false (reference comparison)
9. (parseInt('10 + 2'))  // 10
		   
----------


9 > 5 > 1   // false

9 > 5 > 1
↓
true > 1
↓
1 > 1
↓
false


false == 0 → true (Boolean to number)

'2' > 1 → true ('2' is converted to number)

-----------

true + true → 1 + 1 = 2

--------------

10 > 9 > 8 === true

10 > 9 → true
true > 8 → 1 > 8 → false
false === true → false		   


Arrays are objects, and when you compare objects (including arrays), you are comparing references, not values.
both [1] look the same, they are two separate array instances in memory. 
[1] == [1]        // false (different references)
[1] === [1]       // false (also different references)


Nullish coalescing operator (??) returns the right-hand value only if the left-hand value is null or undefined.
let value = null ?? 'Default';
console.log(value); // 'Default'


let userInput = null;
let username = userInput ?? "Guest";
console.log(username);  // Guest


let apiResponse = undefined;
let data = apiResponse ?? "No data available";
console.log(data);  // No data available

let count = 0;
let result = count ?? 10;
console.log(result);  // 0 ✅

            </code>
            </pre>
            </div>			


    

    <div class="box shadow p-2 mb-3" id="triangle">
        <h2>  Triangle Pattern </h2>
        <pre>
            <code>
                let n = 5; // Number of rows
                for (let i = 1; i <= n; i++) {
              let row = "";
              for (let j = 1; j <= i; j++) {
                  row += "* ";
              }
              console.log(row);
          }
            </code>
        </pre>
        </div>

        <div class="box shadow p-2 mb-3" id="palindrome">
            <h2> Palindrome </h2>
            <pre>
                <code>
                    function isPalindrome(str) {
                        const reversed = str.split('').reverse().join('');
                        return str === reversed;
                      }
                      
                      // Test it
                      console.log(isPalindrome("madam"));    // true
                      console.log(isPalindrome("hello"));    // false                      
                </code>
            </pre>
			<hr>
			
			<pre>
			<code>
			var isPalindrome = function(s) {
				 s = s.replace(/[^a-z0-9]/gi, '').toLowerCase();
				return s === s.split('').reverse().join('');
			};
			let input = "A man, a plan, a canal: Panama";
			console.log(isPalindrome(input));
			</code>
			</pre>
			
            </div>

            <div class="box shadow p-2 mb-3" id="booble">
                <h2>  Booble sort </h2>
                <pre>
                    <code>
                        function bubbleSort(arr) {
                            let n = arr.length;
                            for (let i = 0; i < n - 1; i++) {
                                for (let j = 0; j < n - i - 1; j++) {
                                    if (arr[j] > arr[j + 1]) {
                                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                                    }
                                }
                            }
                            return arr;
                        }
                        console.log(bubbleSort([5, 3, 8, 1, 2])); // Output: [1, 2, 3, 5, 8]
                        
                    </code>
                </pre>
                </div>

                <div class="box shadow p-2 mb-3" id="reverse">
                    <h2>  REVERSE  </h2>

                    <pre>
                        <code>
                            let str ="LOVE"
                            let totalstr = ""
                          
                            for (let i=str.length-1; i>=0; i--){
                              totalstr += str[i]
                            }
                          
                            console.log (totalstr)
							
--------------------------
							
let str = "Santosh kumar"
let reversed = ''
for (let i=str.length-1; i>=0; i--){
    reversed += str[i]
}
let final = reversed.charAt(0).toUpperCase() + reversed.slice(1).toLowerCase()
console.log(final) // Ramuk hsotnas


 -------------- 

  let strs = [1,2,3]
  stroess = strs.reverse();
  console.log(stroess) // [ 3, 2, 1 ]

  -------------- 

  let strss = "LOVE"
  let reverseStrss = strss.split("").reverse("").join("");
  console.log (reverseStrss)
                        </code>
                    </pre>
					
<pre>
<code>
const input = "Santosh Kumar";
const output = input
  .split(" ")
  .map(word => {
    // Reverse the word
    const reversed = word.split("").reverse().join("");
    // Capitalize first letter, lowercase the rest
    return reversed.charAt(0).toUpperCase() + reversed.slice(1).toLowerCase();
  })
  .join(" ");
console.log(output); // Output: Hsotnas Ramuk
</code>
</pre>

<pre>
  <code>
    const str = "I am sam";
const result = str.split(' ').map(word => word.split('').reverse().join('')).join(' ');
console.log(result); // "I ma mas"
  </code>
</pre>

<hr>
<pre>
<code>
var reverseWords = function(s) {
    return s
        .trim() // remove leading/trailing spaces
        .split(/\s+/) // split by one or more spaces
        .reverse() // reverse the array of words
        .join(" "); // join with single space
};

// Example
let s = "the sky is blue";
console.log(reverseWords(s)); // Output: "blue is sky the"
</code>
</pre>
					
                    </div>


                    <div class="box shadow p-2 mb-3" id="typescript">
                        <h2> TYPESCRIPT </h2>
                      <p>  TypeScript is a superset of JavaScript that adds static typing, interfaces, and advanced features to JavaScript. 
                        Differences between TypeScript and JavaScript </p>

<p> <strong> 1. What is TypeScript and how is it different from JavaScript? </strong> </p>
<p> TypeScript is a superset of JavaScript that adds static typing and compile-time checking. It helps catch errors early and supports modern JavaScript features with additional tools like interfaces, enums, and access modifiers. </p>
   
<p> <strong> What are the key features of TypeScript? </strong></p>
<ul>
  <li> Static type checking </li>
  <li> Type annotations </li>
  <li> Interfaces & Generics </li>
  <li> Type inference </li>
  <li> Classes & access modifiers (public, private, protected) </li>
  <li> ES6+ support with backward compatibility </li>
  <li> Rich tooling support (e.g., autocompletion, refactoring) </li>
</ul>

<p><strong> 3. What is the difference between interface and type in TypeScript? </strong></p>
<p> <strong> Both can define object shapes, but: </strong></p>
<ul>
  <li> interface is best for defining object contracts and can be extended or merged. </li>
  <li> type is more flexible, allowing unions, intersections, and can represent primitive types, tuples, etc. </li>
</ul>
--------- 

                      <p>
                        TypeScript - 
                        Statically typed (optional), Needs to be compiled to JavaScript	, Supports interfaces, generics, and modifiers	<br>
                        
                        JavaScript ----- <br>
                        Dynamically typed <br>
                        No compilation needed <br>
                        Limited support <br>
                      </p>
                      
                      <h2> Interfaces </h2>
                      <p> Interface is a way to define the structure of an object, function etc. </p>
                        <pre>
                          <code>
                          interface Info {
                              name:string,
                              age:number,
                              college:string
                          }
                          
                          //interface TeacherType extends Info {
                              //sub: string
                          //}
                          
                          var studentObj:Info = {
                              name:'anil',
                              age:30,
                              college:'IET'
                          }
                          
                          var teacheerObj:Info = {
                              name:'sam',
                              age:40,
                              college:'IET',
                          }
                          
                          //var teacheerObj:TeacherType = {
                              //name:'sam',
                              //age:40,
                              //college:'IET',
                              //sub: 'Math'
                          //}
                          
                      </code>
                      </pre>
                      
                      <h2> Generics </h2>
                      <p> Generics in TypeScript allow you to create reusable components or functions that can work with multiple data types.</p>
                        <pre>
                          <code>
                       // fruits(name:string | number):string | number {
                          //   return name
                          // }
                      
                          fruits<T>(name:T):T {
                            return name
                          }
                          let onlyFruit = fruits("apple")
                          let onlyNum = fruits(100)
                          let onlyBool = fruits(true)
                      </code>
                      </pre>
                      
                      <h2> Modifiers </h2>
                      <p> Modifiers are keywords that you can use to control access, behavior, or properties of classes, methods, properties, and constructors. </p>
                        <pre>
                          <code>
                          public (default)
                          class Person {
                        public name: string;
                      
                        constructor(name: string) {
                          this.name = name;
                        }
                      }
                      
                      const p = new Person("Alice");
                      console.log(p.name); // ✅ OK
                      
                      --------------------
                      
                      ✅ 2. private
                      
                      class Person {
                        private ssn: string;
                      
                        constructor(ssn: string) {
                          this.ssn = ssn;
                        }
                      
                        private showSSN() {
                          return this.ssn;
                        }
                      }
                      
                      const p = new Person("123-45-6789");
                      // console.log(p.ssn); ❌ Error: 'ssn' is private
                      
                      ---------------
                      
                      ✅ 3. protected
                      class Animal {
                        protected move() {
                          console.log("Animal moving...");
                        }
                      }
                      
                      class Dog extends Animal {
                        bark() {
                          this.move(); // ✅ OK
                        }
                      }
                      
                      const d = new Dog();
                      // d.move(); ❌ Error: 'move' is protected
                      
                      
                      </code>
                      </pre>
                      
                      </div>


                       <div class="box shadow p-2 mb-3" id="enums">
                        <h2> Enums </h2>
                        <p> Enums are used to define a set of named constants.</p>
                        <pre>
                          <code>
                            enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move: Direction = Direction.Up;

                          </code>
                        </pre>
                        </div>

 <div class="box shadow p-2 mb-3" id="tuple">
  <h2> Tuple </h2>
  <p> A tuple is a fixed-length array with specific types for each element.</p>
  <pre>
    <code>
      let user: [string, number] = ['Alice', 30];
    </code>
  </pre>


   <div class="box shadow p-2 mb-3" id="typeguards">
  <h2> What are Type Guards in TypeScript? </h2>
  <p> Type guards are used to narrow down types within a conditional block. </p>
  <pre>
    <code>
      function print(value: string | number) {
  if (typeof value === 'string') {
    console.log(value.toUpperCase()); // string
  } else {
    console.log(value.toFixed(2)); // number
  }
}
    </code>
  </pre>
 </div>


 <div class="box shadow p-2" id="readonly"> 
<h2> readonly </h2>
<p> readonly marks properties as immutable after initialization. </p>
<pre>
  <code>
    interface Car {
  readonly brand: string;
}
  </code>
</pre>
 </div>

<div class="box shadow p-2" id="never"> 
<h2> never </h2>
<p> never represents a value that never occurs (e.g., function throws an error or infinite loop). </p>
<pre>
  <code>
function fail(): never {
  throw new Error("Something went wrong");
}
  </code>
</pre>
 </div>


<div class="box shadow p-2" id="union"> 
<h2> Union | (OR) </h2>
<p> Union types are used when a value can be more than a single type. </p>
<pre>
  <code>
function printStatusCode(code: string | number) {
  console.log(`My status code is ${code}.`)
}
printStatusCode(404);
printStatusCode('404');
  </code>
</pre>
 </div>

<div class="box shadow p-2" id="casting"> 
<h2> TypeScript Casting </h2>
<p> Casting is the process of overriding a type. </p>
<p> A straightforward way to cast a variable is using the as keyword, which will directly change the type of the given variable.
</p>
<pre>
  <code>
    let x: unknown = 'hello';
console.log((x as string).length);
  </code>
</pre>
</div>

<div class="box shadow p-2" id="classes"> 
<h2> TypeScript Classes </h2>
<p> The members of a class (properties & methods) are typed using type annotations, similar to variables.
 </p>
</p>
<pre>
  <code>
    class Person {
  name: string;
}

const person = new Person();
person.name = "Jane";
  </code>
</pre>
<h2> Members: Visibility </h2>
<div>
There are three main visibility modifiers in TypeScript. <br>
public - (default) allows access to the class member from anywhere <br>
private - only allows access to the class member from within the class <br>
protected - allows access to the class member from itself and any classes that inherit it, which is covered in the inheritance section below
</div>
</div>



                      <div class="box shadow p-2 mb-3" id="html">
                        <h2> HTML AND CSS </h2>
                        Hyper Text markup Language <br>
						<p> The <strong> !DOCTYPE </strong> html declaration defines that this document is an HTML5 document </p> 
	<p> The <strong> html </strong> element is the root element of an HTML page </p> 
	<p> The <strong> head </strong> element contains meta information about the HTML page </p> 
	<p> The <strong> title </strong> element specifies a title for the HTML page (which is shown in the browser's title bar or in the page's tab) </p>
                       
                       
                        <h2> Tag and Element </h2>
						            <p> HTML tag is a piece of markup that defines an element within an HTML document. </p>
                        <p> <strong> Tag </strong> Opening or closing code in angle brackets </p>
                        <p> <strong> Elements </strong> Tag(s) plus content</p>
                        <p> <strong> Void Element </strong>	Element with no content/closing tag	<img />, <br /></p>

                        <h2> Attribute </h2>
                        <pre>
                            <code>
                                img
                                    src="cat.jpg"
                                    alt="A cute kitten"
                                    width="300"
                                    height="200"
                                    title="Hover text here"
                                    class="responsive-img"
                                    loading="lazy"
                                    />
                            </code>
                        </pre>
						
						<h2>What is the difference between “display: none” and “visibility: hidden”, when used as attributes to the HTML element. </h2>
						<p> When we use the attribute “visibility: hidden” for an HTML element then that element will be hidden from the webpage but still takes up space. Whereas, if we use the “display: none” attribute for an HTML element then the element will be hidden, and also it won’t take up any space on the webpage.</p>
						
						<h2> How to specify the metadata in HTML5? </h2>
						<p> To specify we can use <meta> tag which is a void tag,i.e., it does not have a closing tag. Some of the attributes used with meta tags are name, content, http-equiv, etc. The below image tells how to specify the metadata. </p>
                        
                       
                        
                        <h2> P and span tag difference </h2>
                        <p> p Block element, Paragraph, Starts on a new line	</p>
                        <p> span Inline element, No semantic meaning, Styling small parts, Stays inline </p>
                        
                        <h2> CSS </h2>
                        <p> <strong> css selector </strong> - CSS selector is a pattern used to select HTML elements , like - id, .class, element.class, Parent child, element:hover </p>
                        <p> <strong> Pseudo-Elements (::, ::before, ::after) , Pseudo-Classes (:, :hover, :focus, :nth-child()) </strong></p>
                        
                        <p><strong> Box Model </strong> Box Model defines how an element’s size and spacing are calculated. </p>
                        
                       
                        </div>

<div id="frontend">
  <h2> Frontend Performance Tips </h2>
  <ol>
    <li> Minify CSS, JavaScript, and HTML (remove whitespace/comments). </li>
    <li> Optimize Images , Use correct formats: WebP , responsive images, Lazy load images  </li>
    <li> Use a Content Delivery Network (CDN) </li>
    <li> Reduce number of render-blocking resources (like large CSS or JS). </li>
    <li> Backend & Server Optimization </li>
  </ol>
  <h2> Tools to Measure & Monitor </h2>
Lighthouse (built into Chrome DevTools): Full performance audit. <br>
PageSpeed Insights: Google’s tool with real-world data. <br>
WebPageTest.org: Waterfall view of your site’s loading. <br>
GTmetrix: Performance scores + suggestions. <br>
Chrome DevTools: Network tab, performance tab, coverage tab. <br>
</div>


                        <div id="debugging"> 
                          <h2>Debugging </h2>
                          <strong> Browser DevTools (Chrome/Edge/Safari/Firefox): </strong>
                          Elements tab: Inspect HTML & CSS in real time. <br>
                          Console tab: View logs, warnings, errors. <br>
                          Sources tab: Set breakpoints, step through code. <br>
                          Network tab: Track API calls, status codes, and payloads. <br>
                          Performance tab: Analyze load time, bottlenecks. <br>
                          Application tab: View localStorage, sessionStorage, cookies. <br>
                        </div>

<div id="sse">
<p> SSE is a way for the server to push real-time updates to the browser over HTTP — using a unidirectional communication channel. </p>
<h2> SSE vs WebSockets </h2>
<p> <strong> SSE </strong></p>
<p class="p-0 m-0"> One-way (Server→Client) </p>
<p class="p-0 m-0"> Protocol ->	HTTP </p>
<p class="p-0 m-0"> Reconnect -> Auto </p>
<p class="p-0 m-0"> Easy </p>
<p> <strong> WebSocket </strong></p>
<p class="p-0 m-0"> Two-way (Full duplex) </p>
<p class="p-0 m-0"> WebSocket (WS)	 </p>
<p class="p-0 m-0"> Manual </p>
<p class="p-0 m-0"> Complex </p>
</div>

<div id="html5"> 
<h2> HTML 5 CANVAS </h2>
<P> HTML5 canvas element is used to draw graphics . Lines and shapes. Animations. Games, charts</P>

<h2> HTML API </h2>
<p> HTML5 introduced a bunch of JavaScript-accessible browser APIs that give you more control over the browser, user interaction, and data — without needing plugins.
</p>

<h2> Geolocation API </h2>
<p> Get user's location </p>
<pre><code>
  navigator.geolocation.getCurrentPosition((pos) => {
    console.log(pos.coords.latitude, pos.coords.longitude);
  });  
</code>
</pre>

<h2>  Web Storage API </h2>
<p> localStorage: persists data even after reloads </p>
<p> sessionStorage: clears on tab close </p>

<h2> Canvas API </h2>
<pre>
  <code>
    canvas id="myCanvas" width="200" height="100"> canvas>
script>
  const ctx = document.getElementById('myCanvas').getContext('2d');
  ctx.fillStyle = "red";
  ctx.fillRect(20, 20, 150, 50);
/script>
  </code>
</pre>

<h2> Notification API </h2>
<pre>
  <code>
    Notification.requestPermission().then((perm) => {
      if (perm === "granted") {
        new Notification("Hello!", { body: "Welcome back!" });
      }
    });    
  </code>
</pre>

<h2> Audio/Video API </h2>
<pre><code>
  video controls>
    source src="video.mp4" type="video/mp4">
  /video>  
</code></pre>

</div>

<div id="gridFlex">
<h2> Grid Flex </h2>
<p> GRID - 2D (Rows & Columns), Aligns items in both rows and columns, Uses grid-gap, row-gap, column-gap </p>
<p> FLEX BOX - 1D (Row or Column), Aligns items in a single row or column, Uses gap but only for row/column spacing </p>

</div>

<div id="semantic">
  <h2> Semantic </h2>
  <h2> Semantic HTML elements </h2>
  <p> Semantic HTML elements are tags in HTML, They help define what the content is, such as a header, footer, main content, or a list item.</p>
  <pre><code> article>, aside>, header>, nav>, and section>.  </code></pre>
  <h2 class="mt-4"> Benefits of Using Semantic HTML </h2>
  Improved SEO, Enhanced Accessibility, Clearer Structure
  
  <h2 class="mt-4"> Non-semantic HTML elements </h2>
  do not provide information about the content <br> like div> div> and span> span>
  <hr>
</div>

<div id="less">
<p> 
 <strong> What is Sass? </strong> <br>
Sass is a CSS preprocessor — a scripting language that extends CSS by adding features that regular CSS doesn't have.
</p>

<p>
✅ Key Features of Sass<br>
Variables	- Store colors, font-sizes, etc. <br>
Nesting - 	Nest CSS selectors in a readable way<br>
Partials	- Split CSS into smaller files and @import them <br>
Mixins	- Reuse chunks of CSS with parameters <br>
Inheritance	- Use @extend to share styles between selectors <br>
Functions - 	Create your own functions for logic in styles <br>
</p>

<p> 
  🧪 Sass vs SCSS
Sass has two syntaxes: <br>
Sass (indented syntax) – no curly braces {} or semicolons ;<br>
SCSS (Sassy CSS) – most popular and looks like regular CSS with added power<br>
</p>


  <h2> Less, Sass, and SCSS </h2>
  <p> Less, Sass, and SCSS are all CSS preprocessors that extend CSS by adding features like variables, nesting, mixins, and functions.  </p>
  <pre>
    <code>
      // scss variable
      $primary-color: blue;
    .button {
      color: $primary-color;
      padding: 10px;
    }
    </code>
  </pre>
  
  <pre>
    <code>
      // nesting in scss  
      .navbar {
          background: #333;
          padding: 10px;
        
          .menu {
            list-style: none;
            padding: 0;
        
            li {
              display: inline-block;
              margin-right: 10px;
        
              a {
                text-decoration: none;
                color: white;
        
                &:hover {
                  color: yellow;
                }
              }
            }
          }
        }
    </code>
  </pre>
  
  <pre>
    <code>
      //Mixins in SCSS
    
      @mixin button-style {
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
      }
      
      .btn {
        @include button-style;
        background: blue;
        color: white;
      }
      
      .btn-danger {
        @include button-style;
        background: red;
      }
    </code>
  </pre>
  
  <pre>
    <code>
      //sass
    $primary-color: blue
    .button
      color: $primary-color
      padding: 10px
    
      //loop 
      @each $size, $padding in (small: 5px 10px, medium: 10px 20px, large: 15px 30px) {
        .button--#{$size} {
          padding: $padding;
        }
      }
  
    </code>
  </pre>
</div>

<div id="database">
<h2> What are Database Technologies? </h2>
Database technologies are systems that allow you to store, manage, retrieve, and manipulate data efficiently. <br>
They help applications (like web apps, mobile apps, etc.) to:<br>
Save user data (like name, email, orders, etc.)<br>
Search and filter data<br>
Update or delete data<br>
Maintain data integrity and security<br>
----------
Common Types of Databases:<br>
1. Relational Databases (SQL)<br>
Store data in tables (rows & columns)<br>
Use Structured Query Language (SQL) to interact<br>
Relationships can be defined between tables<br>

🛠️ Examples:<br>
MySQL (very popular, open-source)<br>
PostgreSQL<br>
Oracle Database<br>
SQL Server (Microsoft)<br>
2. Non-Relational Databases (NoSQL)<br>
Store data in formats like JSON, key-value, documents, graphs<br>
More flexible for large-scale, unstructured data<br>
<br>
🛠️ Examples:<br>
MongoDB (document-based)<br>
Redis (key-value)<br>
Firebase Realtime DB / Firestore<br>
Cassandra<br>

<h2> What is MySQL? </h2>

MySQL is a relational database management system (RDBMS) that:<br>
Uses SQL (Structured Query Language)<br>
Organizes data into tables<br>
Is free and open-source (owned by Oracle)<br>
Commonly used in web development with PHP, Node.js, and many backend frameworks<br>

📦 MySQL Core Concepts:<br>
Concept	Description<br>
Database	A collection of tables<br>
Table	A structure to store rows of data<br>
Row	A single data record<br>
Column	A field or property of the record<br>
Primary Key	Unique identifier for each row<br>
Foreign Key	Creates a relationship between tables<br>


</div>

<div id="position"> 
  <h2> Position </h2>
  <p> <strong> Relative </strong> - The element moves relative to its normal position. </p>
  <p> <strong> Absolute </strong> - The element is positioned relative to the nearest positioned ancestor. </p>
  <p> <strong> Fixed </strong> - The element is positioned relative to the viewport (browser window). </p>
</div>


                        <div class="box shadow p-2 mb-3" id="operator">
                            <h2> Rest Operator </h2>
                            <p> Collects multiple values into a single array or object. </p>
                            <pre>
                                <code>
                                    Function 
                                    function sum(...numbers) {
                                        return numbers.reduce((a, b) => a + b, 0);
                                      }
                                      
                                      console.log(sum(1, 2, 3, 4)); // 10   
                                      
                                      --------------
                                      Destructuring  Array 
                                      const [first, ...rest] = [1, 2, 3, 4];
                                        console.log(first); // 1
                                        console.log(rest);  // [2, 3, 4]
                                      -------------
                                      Destructuring (Object)
                                      const { name, ...details } = {
                                        name: "Alice",
                                        age: 25,
                                        city: "NY",
                                      };
                                      
                                      console.log(name);    // "Alice"
                                      console.log(details); // { age: 25, city: "NY" }                                      

                                </code>
                            </pre>

                            <h2> Spread Operator </h2>
                            <p> Expands an array or object into individual elements or key-value pairs. </p>
                            <p> Array </p>

                            <pre>
                                <code>
                                            const arr1 = [1, 2];
                                            const arr2 = [...arr1, 3, 4]; 
                                            console.log(arr2); // [1, 2, 3, 4]
                                ..........
                                Object clonning
                                const user = { name: "Alice" };
                                const updatedUser = { ...user, age: 30 };
                                console.log(updatedUser); // { name: "Alice", age: 30 }
                                -------------
                                Function 
                                const numbers = [1, 2, 3];
                                console.log(Math.max(...numbers)); // 3
                                </code>
                            </pre>
                        </div>
						
						
						
						
<div class="box shadow p-2 mb-3" id="secondHighestsalarys">
                            <h2> Second Highest Salary </h2>

                            <pre>
                                <code>
								
const salaries = [5000, 7000, 6000, 8000, 9000];
const uniqueSalaries = [...new Set(salaries)]; // Remove duplicates
uniqueSalaries.sort((a, b) => b - a); // Sort descending
const secondHighest = uniqueSalaries[1];
console.log(secondHighest); // Output: 8000
								</code>
								</pre>
								
<pre>
<code>
const employees = [
  { name: "Alice", salary: 5000 },
  { name: "Bob", salary: 7000 },
  { name: "Charlie", salary: 6000 },
  { name: "David", salary: 8000 },
  { name: "Eva", salary: 9000 },
];

const salaries = [...new Set(employees.map(e => e.salary))];
salaries.sort((a, b) => b - a);

const secondHighest = salaries[1];
console.log(secondHighest); // Output: 8000

								</code>
								</pre>
							
<h2> Angular </h2>

<pre>
<code>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-employee',
  templateUrl: './employee.component.html',
})
export class EmployeeComponent implements OnInit {
  employees = [
    { name: 'Alice', salary: 5000 },
    { name: 'Bob', salary: 7000 },
    { name: 'Charlie', salary: 6000 },
    { name: 'David', salary: 8000 },
    { name: 'Eva', salary: 9000 },
  ];

  secondHighestSalary: number | null = null;

  ngOnInit() {
    this.secondHighestSalary = this.getSecondHighestSalary(this.employees);
    console.log('Second highest salary:', this.secondHighestSalary);
  }

  getSecondHighestSalary(data: { name: string; salary: number }[]): number | null {
    const uniqueSalaries = [...new Set(data.map(emp => emp.salary))];
    if (uniqueSalaries.length < 2) return null; // Edge case

    uniqueSalaries.sort((a, b) => b - a);
    return uniqueSalaries[1];
  }
}


HTML
p>Second Highest Salary: {{ secondHighestSalary }} p>

----------------------------

import { Component, OnInit } from '@angular/core';
import { EmployeeService } from './employee.service';
import { from } from 'rxjs';
import { map, toArray, distinct, switchMap, filter } from 'rxjs/operators';

@Component({
  selector: 'app-employee',
  templateUrl: './employee.component.html',
})
export class EmployeeComponent implements OnInit {
  secondHighestSalary: number | null = null;

  constructor(private employeeService: EmployeeService) {}

  ngOnInit() {
    this.employeeService.getEmployees().pipe(
      switchMap(employees => from(employees.map(e => e.salary))),  // flatten to salary stream
      distinct(), // remove duplicates
      toArray(), // collect into array again
      map(salaries => salaries.sort((a, b) => b - a)), // sort descending
      map(sorted => sorted.length > 1 ? sorted[1] : null) // get second highest
    ).subscribe(second => {
      this.secondHighestSalary = second;
      console.log('Second highest salary:', second);
    });
  }
}

</code>
</pre>			
</div>

<div id="htmljs"> 
<h2> HTML JS </h2>

<h2> Simple Toggle sidebar menu </h2>
<pre>
  <code>

    //CSS 
    .sidebar {
  position: fixed;
  top: 0;
  left: -220px;
  width: 200px;
  height: 100%;
  background: #000;
  color: white;
  padding: 15px;
  transition: left 0.3s ease;
  z-index: 1000;
}
.sidebar a {
  color: white;
  text-decoration: none;
  display: block;
  margin: 10px 0;
}
.sidebar.active {
  left: 0;
}

button {
  font-size: 18px;
  cursor: pointer;
}

.close-btn {
  background: none;
  border: none;
  color: white;
  font-size: 24px;
  float: right;
  margin-bottom: 10px;
  cursor: pointer;
}

//HTML 
button onclick="toggleSidebar()"> Menu /button>
div id="sidebar" class="sidebar">
  button class="close-btn" onclick="toggleSidebar()"> X /button>
  ul>
    li>a href="#">Home /a> /li>
    li>a href="#">About /a> /li>
    li>a href="#">Contact /a> /li>
  /ul>
/div>

// JS 
  function toggleSidebar() {
    document.getElementById("sidebar").classList.toggle("active");
  }

  </code>
</pre>

<h2> Add and remove class </h2>

<pre>
  <code>
    //css 
.box {
  width: 100px;
  height: 100px;
  background-color: lightgray;
}

.active {
  background-color: lightgreen;
}

//html 
div class="mt-5">
button id="myButton">Click Me/button>
div id="box" class="box">Hello/div>
/div>

//JS 
document.getElementById('myButton').addEventListener('click', function() {
  const box = document.getElementById('box');
  box.classList.toggle('active');
});

  </code>
</pre>

<h2> Menu with dropdown </h2>

<pre>
  <code>
    /CSS 
    nav {
      background-color: #333;
      padding: 10px 20px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    .menu {
      display: flex;
      list-style: none;
      gap: 20px;
    }

    .menu li {
      position: relative;
    }

    .menu a {
      color: white;
      text-decoration: none;
    }

    .dropdown {
      display: none;
      position: absolute;
      background-color: #444;
      top: 100%;
      left: 0;
      min-width: 150px;
      z-index: 1;
    }

    .dropdown a {
      display: block;
      padding: 10px;
      color: white;
    }

    .menu li:hover .dropdown {
      display: block;
    }

    /* Hamburger menu for mobile */
    .hamburger {
      display: none;
      font-size: 24px;
      cursor: pointer;
    }

    @media (max-width: 768px) {
      .menu {
        display: none;
        flex-direction: column;
        background-color: #333;
        width: 100%;
      }

      .menu.show {
        display: flex;
      }

      .hamburger {
        display: block;
        position: absolute;
        right: 8px;
        top: 0;
      }

      .menu li {
        width: 100%;
      }

      .dropdown {
        position: relative;
      }
    }

    //HTML 
    nav class="mt-5">
    div>MySite /div>
    div class="hamburger" id="hamburger"> &#9776; /div>
    ul class="menu" id="menu">
    li>a href="#">Home /a> /li>
      li>
        a href="#">Services /a>
        ul class="dropdown">
          li> a href="#">Design /a></li>
          li> a href="#">Development /a></li>
          li> a href="#">SEO /a>/li>
        /ul>
      /li>
      li>a href="#">About/a>/li>
      li>a href="#">Contact/a>/li>
    /ul>
  /nav>

  //JS 

    const hamburger = document.getElementById('hamburger');
    const menu = document.getElementById('menu');

    hamburger.addEventListener('click', () => {
      menu.classList.toggle('show');
    });

  </code>
</pre>
<h2> Tabs </h2>

<pre>
  <code>
    //css 

     .tabs {
      display: flex;
      margin-bottom: 10px;
    }

    .tab {
      padding: 10px 20px;
      border: 1px solid #ccc;
      border-bottom: none;
      cursor: pointer;
      background-color: #f0f0f0;
    }

    .tab.active {
      background-color: #fff;
      border-top: 2px solid #007BFF;
      font-weight: bold;
    }

    .tab-content {
      border: 1px solid #ccc;
      padding: 20px;
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    //html 
    div class="tabs mt-5">
    div class="tab active" data-tab="tab1">Tab 1/div>
    div class="tab" data-tab="tab2">Tab 2/div>
    div class="tab" data-tab="tab3">Tab 3/div>
  /div>

  div class="tab-content active" id="tab1">
  h3>Tab 1 Content /h3>
    p>This is content for Tab 1. /p>
  /div>
  div class="tab-content" id="tab2">
    h3>Tab 2 Content /h3>
    p>This is content for Tab 2. /p>
  /div>
  div class="tab-content" id="tab3">
    h3>Tab 3 Content /h3>
    p>This is content for Tab 3. /p>
  /div>


//JS 

    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.tab-content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs and contents
        tabs.forEach(t => t.classList.remove('active'));
        contents.forEach(c => c.classList.remove('active'));

        // Add active class to the clicked tab and matching content
        tab.classList.add('active');
        const activeContent = document.getElementById(tab.getAttribute('data-tab'));
        activeContent.classList.add('active');
      });
    });


  </code>
</pre>

</div>


<div id="formvalidation"> 
<h2> Form Validation </h2>

<pre>
  <code>
    
HTML 

form id="myForm" onsubmit="return validateForm()">
  label>Name: /label>
  input type="text" id="name" /> br />

  label>Email: /label>
  input type="text" id="email" />  br />

  label>Phone: /label>
  input type="text" id="phone" /> br />

  button type="submit">Submit /button>
/form>
p id="errorMsg" style="color: red;"> /p>


JS 

function validateForm() {
  const name = document.getElementById("name").value.trim();
  const email = document.getElementById("email").value.trim();
  const phone = document.getElementById("phone").value.trim();
  const errorMsg = document.getElementById("errorMsg");

  // Name validation
  if (name === "") {
    errorMsg.textContent = "Name is required.";
    return false;
  }

  // Email validation
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailPattern.test(email)) {
    errorMsg.textContent = "Please enter a valid email.";
    return false;
  }

  // Phone validation (10 digits)
  const phonePattern = /^[0-9]{10}$/;
  if (!phonePattern.test(phone)) {
    errorMsg.textContent = "Phone must be 10 digits.";
    return false;
  }

  errorMsg.textContent = ""; // Clear error if everything is valid
  alert("Form submitted successfully!");
  return true;
}

  </code>
</pre>

</div>



<div id="increasevalue"> 
<h2> On click Increase and Decrease Value </h2>

<pre>
  <code>
  HTML 

  div class="quantity-control">
  button class="minus-btn"> -  /button>
  input type="number" id="quantity" value="0">
  button class="plus-btn"> +  /button>
/div>

JAVASCRIPT


  const quantityInput = document.getElementById('quantity');
	const minusButton = document.querySelector('.minus-btn');
	const plusButton = document.querySelector('.plus-btn');

	minusButton.addEventListener('click', () => {
	  let currentValue = parseInt(quantityInput.value);
	  if (currentValue > 0) {
		quantityInput.value = currentValue - 1;
	  }
	});

	plusButton.addEventListener('click', () => {
	  let currentValue = parseInt(quantityInput.value);
	  quantityInput.value = currentValue + 1;
	});


  </code>
</pre>

</div>


<div id="cartbtn"> 
<h2> Update Cart Button </h2>

<pre>
  <code>
    HTML 

div class="cart-icon"> span id="cart-quantity">0  /span> /div>
button class="add-to-cart">Add to Cart  /button>

JAVASCRIPT 

const cartIcon = document.querySelector(".cart-icon");
const cartQuantity = document.getElementById("cart-quantity");
const addToCartButton = document.querySelector(".add-to-cart");

let cartItems = 0; // Initialize the cart item count

addToCartButton.addEventListener("click", () => {
  cartItems++;
  cartQuantity.textContent = cartItems; // Update the icon with the new quantity
  // Add additional logic here to persist the cart data (e.g., using local storage or an API)
});

  </code>
</pre>

</div>


<div id="outoffinput"> 
<h2> Display text outof input </h2>

<pre>
  <code>
    HTML
    input type="text" id="myInput" placeholder="Type something...">
    p id="displayArea"> /p>

    javascript

    const inputElement = document.getElementById("myInput");
    const displayElement = document.getElementById("displayArea");

    inputElement.oninput = function() {
      displayElement.innerText = inputElement.value;
    };

  </code>
</pre>

</div>

<div id="sql">
<h2> 1. What is the difference between DELETE, TRUNCATE, and DROP? </h2>
<ul>
  <li> DELETE: Removes rows, can use WHERE, logs each row (slow but safe). </li>
  <li> TRUNCATE: Removes all rows, faster, can’t use WHERE, minimal logging. </li>
  <li> DROP: Deletes the entire table structure. </li>
</ul>
</div>


<div id="acid">
<h2> 1. What are the ACID properties of a transaction? </h2>
<ul>
  <li> Atomicity: All or nothing. </li>
  <li> Consistency: Data remains valid. </li>
  <li> Isolation: Transactions don’t interfere. </li>
  <li> Durability: Once committed, it's saved even if system crashes. </li>
</ul>
</div>


<div id="clustered">
<h2> 1. What is a clustered index vs. non-clustered index? </h2>
<ul>
  <li> Clustered: Sorts and stores data physically. </li>
  <li> Non-clustered: Stores pointers to the data. </li>
</ul>
</div>


<div id="normalization">
<h2> 1. What is normalization? Name its types. </h2>
<ul>
  <li> Process of organizing data to reduce redundancy. </li>
  <li> Types: 1NF, 2NF, 3NF, BCNF, 4NF, 5NF. </li>
</ul>
</div>


<div id="key">
<h2> What is a foreign key? </h2>
<ul>
  <li> A field that references the primary key of another table. </li>
  <li> Enforces referential integrity. </li>
</ul>
</div>


<div id="join">
<h2> What is the difference between INNER JOIN and LEFT JOIN? </h2>
<ul>
  <li> INNER JOIN: Returns only matching rows. </li>
  <li> LEFT JOIN: Returns all rows from the left, and matches from the right. </li>
</ul>
</div>


<div id="view">
<h2> What is a view? </h2>
<ul>
  <li> A virtual table based on a query.</li>
  <li> Used for abstraction and security. </li>
</ul>
</div>


<div id="procedure">
<h2>What is a stored procedure? </h2>
<ul>
  <li> A precompiled collection of SQL statements. </li>
  <li> Improves performance and security. </li>
</ul>
</div>


<div id="cte">
<h2> What is the use of CTE (Common Table Expression)? </h2>
<ul>
  <li> Temporary result set used for recursion or complex joins. </li>
</ul>
</div>


<div id="tables">
<h2> What are temp tables? </h2>
<ul>
  <li> Temporary tables stored in tempdb, used for intermediate processing. </li>
</ul>
</div>

<div id="trigger">
<h2> What is a trigger?</h2>
<ul>
  <li> An automatic action executed when a table event (INSERT/UPDATE/DELETE) occurs. </li>
</ul>
</div>


<div id="execution">
<h2> What is an execution plan? </h2>
<ul>
  <li> Shows how SQL Server executes a query. </li>
  <li> Used for performance tuning. </li>
</ul>
</div>


<div id="indexing">
<h2> What is indexing and how does it improve performance? </h2>
<ul>
  <li> Creates a data structure to improve query speed. </li>
  <li> Reduces the need for full table scans. </li>
</ul>
</div>


<div id="deadlock">
<h2> What is a deadlock? </h2>
<ul>
  <li> When two processes wait on each other to release resources. </li>
  <li> Solved by proper indexing, consistent order, or timeout. </li>
</ul>
</div>


<div id="clause">
<h2> Difference between WHERE and HAVING clause? </h2>
<ul>
  <li> WHERE: Filters rows before grouping. </li>
  <li> HAVING: Filters groups after aggregation. </li>
</ul>
</div>


<div id="wfunctions">
<h2> What are window functions? </h2>
<ul>
  <li> Functions like ROW_NUMBER(), RANK() that perform calculations across rows related to the current row. </li>
</ul>
</div>


<div id="transaction">
<h2> What is a transaction log? </h2>
<ul>
  <li> A file that records all transactions and modifications made by SQL Server. </li>
</ul>
</div>


<div id="isnull">
<h2>  What is the difference between ISNULL() and COALESCE()? </h2>
<ul>
  <li> Both handle NULLs. </li>
  <li> ISNULL() returns first non-null value; COALESCE() can handle multiple values and different data types. </li>
</ul>
</div>

<div id="union">
<h2>  What is the difference between UNION and UNION ALL? </h2>
<ul>
  <li> UNION: Removes duplicates. </li>
  <li> UNION ALL: Includes duplicates (faster). </li>
</ul>
</div>

<div id="optimize">
<h2>  How do you optimize a SQL query? </h2>
<ul>
  <li> Use proper indexes </li>
  <li> Avoid SELECT * </li>
  <li> Use EXISTS instead of IN </li>
  <li> Avoid cursors </li>
  <li> Review execution plans </li>
</ul>
</div>


</div>

<button id="toTopBtn" title="Go to top">↑</button>
<script src="script.js"></script>
  </body>
</html>
