<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <title> Angular </title>
    <style>
      #toTopBtn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: #333;
  color: white;
  cursor: pointer;
  padding: 0;
  border-radius: 50%;
  font-size: 18px;
  display: none; /* Hidden by default */
  transition: background-color 0.3s;
  width: 30px;
  height: 30px;
}

#toTopBtn:hover {
  background-color: #555;
}
h2 { font-size: 18px; font-weight: 600;}

    </style>
  </head>
  <body>
   <div class="container">

    <ul class="index">
      <li> <a href="#component"> abc </a> </li>
    </ul>

 <h2>INTRO</h2>   
<div class="box shadow p-2 mb-3">
As a UI and Frontend Developer, my primary role was to design, develop, and optimize complex user interfaces for web applications. I worked extensively with Angular to build reusable components, implement routing, handle state management, and integrate APIs efficiently. I collaborated closely with designers and backend developers to ensure a seamless and high-performing user experience.
In addition to frontend development, I have strong design skills and experience working with Figma and Photoshop. I have designed UI layouts, website templates, and even complete dashboards for admin panels, ensuring intuitive and user-friendly interfaces.
I was responsible for creating and maintaining UI architectures, optimizing application performance, and ensuring cross-browser compatibility. I also implemented custom Angular directives, pipes, and services to enhance code reusability and maintainability.
Moreover, I followed best practices in CSS frameworks like Tailwind and Bootstrap to ensure responsiveness and accessibility. I also mentored junior developers, conducted code reviews.
</div>



<h2> ANGULAR BASIC </h2>
<div class="box shadow p-2 mb-3" id="mvc">
<p><strong>  MVC and MVVM (Model-View-ViewModel)  </strong></p>
<p> ** MVC (Model-View-Controller) is a design pattern that separates an application into three main components:
  <ol>
    <li> <strong> Model: </strong> Represents data and business logic (e.g., database, API). </li>
    <li> <strong> View: </strong> The UI layer that displays data to the user. </li>
    <li> <strong> Controller: </strong> Manages user inputs and updates the Model or View. </li>
  </ol>
</p>
<p> ** <strong> HOW WORK MVC  </strong>
  1. The Controller receives user input (e.g., a button click).
  2. The Controller updates the Model (business logic).
  3. The Model notifies the View, and the View updates accordingly. 
</p>
<p>
      <strong> MVVM </strong> 
     <p> <strong> MVVM (Model-View-ViewModel) </strong> is a software architectural pattern that is commonly used in Angular applications, providing a clean separation of concerns between different components of an application. </p> 
     <p> <strong> Model -  </strong>Represents the application’s data and logic, It is the part of the application that manages the state, and it can be composed of services, APIs, </p>
     <p> <strong>View :- </strong> Represents the UI (user interface) elements that the user interacts with, such as buttons, inputs, forms, etc. | View is typically defined using HTML and CSS, and it’s tied to the template of a component. </p> 
     <p> <strong> ViewModel :- </strong> ViewModel holds the data and logic needed to present the Model’s data in a way that the View can easily display.  It is represented by the component in Angular, which binds the data and defines the behavior that will be reflected in the view. two-way data binding (via ngModel) allows the ViewModel. </p> 
</p>
</div>   


<h2 id="component"> COMPONENTS </h2>
<div class="box shadow p-2 mb-3" id="mvc">
<p> Angular Component is the building block of every Angular application. Every angular application is made up of one more Angular Component. </p>
<pre><code> @Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet],
  templateUrl: './app.component.html',
  styleUrl: './app.component.css'
}) </code> </pre>
<p> @Component: A decorator used to convert a normal Typescript class to Angular Component.
</p>
</div>


<h2 id="root"> app-root <app-root></app-root> </h2>
<div class="box shadow p-2 mb-3" id="mvc">
<p> <strong> app-root: </strong> It is the selector/name of the component and it is specified using selector meta data of the component's decorator. </p>  
 <p> <strong> app.component.html: </strong> It is the HTML template document associated with the component. </p> 
 <p> <strong> AppComponent: </strong> Its property (title) is used in the HTML template to set the title of the application. </p> 
</div>



<div class="box shadow p-2 mb-3" id="template">
<h2> TEMPLATE </h2>
<p>   Template is basically a super set of HTML. Template includes all the features of HTML and provides additional functionality to bind the component data into the HTML and to dynamically generate HTML DOM elements. <br> 
<strong> Template can be categorised into two items :- </strong> <br> 
  Data binding {{ title }}, Directives *ngIf="canShow" </p>
</div>


<div class="box shadow p-2 mb-3" id="modules">
<h2>  MODULES, Bootstrap </h2>
<p> Angular Module is basically a collection of related features/functionality. It groups multiple components and services under a single context. </p>
<pre>
  <code>
    import { BrowserModule } from '@angular/platform-browser'; 
    import { NgModule } from '@angular/core'; 
    import { AppComponent } from './app.component'; @NgModule({ 
    declarations: [ 
      AppComponent 
     ], 
     imports: [ 
      BrowserModule 
     ], 
     providers: [], 
     bootstrap: [AppComponent] 
     }) 
     export class AppModule { }
  </code>
</pre>
<ol>
  <li> <strong> NgModule </strong> decorator is used to convert a plain Typescript/JavaScript class into Angular module. </li>
  <li> <strong> declarations: [AppComponent] </strong> - Declarations option is used to include components into the AppModulemodule. </li>
  <li> <strong> bootstrap: </strong> [AppComponent], Bootstrap option is used to set the root component of the AppModulemodule. </li>
  <li> <strong> providers: [], </strong> Providers option is used to include the services for the AppModulemodule. </li>
  <li> <strong> import{} </strong> imports option is used to import other modules into the AppModulemodule. </li>
  </ol>
</div>

<div class="box shadow p-2 mb-3" id="services">
<h2>  SERVICES </h2>
<p>   Services are plain Typescript/JavaScript class providing a very specific functionality. They will do a single task and do it best. The main purpose of the service is to make a certain feature reusable. </p>
</div>

<div class="box shadow p-2 mb-3" id="metadata">
  <h2>  METADATA </h2>
  <p>  Angular, metadata is used to provide additional information about a class, component, or service. </p>
  </div>


  <div class="box shadow p-2 mb-3" id="angularrun">
    <h2>  How to run angular Project ? </h2>
    <p> When we run an Angular application, index.html is the first file that is loaded on the browser. Then, <br> 
      <strong> Browser </strong> looks for the main <strong> TypeScript file, i.e. src/main.ts </strong> <br> 
      Which is the entry point of Angular application. <br>
      <strong> Now, </strong> this file bootstraps the <strong> AppComponent (src/app.component.ts), </strong> the root component of every Angular application. <br> 
      The AppComponent renders its template (src/app.component.html) and uses the corresponding styles (src/app.component.css). <br> 
      <strong> AppComponent </strong> name, i.e., app-root is used inside the <strong> src/index.html </strong> so that view of the angular application can be rendered. </p>
  </div>


  <div class="box shadow p-2 mb-3" id="angularcli">
    <h2>  ANGULAR CLI </h2>
    <p>   Angular CLI (Command Line Interface) is a powerful tool that helps automate and streamline the development process for Angular applications. It provides a set of commands for creating, managing, and building Angular projects. </p>
  </div>

  <div class="box shadow p-2 mb-3" id="angularcontroller">
    <h2>  Controllers in Angular </h2>
    <p> In AngularJS (Angular 1.x), controllers were used to manage the application's logic and data binding. However, in modern Angular (2+), controllers are replaced by components. </p>
  </div>

  <div class="box shadow p-2 mb-3" id="angularspa">
    <h2>  SPA and CHALLENGING WORK / SHARED SERVICES </h2>
    <p>  Single Page Application (SPA) is a web application that dynamically updates content without reloading the entire page. 
      Faster Page Loads ,  Smooth User Experience, Efficient Data Fetching <strong> Examples - GMAIL, FACEBOOK, NETFLIX, TWITTER </strong> </p>
    <h2> CHALLENGING WORK </h2>
      <p> I was working on an Angular project where we used a reactive form with a select box for gender (Male and Female) multiple times across different components. Later, we realized that instead of repeating the same logic, we could create a reusable service for gender options, making the implementation more efficient and maintainable. </p>

    <h2> SHARED SERVICES  </h2>
    <pre>
      <code>
        genders = [
            {"id": "male", "name": "Male"},
            {"id": "female", "name": "Female"},
            {"id": "other", "name": "Other"}
          ]

        select 
        option -  *ngFor="let gender of genders" value="{{gender.id}}" ,  {{gender.name}}
          
      </code>
    </pre>
  </div>


  <div class="box shadow p-2 mb-3" id="architecture">
    <h2> Angular Architecture </h2>
    <p>   Angular is a front-end framework developed by Google for building dynamic single-page applications (SPAs). <br> It follows a component-based architecture where the entire application is structured into modular, reusable components. <br> At its core, Angular applications are made up of modules, components, templates, directives, services, and dependency injection.<br> The root module, typically named AppModule, acts as the entry point of the application and can include multiple feature modules to organize different functionalities. These modules help in maintaining scalability by dividing the application into separate logical parts. </p>
    <p>  A component in Angular is the fundamental building block of the UI. <br> Each component consists of three parts: an HTML template that defines the structure, a TypeScript class that contains business logic, and a CSS file that handles styling.  </p>
    <p>  To enhance the functionality of templates, Angular provides directives. Structural directives, such as *ngIf and *ngFor, modify the DOM by adding or removing elements dynamically, while attribute directives, such as [ngClass] and [ngStyle], change the appearance or behavior of elements. Additionally, pipes are used to transform and format data within templates. </p>
    <p>  Services are singleton objects that can be injected into multiple components using Angular’s dependency injection (DI) system. This ensures better code reusability and separation of concerns. For handling HTTP requests. </p>
    <p>  One of Angular’s most powerful features is routing, which enables navigation between different views without requiring a full page reload. The RouterModule manages the application’s routes and allows users to define URL-based navigation paths for different components. </p>
    <p> Under the hood, Angular’s change detection mechanism optimizes performance by updating only the necessary parts of the UI when data changes. It employs a unidirectional data flow with the ability to detect and update changes efficiently.  </p>
    <p> Overall, Angular’s structured approach, modularity, and built-in functionalities make it an ideal choice for developing large-scale enterprise applications.  </p>
  </div>


  <div class="box shadow p-2 mb-3" id="newfeaturs">
    <h2> NEW FEATURES IN ANGULAR  </h2>
    <p> <strong> => New Features and Updates in Angular 15 </strong></p> 
    <ol>
      <li>Standalone API – No Need for NgModules</li>
      <li> Directive Composition API – Reuse Logic Easily <br> 
        * Allows directives to be combined into a single component easily.  </li>
        <li> Improved Performance with Better Tree Shaking </li>
        <li> <strong> Enhanced Router Features </strong> <br> </li>
        <li> * <strong> Lazy loading components directly (without NgModule). </strong>
          const routes: Routes = [
          { path: 'dashboard', loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent) }]; </li>
        <li> Stable Image Directive (NgOptimizedImage) - NgOptimizedImage improves image performance. </li>
        <li> Better Material UI Components </li>
    </ol>

    <p> <strong> => New Features and Updates in Angular 19 </strong></p> 
    <p>  ​Angular 19, released in November 2024, </p>
    <ol>
      
      <li> Standalone Components by Default </li>
      <li> Incremental Hydration (Developer Preview) <br>
        * This feature enhances server-side rendering by allowing developers to incrementally hydrate parts of their application. Using the @ defer syntax </li>
      <li> Route-Level Render Mode (Developer Preview) <br> * Angular 19 introduces the ability to control the rendering strategy of individual routes </li>
      <li> Enhanced Reactivity with linkedSignal and resource() </li>
      <li> Angular Material: New Time Picker Component </li>
      <li> Two-Dimensional Drag & Drop in CDK </li>
    </ol>
    </div>


    <div class="box shadow p-2 mb-3" id="life-cycle">
      <h2> LIFE CYCLE </h2>
      <p> <strong> Lifecycle hooks in Angular are special methods that get called at different stages of a component’s lifecycle. </strong></p>

      <p> <strong> constructor </strong> - for variable initialization </p>
      <p> <strong> ngOnInit(){}  </strong> - Called once after component initialization </p>
      <p> <strong> ngDoCheck() </strong> - Called during every change detection cycle </p>
      <p> <strong> ngOnChanges() </strong> -  Called when input properties change  </p>
      <pre>
        <code>
          Examples - 
          => Child component --- 
          @Input() item: any;
          ngOnChanges(){
          alert("Data has been updated by parent component...")
          }
          HTML -- 
          {{item}}
      
       => PARENT COMPONENT
          name = 'coding'
          fun(){
           this.name = "Value has been chaged"
           }
          HTML --- 
          app-child item={{name}}> app-child
          button click="fun()"> click me button
        </code>
      </pre>

      <p><strong> ngAfterContentInit() </strong> - Called after content projection (<ng-content>) is initialized </p>
      <p> <strong> ngAfterContentChecked()</strong> - Called after projected content is checked </p>
      <p> <strong> ngAfterViewInit() </strong> -  This hook is called after Angular has fully initialized the component's view <br> 
        (i.e., after the HTML template is rendered and child components are loaded).  </p>
      <p> <strong> ngAfterViewChecked() </strong>	- Called after the component’s and child views are checked </p>
      <p> <strong> ngOnDestroy() </strong> Called just before the component is destroyed </p>
      </div>


      <div class="box shadow p-2 mb-3" id="optimize">
        <h2> OPTIMIZE ANGULAR PAGE </h2>
        <ol>
          <li> Optimize Change Detection </li>
          <li> Lazy Loading </li>
          <li> Reduce Bundle Size ( AOT AHEAD OF TIME ) </li>
          <li> Optimize Third-Party Libraries </li>
          <li> Optimize CSS & Styles, Otimize http, Minimize CSS & Use Critical CSS, CSS minification, Web Workers </li>
          <li> USE track by </li>
        </ol>
        <pre>
          <code>
            *ngFor="let item of items; trackBy: trackByFn">{{ item.name }}
              this.http.get('https://api.example.com/data', { cache: 'force-cache' });
          </code>
        </pre>
        </div>


        <div class="box shadow p-2 mb-3" id="accessibility">
          <h2> Accessibility (A11Y) </h2>
          <p> Make your UI inclusive for everyone (including users with disabilities). </p>
          <p> Add alt text for images. </p>
          <p> Use ARIA attributes for better screen reader support. </p>
          <p> Ensure high color contrast for readability </p>
          <p> Minify CSS, JS and enable Gzip compression. </p>
          <pre><code> const routes: Routes = [
            { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) },
            { path: '**', redirectTo: 'feature' } // Wildcard route (optional)
          ]; </code></pre>
         </div>


         <div class="box shadow p-2 mb-3" id="apiservices">
          <h2> API CALL RESTful APIs -- API serives  </h2>
          <p> Angular, RESTful APIs allow the frontend to communicate with a backend server by making HTTP requests. Angular provides the HttpClient module to perform CRUD (Create, Read, Update, Delete) operations with APIs. </p>
          <pre><code>
            ngOnInit() {
              this._http.get('users/user/details/'+this.user_id).subscribe((resposne: any) => {
                this.user = resposne.user
                console.log(resposne);
              })
            }
          </code></pre>
          </div>


          <div class="box shadow p-2 mb-3" id="validation">
            <pre><code>
              lead_form!: FormGroup
lead_fields = {
  name     : ['', Validators.required],
  email    : ['', Validators.required],
}
constructor( private _fb    : FormBuilder ){
  this._route.queryParams.subscribe(params => { this.tenant_id = params['id']})
}
ngOnInit(){this.initializeForm()}
initializeForm(){
  this.lead_form = this._fb.group(this.lead_fields)
  this.getLeads()
}
getLeads(){
  let params = [{"key": "tenant_id", "value": this.tenant_id},{"key": "limit", "value": 100}]
  this._http.get('leads/leads/', params).subscribe((response:any) => {
    this.leads = response;
    this.action = "Add"
  },(error: any) => {this.errorMessage(error)})
}
            </code></pre>
          </div>


          <div class="box shadow p-2 mb-3" id="crud">
  <h2> CRUD </h2>
  CREATE 
  <pre><code>
    
  createLead(){
    this._http.post('leads/leads/', this.setPayload(this.lead_form.value)).subscribe((response: any) => {
      this.afterAction("Lead Saved")
    },(error: any) => {this.errorMessage(error)})
  }
  
  EDIT
  setPayloadForEdit(form: any){
    return {
      "name"     : form.name,
      "email"    : form.email,
    }
  }
  editLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)

    // delete payload.tenant_id
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)})
  }


  updateLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)
    // delete payload.tenant_id
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)})
  }

  deleteLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    this._http.delete('leads/leads/'+this.lead_id, params).subscribe((response:any) => {
      this.afterAction("Lead Deleted")
    },(error: any) => {this.errorMessage(error)})
  }
  </code></pre>
</div>



<div class="box shadow p-2 mb-3" id="upgrade">
<h2> HOW TO UPGRADE OLD VERSION TO NEW VERSION </h2>  
<div>
=> Always backup your project before upgrading.
=> Use Git commits to track changes at each step.
1. Check the Current Angular Version <br>
ng version
2. Update Angular CLI Globally <br>
npm install -g @angular/cli 
3. ng update @angular/core@16 @angular/cli@16 <br>
4. Update Other Dependencies <br>
ng update
-------------
You should upgrade step by step from Angular 15 → 16 → 17 → 18 → 19 rather than jumping directly from Angular 15 to Angular 19.
If You Try Directly Updating from 15 to 19? <br>
1. dependency conflicts and errors. <br>
2. Some configurations (like angular.json) might break due to missing intermediate updates. <br>
3. Third-party libraries might not support Angular 19 <br>
</div>
</div>


<div class="box shadow p-2 mb-3" id="rxjs">
  <h2> RxJS for Reactive Programming (RxJS) </h2>
 
<p> Difference between </p>  

 <strong> Promise -- </strong>  
// Promise excute immediately when create promises. <br>
// Pomise emit single value. Promise don't have operator . <br>
// Promise cann't be cancel  <br>
<strong> Observable -- </strong> 
// Observable does not start untill subscription. <br> 
// Observable emit multiple value.<br>
// Observable operator like map, filter, reduce. <br>
// Observable can be cancel using unscribe method <br>

<h2 class="mt-4"> * Promises - A Promise in JavaScript represents a value that may be available now, in the future, or never. </h2>
<pre>
  <code>
    let myPromise = new Promise((resolve, reject) => {
      let success = true; // Change this to false to see the reject case
      setTimeout(() => {
        if (success) {
          resolve("Operation Successful!");
        } else {
          reject("Something went wrong!");
        }
      }, 2000);
    });
    myPromise
      .then(result => console.log(result)) // Runs when promise is resolved
      .catch(error => console.log(error)); // Runs when promise is rejected  
  </code>
</pre>

<p> <strong> Observable is a stream of data that can emit multiple values over time. You can subscribe to an Observable to receive these values. </strong></p>

<pre><code>
  myObservable: Observable<number>;
    ngOnInit() {
      this.myObservable = new Observable(observer => {
        let count = 1;
        setInterval(() => {
          observer.next(count++); // Emits a value every second
        }, 1000);
  
      });
      this.myObservable.subscribe(value => {
        console.log('Received:', value);
      });
    }
</code></pre>

<h2> RxJS Operators </h2>
<p><strong> Filtered Values: {{ values }} </strong></p>

<pre><code>
  ngOnInit() {
    const numbers$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9);
    numbers$.pipe(
      filter(num => num % 2 === 0), // Filter even numbers
      map(num => num * 10) // Multiply each by 10
    )
    .subscribe(result => {
      this.values.push(result);
    });
  }
</code></pre>

<pre>
  <code>
    let observable = new Observable((observer) => {
      setTimeout(() => {
        observer.next("observable is working");
        observer.complete();
      }, 1000)
      })
      
      observable.subscribe({
        next: (result) => console.log(result),
        complete: () => console.log("Observable completed")
      })
  </code>
</pre>

<h2> Example: Converting Promise to Observable </h2>
<pre><code>
  const promise = new Promise((resolve) => {
    setTimeout(() => resolve('Promise resolved!'), 2000);
  });

  // Convert Promise to Observable

  const observable$ = from(promise);
  observable$.subscribe(value => console.log(value));
</code></pre>

<h2> Handling HTTP Request with Observable vs Promise </h2>
<pre>
  <code>
    getData(): void {
      fetch('https://jsonplaceholder.typicode.com/posts')
        .then(response => response.json())
        .then(data => console.log(data))
        .catch(error => console.error(error));
    } 
  </code>
</pre>

<h2> Observable with Multiple Values </h2>
<pre>
  <code>
    const myObservable = new Observable(observer => {
      observer.next('Value 1');
      observer.next('Value 2');
      setTimeout(() => {
        observer.next('Value 3 (after delay)');
        observer.complete(); // Ends the stream
      }, 2000);
    });
    myObservable.subscribe(value => console.log(value));
  </code>
</pre>

<h2>  Cancelling an Observable </h2>
<pre><code>
  const observable$ = interval(1000); // Emits values every second
  const subscription: Subscription = observable$.subscribe(value => console.log(value));
  setTimeout(() => {
    console.log('Unsubscribing...');
    subscription.unsubscribe(); // Stops emissions
  }, 5000);
</code></pre>

</div>


<div class="box shadow p-2 mb-3" id="rxjssubject">
  <h2> RxJS SUBJECT //Create a Shared Service </h2>
  <p>  Subject in RxJS is a special type of Observable that allows values to be multicasted to multiple subscribers. </p>
<p> <strong>  Create a Shared Service </strong></p>
<pre>
  <code>
    private dataSubject = new Subject<string>(); // Create Subject
      data$ = this.dataSubject.asObservable(); // Expose as Observable
      sendData(message: string) {
        this.dataSubject.next(message); // Send data
      }
  
     <strong> Send Data from Component 1 (Sender)  </strong> 
      
      button (click)="sendMessage()">Send Message button
  
      constructor(private dataService: DataService) {}
  
      sendMessage() {
      this.dataService.sendData("Hello from Sender!");
      }
  
      <strong> Receive Data in Component 2 (Receiver) </strong> 
  
      <p>Received: {{ receivedMessage }}</p>
  
    receivedMessage: string = "";
  
    constructor(private dataService: DataService) {}
  
    ngOnInit() {
      this.dataService.data$.subscribe(message => {
        this.receivedMessage = message; // Receive data
      });
    }
  
  </code>
</pre>
</div>


NgRx (Redux for Angular)
<div>
  NgRx is a state management library for Angular applications that implements the Redux pattern using RxJS.
  Uses Actions, Reducers, Store, Effects, and Selectors.

  TS Actions examples - 
  <!-- export const addItem = createAction('[Cart] Add Item', props<{ item: string }>());
  export const removeItem = createAction('[Cart] Remove Item', props<{ item: string }>()); -->
  STATE OF STRUCTURE 
  <!-- export const initialState = { count: 0 };
  export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => ({ count: state.count + 1 })),
  on(decrement, (state) => ({ count: state.count - 1 }))
); -->
NGXS (Simpler alternative to NgRx)
  <!-- @State<number>({ name: 'counter', defaults: 0 })
    export class CounterState {
      @Action(Increment)
      increment(ctx: StateContext<number>) {
        const state = ctx.getState();
        ctx.setState(state + 1);
      }
    } -->
SignalStore
Introduced in Angular 17 as a lightweight, reactive state management solution.
Uses signals instead of Observables.
<!-- count = signal(0);
  increment() {
    this.count.set(this.count() + 1);
  } -->

=> ngRx Store?
ngRx Store is a state management library for Angular applications. It is based on Redux and helps manage application state in a predictable way using actions, reducers, and selectors.
1️⃣ Actions – Define what happens in the app (e.g., "Add Product", "Delete User").
2️⃣ Reducers – Handle state changes based on actions.
3️⃣ State – The single source of truth for the app.
4️⃣ Selectors – Retrieve specific data from the store.
5️⃣ Effects – Handle asynchronous operations like API calls.

<script>
  Installation
ng add @ngrx/store
ng add @ngrx/effects

* Actions
import { createAction } from '@ngrx/store';
export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');
export const reset = createAction('[Counter] Reset');

* Create Reducer
import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';
export const initialState = 0;
export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => state + 1),
  on(decrement, (state) => state - 1),
  on(reset, () => 0)
);

* Register Store
  import { StoreModule } from '@ngrx/store';
  import { counterReducer } from './counter.reducer';
  imports: [
  StoreModule.forRoot({ count: counterReducer }) // Register reducer
  ],

* Store in Components
import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

@Component({
  selector: 'app-counter',
  template: `
    <h1>Counter: {{ count$ | async }}</h1>
    <button (click)="increment()">Increment</button>
    <button (click)="decrement()">Decrement</button>
    <button (click)="reset()">Reset</button>
  `
})
export class CounterComponent {
  count$ = this.store.select('count'); // Select state

  constructor(private store: Store<{ count: number }>) {}

  increment() { this.store.dispatch(increment()); }
  decrement() { this.store.dispatch(decrement()); }
  reset() { this.store.dispatch(reset()); }
}
</script>

----- 
ngRx Store helps manage global state in Angular apps.
It follows Redux principles with actions, reducers, and selectors.
Effects handle async operations like API calls.
Improves scalability, performance, and debugging.

</div>

State Management in Angular
<div>
    State management in Angular is the process of handling application data efficiently across components, services, and routes. Local State, Component State, Service State (App-Level State)
</div>

SIGNALS
<div>
Signals in Angular provide a reactive way to manage and track state changes in a component. They are similar to RxJS observables.
Examples :- 

<h2>Counter: {{ count() }}</h2>

<button (click)="increment()">Increment</button>
<button (click)="decrement()">Decrement</button>

TS - 
count: Signal<number> = signal(0);
increment() { this.count.set(this.count() + 1); }
decrement() { this.count.set(this.count() - 1); }

</div>

Lazy Loading
<div>
  Lazy Loading is an optimization technique in Angular that loads modules or components only when they are needed, instead of loading everything upfront.
  These modules are loaded dynamically only when the user navigates to them.

  ==> path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) 
  Lazy Loading with Child Components
  { path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) },
  { path: '', redirectTo: 'products', pathMatch: 'full' } 
</div>

CHANGE DETECTION 
<div>
  Change Detection in Angular is the process of updating the DOM when the application state changes. Angular automatically detects changes and updates the UI accordingly.
  1. Default Change Detection, 2. OnPush Change Detection

  Default Change Detection Examples :- 

  <h2>Count: {{ count }}</h2> 
  <button (click)="increment()">Increment</button>

  <!-- count = 0;
  increment() {
    this.count++;
  } -->

  OnPush Change Detection Examples :- 

  import ChangeDetectionStrategy, Input 
  <h2>{{ data }}</h2> 
  @component({ changeDetection: ChangeDetectionStrategy.OnPush})
  @Input() data: string;

  --------------------------------
  
  <app-onpush [data]="message"></app-onpush>
  <button (click)="updateMessage()">Update Message</button>
  Ts 
  message = 'Hello';
  updateMessage() {
    this.message = 'Hello, Angular!';
  }
</div>

Micro Frontend
<div>
Micro Frontend (MFE) is an architectural approach where a frontend application is divided into smaller, independently deployable micro applications.
Why Use Micro Frontend in Angular?
Scalability: Large applications can be split into smaller manageable parts.
Independent Deployment: Each micro frontend can be developed, tested, and deployed independently.
Technology Agnostic: Different teams can use different frameworks (Angular, React, Vue) if needed.
Better Maintainability: Smaller codebases are easier to maintain.
Steps to Implement Micro Frontend in Angular
-------------------------------------------
Let's assume we have:
Shell App (Host Application) → Main container that loads micro frontends.
Remote App 1 (Micro App 1)
Remote App 2 (Micro App 2)
</div>

SSR 
<div>
SSR - server-side rendering (SSR) is a process that involves rendering pages on the server, resulting in initial HTML content which contains initial page state. 
</div>

How to use multiple API in angular ? + AOT JIT
<div>
    Angular, We can use multiple APIs in different ways.
    Using forkJoin (Parallel API Calls - Best for Independent APIs)
    <script>
        forkJoin([
          this.http.get('https://api.example.com/users'),
          this.http.get('https://api.example.com/posts')
        ]).subscribe(([users, posts]) => {
          console.log('Users:', users);
          console.log('Posts:', posts);
        });
    </script>
AOT - Ahead of time compilation at build time application runs. 
JIT - Just in time

** Different AOT AND JIT --
<script>
JIT (Just-in-Time) Compilation:

Happens at runtime in the browser.
Compiles the Angular application in the browser as it loads.
Faster development builds but slower performance in production.

AOT (Ahead-of-Time) Compilation:

Happens during the build phase before the application is run.
Compiles the application into efficient JavaScript code ahead of time, which leads to faster loading and better performance.
Recommended for production builds.
</script>
</div>

@VIEW Child
<div> 
@ViewChild is a decorator in Angular that allows us to access and interact with child components, directives,

<h2 #heading>Welcome to Angular!</h2>
<button (click)="changeText()">Change Text</button>

@ViewChild('heading') headingElement!: ElementRef;

ngAfterViewInit() {
  console.log('Text content:', this.headingElement.nativeElement.textContent);
}

changeText() {
  this.headingElement.nativeElement.textContent = 'Text Changed!';
  this.headingElement.nativeElement.style.color = 'red';
}

----------------- 
@ViewChildren (Multiple Element or Component References)
=> child.component.ts 
   <p>Child Component</p>
   greet() {
    return 'Hello from Child Component!';
  }

=> parent.component.ts
<app-child></app-child>
<app-child></app-child>
<app-child></app-child>
<button (click)="callChildrenMethods()">Call All Child Methods</button>
ts
@ViewChildren(ChildComponent) children!: QueryList<ChildComponent>;
  ngAfterViewInit() {
    this.children.forEach((child, index) => {
      console.log(`Child ${index + 1}: ` + child.greet());
    });
  }
  callChildrenMethods() {
    this.children.forEach((child) => alert(child.greet()));
  }
</div>
--------------------------------
DATA BINDING
--------------------------------
<div>
Data Binding in Angular is a technique that synchronizes data between the component ang the view (HTML).
Interpolation({{ title }}), Property Binding, Event Binding ((click)="showAlert()">Click</button> ), 

Two-way Binding Example
userInput: string = '';  // Model property
<input type="text" [(ngModel)]="userInput" placeholder="Type something..." />
<p>You typed: {{ userInput }}</p>
</div>

DECORATOR 
<div> 
    Decorator is a function that add metadata to a class. @component, @directives, @ngModule 
</div>

DECORATIVE -----
<div>
Diretives is class that modifies the behaviour appearance of the elements
@ViewChild -  Access a Child Component in the Parent Component
@viewChildren - It is used to get multiple child components, directives.

view child examples 
<div> 
<app-child></app-child>
 <button (click)="callChildMethod()">Call Child Method</button>
<p>{{ message }}</p>

TS file 

@ViewChild(ChildComponent) child!: ChildComponent;
message = '';
ngAfterViewInit() {
  this.message = this.child.sayHello();
}
callChildMethod() {
  this.message = this.child.sayHello();
}
</div>
-------------

@Input, @output
<div>
@Input and @Output are used for communication between parent and child components

exampe child ts -  @Input() message!: string; 
template: `<h3>Message from Parent: {{ message }}</h3>`,  

parent ts - 
parentMessage = 'Hello, Child!';
-------------------------------------------

@output examples - child ts -
 @Output() messageEvent = new EventEmitter<string>();

sendMessage() {
      this.messageEvent.emit('Hello, Parent!'); // Sending data to parent
}

Parent ts - 

template : `
    <app-child (messageEvent)="receiveMessage($event)"></app-child>
    <p>Received Message: {{ receivedMessage }}</p>
    ---------------
    receivedMessage = '';
    receiveMessage(message: string) {
      this.receivedMessage = message; // Updating receivedMessage from child
    }   
</div>

Ngfor, forloop
<div>
    ngfor 

    employees = [
    {
    id: 1,
    name: "Santosh Kumar",
    age: 30,
    department: "Human Resources",
    salary: 5000000
    },
    <tr *ngFor="let employee of employees"> </tr>
    ----------------------
    isVisiable:boolean = false 
    <h2 *ngIf="isVisiable"> Welcome to NgIf</h2>
</div>

CUSTOM DIRECTIVE 
<div>
    custom Directive Command - ng g d directive-name (cdirective)
    @Input() color!:string;

    constructor(private el: ElementRef) {} //Refrence DOM elements, //void is a type that represents the absence of a value

    ngOnInit(): void { 
    // this.el.nativeElement.style.backgroundColor = 'red';
        this.el.nativeElement.style.backgroundColor = this.color;
    }
    <p cdirective color="red"> Form </p>
-------------------------

<div> @Input() defaultColor: string = 'yellow'; // Default color
  @Input() highlightColor: string = 'red'; // Color on click
  private isHighlighted = false;
  
  onclick button 
   ngOnInit(): void {
      this.el.nativeElement.style.backgroundColor = this.defaultColor;
    }
  
  @HostListener('click') onClick() {
    this.isHighlighted = !this.isHighlighted; 
    this.el.nativeElement.style.backgroundColor = this.isHighlighted ? this.highlightColor : this.defaultColor;
    } 
  <button cdirective toggleColor defaultColor="yellow" highlightColor="red" class="px-4 py-2 rounded-md border"> Click Me </button>
  ---------------- 
  @Directive({
    selector: '[websanto]', // Custom attribute selector
  })

  @Input() color: string = ''; // Input property for color

  constructor(private el: ElementRef) {}

  ngOnInit() {
    this.el.nativeElement.style.backgroundColor = this.color; // Apply color
  }
in HTML 
<button websanto color="red">Submit</button>
</div>
</div>

SCROLLTOP
<div>
  private showClass = 'show-scroll-button';
  constructor(private el: ElementRef, private renderer: Renderer2) {}
  ngOnInit() {
    this.renderer.addClass(this.el.nativeElement, 'scroll-to-top');
  }
  @HostListener('window:scroll', [])
  onWindowScroll(){
    if(window.scrollY > 200){
      this.renderer.addClass(this.el.nativeElement, this.showClass);
    } else {
      this.renderer.removeClass(this.el.nativeElement, this.showClass);
    }
  }
  @HostListener('click') onclick(){
    window.scrollTo({ top:0, behavior: 'smooth'});
  }
</div>

ADD AND REMOVE CLASS 
<DIV>
  @HostListener('click') onClick() {
    this.isHighlighted = !this.isHighlighted;

    if (this.isHighlighted) {
      // Add class to clicked element
      this.renderer.addClass(this.el.nativeElement, 'active');

      // Remove class from other elements
      this.removeClassFromOtherElements();
    } else {
      // Remove class from this element
      this.renderer.removeClass(this.el.nativeElement, 'active');
    }
  }
</DIV>
---------
structural directive and attribute directive 
isVisiable = true
<div *ngIf="isVisiable"> Welcome </div>
<button (click)="isVisiable = !isVisiable"> click </button>
--------------
<p [ngClass]="{'active': isActive, 'inactive': !isActive}">Styled Text</p>
<button [ngStyle]="{'background-color': isActive ? 'green' : 'red'}">Click Me</button>
</div>

PIPE, CUSTOM PIPE, PURE, IMPURE
<div>
  <!-- What is the difference between a Pipe and a Directive?
  Pipes transform data in templates (date, uppercase).
  Directives modify the behavior of DOM elements (ngIf, ngFor). -->

Pipes are a special operator in Angular template expressions that allows you to transform data declaratively in your template.
Uppercase: {{ 'hello world' | uppercase }}

today: Date = new Date();
<p>Full Date: {{ today | date:'fullDate' }}</p>
pure - Only when input data changes	, Faster , Static data transformations	
impure - On every change detection cycle, Slower 

 custom Pipe, PipeTransform
 <!-- transform(value: string, gender: string): string {
    if(gender.toLowerCase()=="male")
      return "Mr. "+value;
      else
      return "Miss. "+value
    }    -->
    {{employee.name | mypipe:employee.gender }}

----- impure 

An impure pipe in Angular executes on every change detection cycle, even if the input data hasn’t changed.
pure: false
transform(value: string, gender: string): string {
    <!-- if (!value || !gender) return value; -->
    if(gender.toLowerCase()=="male")
      return "Mr. "+value;
      else
      return "Miss. "+value
    }

FILTER IMPURE PIPE EXAMPLES 
<!-- pure: false
transform(items: any[], searchText: string): any[] {
  if (!items || !searchText) {
    return items;
  }
  return items.filter(item =>
    item.toLowerCase().includes(searchText.toLowerCase())
  ); -->
  use in component 
  <!-- searchText: string = '';
  items: string[] = ['Angular', 'React', 'Vue', 'Svelte']; -->
  use in template 
  <!-- <input type="text" [(ngModel)]="searchText" placeholder="Search..." />
  <ul>
    <li *ngFor="let item of items | filterItems:searchText">
      {{ item }}
    </li>
  </ul> -->
</div>


<div>
  
Using a Global Variable for data transfer
<div> 
  ts - let sharedData: any;
  Sender - sendData() {
    sharedData = "Data from Sender";
  }
  Receive - receivedData = sharedData;
</div>

Spying on a Method in Angular (Jasmine & SpyOn)
<div>
  jASMINE - 
  Jasmine is a behavior-driven development (BDD) framework for testing JavaScript applications.
  It does not depend on any external libraries and is commonly used for unit testing in Angular.

  In Angular unit testing, spying on methods is a common practice to track method calls, prevent actual execution, and return mock values. This is done using Jasmine’s spyOn function.

  export class MyComponent {
    myMethod() {
      console.log('Original method executed');
    }
  
    anotherMethod() {
      this.myMethod(); // Calls myMethod internally
    }
  }  

 -- Spy on an Observable	
 spyOn(service, 'methodName').and.returnValue(of(fakeData))

 --Spy on a service method
 spyOn(service, 'methodName')
</div>

TYPESCRIPT 
<div>
  TypeScript is a superset of JavaScript that adds static typing, interfaces, and advanced features to JavaScript. 
  Differences between TypeScript and JavaScript

  TypeScript - 
  Statically typed (optional), Needs to be compiled to JavaScript	, Supports interfaces, generics, and modifiers	
  JavaScript -----
  Dynamically typed
  No compilation needed
  Limited support

  Interface in TypeScript defines a contract for an object’s structure.
  interface User {
    name: string;
    age: number;
    email?: string; // Optional property
  }
  const user: User = { name: "John", age: 25 };
</div>

CHART IMPLEMENTS 
<div>
  Bar chart and Pie chart Installation
  ng2-charts - v4 support with angular 15
  npm install according to doc
  Global configuration
  providers
  ngcharconfiguration in module
  code copy markup and ts code
  using dependancy --legacy-peer-deps
</div>

Standalone Components in Angular
<div>
Angular introduced Standalone Components in Angular 14 to eliminate the need for NgModule.
Before Angular 14: Every component needed to be declared in an NgModule.
Now (Angular 14+): Components can work independently without NgModul
</div>

Route Guards in Angular
<div>
  Angular Guards are services that control access to routes in an Angular application. They are used to protect routes from unauthorized access or to prevent unwanted navigation. Common types of guards include:

  CanActivate: Determines if a route can be activated.
  CanDeactivate: Checks if a route can be deactivated.
  CanLoad: Determines if a module can be loaded lazily.
  <script>
constructor(private router: Router) {}
canActivate(): boolean {
  const isLoggedIn = !!localStorage.getItem('user');
  if (!isLoggedIn) {
    this.router.navigate(['/login']); // Redirect to login if not authenticated
    return false;
  }
  return true;
}
  </script>
  Applying Route Guard to Routes
  <!-- const routes: Routes = [
  { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] }
]; -->
</div>

Dependency Injection (DI) in Angular
<div>
  DI is a design pattern in Angular used for managing dependencies (services, components, etc.).
  * Instead of creating objects manually, Angular injects them automatically.
  * Uses @Injectable() decorator for services.
  => Create Serives 
  getData() {
    return ['Angular', 'React', 'Vue'];
  }
  => Inject the Service into a Component
  frameworks: string[];
  constructor(private dataService: DataService) {  // 🔹 Inject Service Here
    this.frameworks = this.dataService.getData();
  }
  <h1>{{ frameworks }}</h1>
</div>

FORMS
<div>
  What is the difference between Template-driven and Reactive Forms?
  Template-driven
  Structure Based on directives
  Validation Asynchronous
  Simple forms
  Two-way data binding
  ----------------------
  Reactive Forms
  Structure Based on explicit creation
  Synchronous
  Complex forms
  Immutable data model  

  <div>
    lead_form!: FormGroup
    lead_fields = {
    name     : ['', Validators.required],
    email    : ['', Validators.required],
    }
    constructor( private _fb    : FormBuilder ){
  this._route.queryParams.subscribe(params => { this.tenant_id = params['id']})
  }
  ngOnInit(){this.initializeForm()}
  initializeForm(){
  this.lead_form = this._fb.group(this.lead_fields)
  this.getLeads()
  }
  saveForm() {
    if (this.myForm.invalid) {
      alert('Please fill in all required fields!');
      return;
    }
  </div>

  HTML 
  <form [formGroup]="lead_form" (ngSubmit)="saveForm()">
  <input type="text" class="form-control" placeholder="Name" formControlName="name">
  <span class="error-message" *ngIf="lead_form.get('name')?.touched && lead_form.get('name')?.hasError('required')">
  Name is required. </span>
  </form>

</div>

LOCALSTORAGE AND SESSIONSTORAGE 
<div>
Local Storage - 
- Data remains even after closing/reopening the browser	
- Available across all tabs/windows of the same origin	
- Storage limit Around 5MB per origin	
- Store user preferences, theme settings, authentication tokens, etc.	
SessionStorage  
- Data is cleared when the browser/tab is closed
- Available only within the same tab
- Store temporary data like form input, session-based UI state, etc.
<script>
// Store data
localStorage.setItem('username', 'Santosh');
// Retrieve data
const username = localStorage.getItem('username');
console.log(username); // Output: Santosh
// Remove data
localStorage.removeItem('username');
// Clear all data
localStorage.clear();
</script>
USING SESSION STORAGE
<script> 
  sessionStorage.setItem('sessionUser', 'JohnDoe');
</script>
Using the Service in a Component
<script>
  saveData() {
    this.storageService.setLocalStorage('user', { name: 'Santosh', role: 'Admin' });
    this.storageService.setSessionStorage('sessionUser', { name: 'Guest' });
  }
  loadData() {
    const user = this.storageService.getLocalStorage('user');
    const sessionUser = this.storageService.getSessionStorage('sessionUser');
    console.log('Local User:', user);
    console.log('Session User:', sessionUser);
  }
  clearData() {
    this.storageService.clearLocalStorage();
    this.storageService.clearSessionStorage();
  }
</script>
<button (click)="saveData()">Save Data</button>
</div>

Authentication in Angular
<div>
  Authentication can be implemented using JWT tokens, Angular guards, and interceptors to manage login and secure routes.
  <script>
    import { Injectable } from '@angular/core';
@Injectable({
    providedIn: 'root'
})
export class AuthService {
    constructor() { }
    isLoggedIn(): boolean {
        return !!localStorage.getItem('userToken');
    }
}
  </script>
</div>

FILTER
<div>
ng generate pipe filter
name: 'filter'
<!-- transform(items: any[], searchText: string): any[] {
  if (!items || !searchText) return items;
  searchText = searchText.toLowerCase();
  return items.filter(item => item.toLowerCase().includes(searchText));
} -->
<input type="text" [(ngModel)]="searchText" placeholder="Search items..." />
<div *ngFor="let item of items | filter:searchText | paginate: { itemsPerPage: 10, currentPage: currentPage }">
  {{ item }}
</div>
<pagination-controls (pageChange)="currentPage = $event"></pagination-controls>

</div>

PAGINATION 
<div>
export class AppComponent implements OnInit {

  <!-- items: string[] = [];  // Store 100 items
  pagedItems: string[] = []; // Store items for current page
  pageSize = 10; // Number of items per page
  currentPage = 1; // Current active page
  totalPages = 0; // Total number of pages -->

  ngOnInit() {
    this.createItemsList();
  }

  createItemsList(){
    for(let i=1; i<=100; i++){
      this.items.push("Item" +' '+ i)
    }
    <!-- console.log('Check', this.items); -->
    this.totalPages = Math.ceil(this.items.length / this.pageSize);
    this.updatePage();
  }

  // Function to update items for the current page
  updatePage() {
    <!-- const startIndex = (this.currentPage - 1) * this.pageSize;
    const endIndex = startIndex + this.pageSize;
    this.pagedItems = this.items.slice(startIndex, endIndex); -->
  }

  // Function to change page
  goToPage(page: number) {
    <!-- if (page >= 1 && page <= this.totalPages) {
      this.currentPage = page;
      this.updatePage();
    } -->
  }
}
-------------------------- 
<div *ngFor="let item of pagedItems">
  {{ item }}
</div>
<!-- Pagination Controls -->
<div class="pagination">
  <button (click)="goToPage(currentPage - 1)" [disabled]="currentPage === 1">Previous</button>
  <button *ngFor="let page of [].constructor(totalPages); let i = index"
          (click)="goToPage(i + 1)"
          [class.active]="currentPage === i + 1">
    {{ i + 1 }}
  </button>
  <button (click)="goToPage(currentPage + 1)" [disabled]="currentPage === totalPages">Next</button>
</div>

</div>

12. Store is a centralized state management solution that holds the application’s state  
and provides mechanisms to update and access the state efficiently.

--------------------------------
10. In Angular 17, authentication involves:

Login Page – User enters credentials.
Auth Service – Handles authentication & token storage. ( dedicated service within your application that handles all user authentication logic, including login, logout )

Dashboard Component – Accessible only after login.
Auth Guard – Protects routes from unauthorized access. ( Auth Guard is a mechanism that controls access to routes based on user authentication. )

Lazy loading ondemand load 
---------------------------------------

1. Git pull automatically merges the fetched changes into the current branch, git fetch does no 
2. Git Fetch a primary command used to download contents from a remote repository.
3. Git stash git stash command takes your uncommitted changes and saves later use. 


Learend
Always check if ReactiveFormsModule is imported in the module.

-----------------------------------

<div> 

<form [formGroup]="lead_form" (ngSubmit)="saveLead()">
  <input type="text" class="form-control" placeholder="Name" formControlName="name">
  <div class="error-message" *ngIf="lead_form.get('name')?.touched && lead_form.get('name')?.hasError('required')">
  Name is required. </div>
  </form>

  const routes: Routes = [
  { path: '', component: HomeComponent },
  ];

  // services 
  previousButton(){
    if(sessionStorage.getItem('role') == "client"){
      return false
    }
    return true
  }


------------- CUSTOM PIPE --------------------

ng generate pipe reverseText
@Pipe({
  name: 'reverseText'
})
export class ReverseTextPipe implements PipeTransform {
  transform(value: string): string {
    return value.split('').reverse().join('');
  }
}
without custom pipe
today: Date = new Date();
<p>Full Date: {{ today | date:'fullDate' }}</p>
------------------------------------------------- 

HTML AND CSS 
<div>

Semantic elements in HTML clearly describe their meaning to both the browser and developers.
GRID AND FLEX BOX - 
<!-- GRID - 2D (Rows & Columns), Aligns items in both rows and columns, Uses grid-gap, row-gap, column-gap
FLEX BOX - 1D (Row or Column), Aligns items in a single row or column, Uses gap but only for row/column spacing -->
Pseudo-Elements (::, ::before, ::after) , Pseudo-Classes (:, :hover, :focus, :nth-child())

  ////////////////// CSS =================
  <!-- Use relative when you want to adjust an element without removing it from the document flow.
  Use absolute when you want to detach an element and position it within a specific container. -->

  Relative - The element moves relative to its normal position.
  Absolute - The element is positioned relative to the nearest positioned ancestor 
  Fixed - The element is positioned relative to the viewport (browser window).

  CSS Box Model defines how an element’s size and spacing are calculated.
------------------------ 
  Less, Sass, and SCSS are all CSS preprocessors that extend CSS by adding features like variables, nesting, mixins, and functions. 
  
  // scss variable
  <code>
  $primary-color: blue;
  .button {
    color: $primary-color;
    padding: 10px;
  }
  </code>
  
  --------------------
  // nesting in scss  
  .navbar {
      background: #333;
      padding: 10px;
    
      .menu {
        list-style: none;
        padding: 0;
    
        li {
          display: inline-block;
          margin-right: 10px;
    
          a {
            text-decoration: none;
            color: white;
    
            &:hover {
              color: yellow;
            }
          }
        }
      }
    }
  
    //Mixins in SCSS
  
    @mixin button-style {
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 16px;
    }
    
    .btn {
      @include button-style;
      background: blue;
      color: white;
    }
    
    .btn-danger {
      @include button-style;
      background: red;
    }
    
  //sass
  $primary-color: blue
  .button
    color: $primary-color
    padding: 10px
  
    //loop 
    @each $size, $padding in (small: 5px 10px, medium: 10px 20px, large: 15px 30px) {
      .button--#{$size} {
        padding: $padding;
      }
    }

    ----------------- 
    
    Variables ($primary-color, $secondary-color)
    ✅ Mixins (@mixin button-style($bg-color))
    ✅ Nesting (&:hover)
    ✅ Loops (@each for button sizes)

</div>

LOGIN PAGE STEP 
<div>
ng generate component pages/login
ng generate component pages/dashboard
ng generate service services/auth
Auth Guard: Prevents unauthorized users from accessing Dashboard
-----------------
Create Authentication Service ( auth.service.ts)
<script>
  constructor(private router: Router) {}

login(username: string, password: string): boolean {
  if (username === 'admin' && password === 'password') {
    localStorage.setItem('isLoggedIn', 'true');
    this.router.navigate(['/dashboard']);
    return true;
  }
  return false;
}

logout() {
  localStorage.removeItem('isLoggedIn');
  this.router.navigate(['/login']);
}

isAuthenticated(): boolean {
  return localStorage.getItem('isLoggedIn') === 'true';
}
</script>
login.component.ts
<script>
  username: string = '';
  password: string = '';
  errorMessage: string = '';

  constructor(private authService: AuthService) {}

  login() {
    if (!this.authService.login(this.username, this.password)) {
      this.errorMessage = 'Invalid credentials!';
    }
  }
</script>
login.component.html
<div class="login-container">
  <h2>Login</h2>
  <input type="text" placeholder="Username" [(ngModel)]="username" />
  <input type="password" placeholder="Password" [(ngModel)]="password" />
  <button (click)="login()">Login</button>
  <p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>
</div>
dashboard.component.ts:
<script>
  constructor(private authService: AuthService) {}
  logout() {
    this.authService.logout();
  }
</script>
dashboard.html 
<script>
  <div class="dashboard-container">
  <h2>Welcome to Dashboard</h2>
  <button (click)="logout()">Logout</button>
</div>
</script>
</div>

</div>
</div>

</div>

<button id="toTopBtn" title="Go to top">↑</button>
<script src="script.js"></script>
  </body>
</html>
