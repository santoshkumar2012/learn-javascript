<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <title> Angular </title>
  <style>
    body {
      font-size: 1.2rem;
      color: #000;
    }

    a {
      color: #000;
      font-weight: 600;
    }

    pre code {
      font-size: 1.2rem !important;
    }

    #toTopBtn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 99;
      border: none;
      outline: none;
      background-color: #333;
      color: white;
      cursor: pointer;
      padding: 0;
      border-radius: 50%;
      font-size: 18px;
      display: none;
      /* Hidden by default */
      transition: background-color 0.3s;
      width: 30px;
      height: 30px;
    }

    #toTopBtn:hover {
      background-color: #555;
    }

    h2 {
      font-size: 18px;
      font-weight: 700;
    }

    pre {
      display: block;
      margin-top: 0;
      margin-bottom: 0;
      overflow: auto;
      font-size: .875em;
      background: #eeeeee;
    }

    pre,
    code {
      word-wrap: break-word !important;
      /* Break long words */
      overflow-wrap: break-word !important;
    }

    .index {
      padding: 0;
      margin: 0;
    }

    .index li {
      list-style: none;
      display: inline-block;
      border: #ccc solid 1px;
      padding: 0px 5px;
      margin: 3px 0;
    }

    .index li a {
      text-decoration: none;
      color: #000;
      font-weight: 600;
      text-transform: capitalize;
    }

    .borderline {
      display: block;
      width: 100%;
      border: none !important;
    }

    .borderline li {
      border: none;
    }
  </style>
</head>
<body>
  <div class="container-fluid">

    <ul class="index">
      <li> <a href="#angularrun"> angular Run </a> </li>
      <li> <a href="#why"> why angular </a> </li>
      <li> <a href="#angularjs"> Angular and Angular JS </a> </li>
      <li> <a href="#jstype"> JavaScript vs TypeScript </a> </li>
      <li> <a href="#architecture"> architecture </a> </li>
      <li> <a href="#language"> i18n </a></li>
      <li> <a href="#modules"> Modules, bootstrap </a> </li>
      <li> <a href="#routing"> Routing  </a></li>
      <li> <a href="#shared"> shared, Challenging </a> </li>
      <li> <a href="#angularspa"> SPA </a> </li>
      <li> <a href="#mvc"> MVC </a> </li>
      <li> <a href="#root"> root </a> </li>
      <li> <a href="#jse"> AngularJS Expression - JS Expressions </a> </li>
      <li> <a href="#component"> components </a> </li>
      <li> <a href="#reusable"> Component Reusable </a> </li>
      <li> <a href="#template"> template / router-outlet </a> </li>
      <li> <a href="#metadata"> metadata </a> </li>
      <li> <a href="#angularcli"> angular CLI </a> </li>
      <li> <a href="#angularcontroller"> controllers </a> </li>
      <li> <a href="#ssr"> SSR </a> </li>
      <li> <a href="#optimize"> <strong> Optimization / Bundle Size </strong> </a> </li>
      <li> <a href="#lazy"> <strong> lazy loading </strong> </a> </li>
      <li> <a href="#change"> Change Detection, Zone.js </a> </li>
      <li> <a href="#accessibility"> accessibility </a> </li>
      <li> <a href="#newfeatures" style="background:green; color:#fff;"> New featurs </a> </li>
      <li> <a href="#routeguards"> routeguards, Dynamic Menu </a> </li>
      <li> <a href="#spa"> SPA </a> </li>
      <li> <a href="#state"> state management </a> </li>
      <li> <a href="#scope"> Scope </a> </li>
      <li> <a href="#angular-react"> Angular and React </a> </li>
      <li> <a href="#server"> Upload Angular Project </a> </li>
      <li> <a href="#storage"> Local Storage </a> </li>
      <li> <a href="#packages"> packages.json, angular.json </a> </li>
      <li> <a href="#async"> Async, Async pipe, promise </a> </li>
      <li> <a href="#authentication"> <strong> Authentication, Authorization </strong> </a> </li>
      <li> <a href="#jwt"> <strong> JWT </strong> </a> </li>
      <li> <a href="#encapsulation"> View Encapsulation </a> </li>
      <li> <a href="#async-defer"> async and defer </a> </li>
      <li> <a href="#debugg"> Debugging </a></li>
      <li class="borderline"><a href="#"> </a></li>
      <li> <a href="#databinding"> Data Binding </a> </li>
      <li> <a href="#datatransfer"> Data Transfer wrelation </a> </li>
      <li> <a href="#decorator"> decorator </a> </li>
      <li> <a href="#directive"> directive </a> </li>
      <li> <a href="#input"> @input() </a> </li>
      <li> <a href="#datatransferinput"> Data Transfer </a></li>
      <li> <a href="#ngfor"> *ngFor, *ngIf, else, Toggle, @HostListener, ng-template </a> </li>
      <li> <a href="#pipe"> pipe, pure, impure </a> </li>
      <li> <a href="#viewchild"> viewchild </a> </li>
      <li> <a href="#global-variable"> global-variable </a> </li>
      <li class="borderline"><a href="#"> </a></li>
      <li> <a href="#form"> Form, reactiveform </a> </li>
      <li> <a href="#datapush"> Simple data push </a> </li>
      <li> <a href="#crud"> crud </a> </li>
      <li> <a href="#form-crud"> form validation, crud </a> </li>
      <li> <a href="#empw-api"> Employee crud without api </a> </li>
      <li> <a href="#emp-api"> Employee crud with api </a> </li>
      <li> <a href="#emp-dynamic"> Emp crud API Dynamic Form </a> </li>
      <li> <a href="#emp-withoutdynamic"> Emp crud WITHOUT API Dynamic Form </a> </li>
      <li> <a href="#crudstaticdata"> Crud Static Data </a></li>
      <li> <a href="#apiservices"> <strong> API </strong> Rest API / Web API </a> </li>
      <li class="borderline"><a href="#"> </a></li>
      <li> <a href="#rxjs"> Rxjs </a> </li>
      <li> <a href="#rxjsoperator"> Rxjs Operators (Map, Switch map, Concate Map, Mergemap, DebounceTime, pluck, Filter)
        </a> </li>
      <li> <a href="#rxjsoperatorlive"> Rxjs Operators live example </a> </li>
      <li><a href="#error"> Error Handling </a></li>
      <li> <a href="#rxjssubject"> Rxjs subject </a> </li>
      <li> <a href="#ngrx"> <strong> Ngrx </strong>, Transition between two states </a> </li>
      <li> <a href="#life-cycle"> life-cycle </a> </li>
      <li> <a href="#services"> Services </a> </li>
      <li> <a href="#interceptor"> <strong> Interceptor </strong> </a> </li>
      <li> <a href="#di"> Dependancy injection </a> </li>
      <li> <a href="#class"> Class </a> </li>
      <li> <a href="#aot"> AOT </a> </li>
      <li> <a href="#signals"> <strong> signal </strong> </a> </li>
      <li> <a href="#graphql"> graphql </a> </li>
      <li> <a href="#vresion-upgrade"> how to upgrade </a> </li>
      <li> <a href="#pitfalls"> Best Practices vs. Common Pitfalls </a></li>
      <li> <a href="#aggrid"> ag-Grid vs. ngx-datatable (Angular Table Libraries) </a></li>
      <li class="borderline"><a href="#"> </a></li>
      <li><a href="#changetheme"> Change dark and light theme </a></li>
      <li> <a href="#cross"> Cross-browser compatibility, mobile-responsive </a></li>
      <li> <a href="#microfronted"> <strong> Microfronted </strong> </a> </li>
      <li> <a href="#webpack"> <strong> Webpack </strong> </a></li>
      <li> <a href="#material"> <strong> Angular Material </strong> </a> </li>
      <li> <a href="#prime"> PrimeNg </a> </li>
      <li> <a href="#customuiliberary"> Custom UI Component Library </a></li>
      <li> <a href="#counter"> Counter </a> </li>
      <li> <a href="#dynamicInput"> Dynamic Input Field </a> </li>
      <li> <a href="#chart"> chart </a> </li>
      <li> <a href="#filter"> Filter </a> </li>
      <li> <a href="#pagination"> pagination </a> </li>
      <li> <a href="#login-setup"> login-setup </a> </li>
      <li> <a href="#register-setup"> Register-setup </a> </li>
      <li> <a href="#json"> json </a> </li>
      <li> <a href="#dom"> DOM Manipulation </a></li>
      <li> <a href="#scrolltop"> scrolltop </a> </li>
      <li> <a href="#add-remove"> add remove </a> </li>
      <li> <a href="#accordion"> Accordion and Tabs </a></li>
      <li class="borderline"><a href="#"> </a></li>

      <li> <a href="#test"> Angular Test casing Jasmine/karma </a> </li>
      <li> <a href="#spying"> spying </a> </li>
      <li> <a href="#git"> GIT AND GITHUB </a> </li>
      <li> <a href="#google"> Google Cloud </a></li>
      <li> <a href="#azile"> Azile Methodology </a></li>
      <li> <a href="#web"> Web Optimization? </a></li>
      <li> <a href="#asetup"> Angular Setup </a></li>
      <li> <a href="#net"> .NET Core / ASP.NET </a></li>
      <li> <a href="#npm"> <strong> NPM </strong> </a></li>
      <li> <a href="#cicd"> Tools - CI/CD environments </a> </li>
      <li> <a href="#azure"> Azure DevOps </a> </li>
      <li> <a href="#jenkins"> <strong> Jenkins </strong> </a></li>
      <li> <a href="#testtools"> Testing Tools </a></li>
      <li> <a href="#sitecore"> sitecore MVC </a></li>
      <li> <a href="#sitecorejss"> Sitecore JSS </a></li>
      <li> <a href="#angreact"> Manage Angular + React in the same project </a></li>
      <li> <a href="#coreweb"> Core Web Vitals ( improve SEO ) </a></li>
      <li> <a href="#deployment"> Fronted -> Backend, Deployment, CORS </a>
      </li>
    </ul>

    <h2 class="mt-4">INTRO</h2>
    <div class="box shadow p-2 mb-3">
      "In my previous role at Quickparts, a manufacturing-based company, I worked primarily as an Angular Frontend
      Developer. My main responsibility was building the Product Management Dashboard, where I developed complex UI
      modules like product listing, filtering, status updates, and detailed views using Angular."
      <br>
      <br>
      "I created <a href="#reusable"> reusable components </a>, managed routing and <a href="#lazy"> lazy loading </a>,
      handled <a href="#state">
        state management </a> <a href="#rxjs"> using RxJS </a>, and <a href="#apiservices"> integrated REST APIs </a> to
      fetch and display dynamic data. I also implemented <a href="#directive"> custom directives </a> and pipes to
      enhance functionality and maintain clean, modular code."
      <br>
      <br>
      <!-- "While I collaborated with the design team and used Figma/Photoshop to implement pixel-perfect UI, my main contribution was in Angular development — building real features, solving bugs, and <a href="#optimize"> optimizing performance </a>." -->
      "While I used the Figma design to implement pixel-perfect UI, my main contribution was in Angular development —
      building real features, solving bugs, and <a href="#optimize"> optimizing performance </a>."
      <br>
      <br>
      <hr>
      Yes, I worked with Figma and have hands-on experience working with Figma designs. I’ve converted Figma mockups
      into responsive HTML and integrated them into Angular projects.
      <br>
      I know how to extract design details such as colors, image dimensions, gradients, border radius, and spacing to
      ensure a pixel-perfect implementation.
      <br>
      Additionally, I’ve also created designs in Figma based on client requirements, especially for dashboard
      interfaces. So I'm comfortable both interpreting Figma designs and designing directly within Figma as needed.

      <hr>
      In this role, I created design accroding to client in Figma and using also photoshop and converted them into
      pixel-perfect UI using HTML, CSS3, JavaScript, and Bootstrap, ensuring full responsiveness. After completing the
      UI, I integrated it into Angular, setting up components, routing, and ensuring smooth functionality. <br>
      I am passionate about creating clean, responsive, and user-friendly interfaces and always strive to enhance the
      UI/UX experience.
      <p> <em> I started my career at Redcube Digital Pvt. Ltd. as a Web Designer, where I worked for three years.
          Later, I was promoted to the development team, </em></p>
      <br>


      <hr>

      real dynamic data, API integration
      ------

      Module / Feature

      <ul>
        <li> <strong> Product List Page </strong> *ngFor, custom filter pipe, API integration </li>
        <li> <strong> Product Detail Page </strong> Routing with params, ngIf, custom component </li>
        <li> <strong> Product Upload </strong> Reactive Forms, validations </li>
        <li> <strong> Product Status </strong> Toggle Click handlers, conditional class, API PATCH </li>
        <li> <strong> Dashboard </strong> Charts Angular services + chart libraries </li>
        <li> <strong> Lazy Loading </strong> Sections Angular routing, feature modules </li>
        <li> <strong> Auth/Login </strong>Reactive forms, AuthService, Route Guards </li>
      </ul>

      <h2> Product Dashboard Project </h2>

      <p> “In the Quickparts product dashboard, we worked with real-time product data fetched from REST APIs. The data
        included fields like product name, SKU, price, category, quantity, status (active/inactive), images, and
        timestamps. I used Angular services and the HttpClient module to call APIs, and displayed data using *ngFor in
        tables and cards.” </p>

      <p> “We also implemented features like searching, filtering by category or status, pagination, and sorting. For
        example, on the product list module, I received JSON data from the backend, and used RxJS operators like map and
        filter to manipulate it before rendering.” </p>

      <p> “In forms, I also handled data for creating or updating a product — like uploading product images, selecting
        categories from dropdowns, and validating inputs using Angular Reactive Forms.”</p>

      <p> <strong> Thank you for your time. Do you have any suggestions on how I could strengthen my profile for this
          kind of role? </strong> </p>

    </div>

<div class="box shadow p-2 mb-3" id="debugg">
<h2> Debugg </h2>
<p> In Angular, we can debug using console.log(), browser DevTools, Angular DevTools extension, VS Code breakpoints, lifecycle hook logging, and API monitoring via Network tab. </p>

<ol>
  <li>  <strong> Use console.log() (Quick Checks)  </strong>
    <ul>
      <li> Place console.log() statements in your code to see variable values and execution flow. </li>
      <li> Use console.table() for arrays/objects to see them clearly. </li>
    </ul>
  </li>
  <li> <strong> Browser Developer Tools (Chrome/Edge/Firefox)  </strong>
    <ul>
      <li> <strong> Elements tab  </strong>→ Inspect HTML, CSS, and check bindings. </li>
      <li> <strong> Console tab </strong> → View errors, warnings, and logs. </li>
      <li> <strong> Sources tab </strong> → Set breakpoints in .ts files (Angular generates source maps in development mode so you can debug TypeScript directly). </li>
      <li> <strong> Network tab </strong> → Check API requests, responses, headers, and status codes. </li>
    </ul>
  </li>
  <li> <strong> Angular DevTools Extension </strong>
  <ul>
    <li> Official Chrome/Edge extension from Angular team. </li>
    <li> View current state of component inputs, outputs, and signals. </li>
    <li> Profile change detection cycles. </li>
    <li> "Angular DevTools" in the Chrome Web Store. </li>
  </ul>
  </li>
</ol>

</div>

<div class="box shadow p-2 mb-3" id="angularjs">
<h2> Angular Command </h2>
ng new project-name <br>
ng serve <br>
ng g c component-name <br>
ng build <br>
ng test <br>
npm install -g @angular/cli@17 <br>
ng new my-app --version 17<br>


      <h2 class="mt-4"> ANGULAR and ANGULAR JS different between </h2>
      <p>
        AngularJS = v1.x <br>
        Angular = v2 and above (latest is v17 as of 2025)
      </p>
      <p>
        AngularJS = JavaScript <br>
        Angular = TypeScript (superset of JavaScript)
      </p>
      <p>
        AngularJS = MVC (Model-View-Controller) <br>
        Angular = Component-based architecture
      </p>
      <p>
        AngularJS = Not mobile-friendly <br>
        Angular = Built with mobile-first in mind
      </p>
      <p>
        AngularJS = Slower (due to two-way binding and digest cycle) <br>
        Angular = Faster (thanks to one-way data binding and Ivy compiler)
      </p>
      <p>
        AngularJS = Two-way binding (default) <br>
        Angular = One-way binding (by default, can do two-way)
      </p>
      <p>
        AngularJS = Done directly in controllers <br>
        Angular = Handled via directives and templates
      </p>
    </div>

    <div class="box shadow p-2 mb-3" id="jstype">
      <h2> JavaScript vs TypeScript </h2>
      <ul>
        <li> <strong> JavaScript </strong></li>
        <li> A scripting language used to create dynamic web content. </li>
        <li> Dynamically typed (types are checked at runtime). </li>
        <li> Interpreted directly by the browser. </li>
        <li> </li>
        <li> <strong> TypeScript </strong></li>
        <li> A superset of JavaScript that adds static typing. </li>
        <li> Statically typed (types are checked at compile time). </li>
        <li> Compiled to JavaScript before running in the browser. </li>
      </ul>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
// JavaScript
function add(a, b) {
  return a + b;
}
-------------
// TypeScript
function add(a: number, b: number): number {
  return a + b;
}
</code>
</pre>
    </div>

    <div class="box shadow p-2 mb-3" id="asetup">
      <h2> ANGULAR Setup </h2>
      npm install -g @angular/cli <br>
      ng new project-name> <br>
      cd my-first-angular-app <br>
      npm start<br>
      <br>

      After got error follows below step<br>
      Error: Could not find the '@angular-devkit/build-angular:dev-server' builder's node package.<br>
      <br>
      <br>
      rm -rf node_modules package-lock.json<br>
      npm cache clean --force<br>
      npm install<br>

      <br>
      ------------------
      <br>
      routing Setup<br>
      <br>
      import { Routes } from '@angular/router';<br>
      import { LoginComponent } from './login/login.component';<br>
      import { DashboardComponent } from './dashboard/dashboard.component';<br>
      <br>
      export const routes: Routes = [<br>
      {path: '', component: LoginComponent},<br>
      {path: 'dashboard', component: DashboardComponent}<br>
      ];
      <br>
      ---------------------------
      <br>
      app.component.html<br>
      router-outlet>/router-outlet><br>
    </div>


    <div id="net">
      <div class="box shadow p-2 mb-3" id="asetup">
        <h2> .NET Core / ASP.NET Core </h2>
        <p> .NET Core is a cross-platform, high-performance, open-source framework developed by Microsoft. <br>
          ASP.NET Core is the web framework used for building modern web applications, REST APIs, and microservices.
        </p>

        <h2> <strong> Key Concepts in .NET Core Server-Side Development </strong> </h2>
        <ul>
          <li> <strong> Middleware </strong> Software components used to configure the HTTP request/response pipeline.
          </li>
          <li> <strong> Dependency Injection (DI) </strong> Built-in service for managing class dependencies. </li>
          <li> <strong> Routing </strong> Directs incoming requests to route handlers (controller/action). </li>
          <li> <strong> Entity Framework Core </strong> ORM used to interact with relational databases. </li>
          <li> <strong> Controllers / APIs </strong> Handle HTTP requests in MVC or REST API style. </li>
          <li><strong> Model Binding </strong> Automatically maps HTTP request data to parameters. </li>
          <li> <strong> Configuration </strong> Uses appsettings.json, IConfiguration, and environment variables. </li>
        </ul>

      </div>
    </div>

    <div id="net">
      <div class="box shadow p-2 mb-3" id="asetup">
        <h2> Object-Oriented Design for Web / SPA Applications </h2>
        <p> Object-Oriented Design is a methodology for designing applications using objects and classes. It focuses on
          encapsulation, inheritance, polymorphism, and abstraction to model real-world entities. </p>

        <h2><strong> How do you apply OOP principles in frontend Angular projects? </strong></h2>
        <ul>
          <li> Use services to encapsulate business logic (like classes). </li>
          <li> Define interfaces and models for strong typing. </li>
          <li> Apply inheritance and composition to reuse logic across components. </li>
          <li> Use dependency injection for decoupling and testing. </li>
        </ul>

        <h2 class="mt-4"> <strong> What design patterns are commonly used in Angular apps? </strong></h2>
        <ul>
          <li> Singleton (Services) </li>
          <li> Observer (RxJS Observables) </li>
          <li> Facade (NgRx Facades) </li>
          <li> Factory (Dynamic component creation) </li>
          <li> Strategy (Conditional logic encapsulated in services)</li>
        </ul>

        <h2 class="mt-4"> What is SOLID in OOP and how do you use it in Angular? </h2>
        <ul>
          <li> S – Single Responsibility: One component/service per responsibility </li>
          <li> O – Open/Closed: Extend components via inheritance </li>
          <li> L – Liskov: Replace base types with subtypes without breaking code </li>
          <li> I – Interface Segregation: Split large interfaces into smaller ones </li>
          <li> D – Dependency Inversion: Use DI tokens and services </li>
        </ul>

        <h2 class="mt-4"> <strong> debug Angular applications? </strong> </h2>
        <ul>
          <li> Use Angular DevTools for component inspection </li>
          <li> Debug Observables using tap() and breakpoints </li>
          <li> Use console logs, debugger statements, and catchError in RxJS </li>
        </ul>

        <h2 class="mt-4"> <strong> What is your approach for full end-to-end development in Angular? </strong></h2>
        <ul>
          <li> Start with requirement analysis and object modeling </li>
          <li> Define interfaces/models </li>
          <li> Build modular components </li>
          <li> Integrate with APIs via services </li>
          <li> Add routing, guards, interceptors </li>
          <li> Perform unit testing and E2E testing </li>
          <li> Prepare for CI/CD deployment </li>
        </ul>

      </div>
    </div>


    <div class="box shadow p-2 mb-3" id="mvc">
      <h2> ANGULAR BASIC </h2>
      <p><strong> MVC and MVVM (Model-View-ViewModel) </strong></p>
      <p> ** MVC (Model-View-Controller) is a design pattern that separates an application into three main components:
      <ol>
        <li> <strong> Model: </strong> Represents data and business logic (e.g., database, API). </li>
        <li> <strong> View: </strong> The UI layer that displays data to the user. </li>
        <li> <strong> Controller: </strong> Manages user inputs and updates the Model or View. </li>
      </ol>
      </p>
      <p> ** <strong> HOW WORK MVC </strong>
        1. The Controller receives user input (e.g., a button click).
        2. The Controller updates the Model (business logic).
        3. The Model notifies the View, and the View updates accordingly.
      </p>
      <p>
        <strong> MVVM </strong>
      <p> <strong> MVVM (Model-View-ViewModel) </strong> is a software architectural pattern that is commonly used in
        Angular applications, providing a clean separation of concerns between different components of an application.
      </p>
      <p> <strong> Model - </strong>Represents the application’s data and logic, It is the part of the application that
        manages the state, and it can be composed of services, APIs, </p>
      <p> <strong>View :- </strong> Represents the UI (user interface) elements that the user interacts with, such as
        buttons, inputs, forms, etc. | View is typically defined using HTML and CSS, and it’s tied to the template of a
        component. </p>
      <p> <strong> ViewModel :- </strong> ViewModel holds the data and logic needed to present the Model’s data in a way
        that the View can easily display. It is represented by the component in Angular, which binds the data and
        defines the behavior that will be reflected in the view. two-way data binding (via ngModel) allows the
        ViewModel. </p>
      </p>
    </div>

    <div class="box shadow p-2 mb-3" id="why">
      <h2> What are some of the advantages of Angular over other frameworks? </h2>
      <ul>
        <li> <strong> Features that are provided out of the box - </strong> Angular provides a number of built-in
          features like routing, state management, rxjs library and http servicesstraight out of the box. This means
          that one does not need to look for the above-stated features separately. They are all provided with angular.
        </li>
        <li><strong> Declarative UI -</strong> Angular uses HTML to render the UI of an application. HTML is a
          declarative language and is much easier to use than JavaScript. </li>
        <li> <strong> Long-term Google support - </strong> Google announced Long-term support for Angular. This means
          that Google plans to stick with Angular and further scale up its ecosystem. </li>
      </ul>
    </div>

    <div class="box shadow p-2 mb-3" id="angular-react">
      <h2> Angular and React difference </h2>
      Angular
      <p> Full-fledged framework </p>
      <p> Uses TypeScript by default </p>
      <p> Architectural - MVC-style, services, DI, etc </p>
      <p> Built-in services & RxJS </p>
      React
      <p> Just a library for UI </p>
      <p> Uses JavaScript (TS optional) </p>
      <p> Easier to start – more flexible </p>
      <p> Flexible – you choose tools & structure
      </p>
    </div>

    <h2 id="component"> COMPONENTS </h2>
    <div class="box shadow p-2 mb-3">
      <p> Angular Component is the building block of every Angular application. <br> Every angular application is made up of
        one more Angular Component. </p>

<h2> Types of component </h2>
<p> Angular has a single component class type, but based on usage, we can classify into root, feature, shared, container, and standalone components. </p>

<ol>
  <li> Root Component 
    <ul>
      <li> The entry point of the Angular application. </li>
      <li> Declared in AppModule and bootstrapped in main.ts. </li>
      <li> Example: AppComponent.</li>
    </ul>
  </li>
  <li> Feature Components 
    <ul> 
      <li> Represent a specific feature or section of the app. </li>
  </ul>
  </li>
  <li> Shared/Reusable Components <ul>
    <li> Components used across multiple parts of the app. </li>
    <li> Often placed inside a SharedModule. </li>
    <li> Example: Buttons, modals, loaders. </li>
  </ul>
</li>
<li> 
  Standalone Components (Angular 14+)
  <ul>
    <li> Do not require an NgModule. </li>
    <li> Can be imported directly into other standalone components or modules. </li>
  </ul>
</li>
</ol>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  import { Component } from '@angular/core';

  @Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet],
  templateUrl: './app.component.html',
  styleUrl: './app.component.css'
}) 

export class NgforComponent {}

</code> </pre>
      <p> @Component: A decorator used to convert a normal Typescript class to Angular Component.
      </p>
    </div>



    <div class="box shadow p-2 mb-3" id="root">
      <p> <strong> app-root: </strong> It is the selector/name of the component and it is specified using selector meta
        data of the component's decorator. </p>
      <p> <strong> app.component.html: </strong> It is the HTML template document associated with the component. </p>
      <p> <strong> AppComponent: </strong> Its property (title) is used in the HTML template to set the title of the
        application. </p>
    </div>

    <div class="box shadow p-2 mb-3" id="encapsulation">
      <h2> View Encapsulation </h2>
      <p> View Encapsulation in Angular controls how styles (CSS) are applied to components </p>
      <p> Normally in HTML/CSS, styles are global — meaning CSS from one part of your app could affect other parts.
        Angular provides View Encapsulation to help isolate component styles. </p>
    </div>


    <div class="box shadow p-2 mb-3" id="async-defer">
      <h2> async and defer? </h2>
      <p> They are attributes used with script> tags to control how JavaScript is loaded and executed by the browser.
        This is especially important in Angular because it improves initial page load (performance). </p>
      <ul>
        <li> <strong> async Attribute </strong></li>
        <li> The script is downloaded in parallel (asynchronously) with HTML parsing. </li>
        <li> Once downloaded, the script executes immediately, pausing HTML parsing. </li>
        <li> Scripts with async do not wait for other scripts or DOM to be ready. </li>
        <li> Best for scripts that don’t depend on other scripts and don’t affect DOM structure immediately. </li>
      </ul>
      <pre>
  <code>
    Example- 
    script src="analytics.js" async>/script>
  </code>
</pre>

      <h2> defer Attribute </h2>
      <ul>
        <li> The script is downloaded in parallel (like async) but </li>
        <li> It waits to execute until after the entire HTML document is parsed. </li>
        <li> Maintains the execution order for multiple scripts. </li>
        <li> Best for scripts that need the full DOM ready (like Angular’s main scripts). </li>
      </ul>
      <pre>
  <code>
    script src="main.js" defer> /script>
  </code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="scope">
      <h2> SCOPE </h2>
      <p> In Angular, a scope is an object that refers to the application model. It is a context in which expressions
        can be executed. These scopes are grouped hierarchically, comparable to the DOM structure of the application. A
        scope aids in the propagation of various events and the monitoring of expressions. </p>

    </div>

    <div class="box shadow p-2 mb-3" id="template">
      <h2> TEMPLATE </h2>
      <p>
        Template is basically a super set of HTML. Template includes all the features of HTML and provides additional
        functionality to bind the component data into the HTML and to dynamically generate HTML DOM elements. <br>
        <strong> Template can be categorised into two items :- </strong> <br>
        Data binding {{ title }}, Directives *ngIf="canShow"
      </p>

      <h2> Template Variable </h2>
      <p> template variable is a reference to a DOM element or Angular component/directive defined in your HTML
        template, and it is used within that template only. </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
input #myInput type="text">
---------
input #username type="text">
button (click)="log(username.value)">Log Username button>
------
with angular compoent <br>
app-child #childComp> app-child>
button (click)="childComp.doSomething()">Call Method button>

</code>
</pre>

      <p class="mt-4"> <strong> Angular Template ( ng-template>) </strong> </p>
      <p> Used to define HTML fragments that are not rendered immediately, but can be conditionally or programmatically
        displayed. </p>
      ng-template> is a placeholder for content. <br>
      Used in structural directives like *ngIf, *ngFor.
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>

ng-template #noData>
p>No data available.</p>
/ng-template>

div *ngIf="data.length === 0; else showData">
  ng-container *ngTemplateOutlet="noData"> /ng-container>
/div>

ng-template #showData>
  p>Data is loaded. /p>
/ng-template>

</code>
</pre>

      <p class="mt-4"> <strong> 2. Angular Router Outlet (router-outlet>) </strong></p>

      <p>
        router-outlet> is a placeholder directive that tells Angular where to render the component associated with the
        current route.
        <br> Loads different components dynamically based on route.
      </p>


      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    const routes: Routes = [
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent }
];

  </code>
</pre>


    </div>

    <div class="box shadow p-2 mb-3" id="jse">
      <h2> Difference Between AngularJS and JavaScript Expressions </h2>
      <p> <strong> AngularJS Expression </strong> <br>
        Executed in the context of AngularJS scope (e.g., component/controller).
        <br>
        Used inside {{ }} or directives like ng-bind, ng-if, <br>
        Does not support if, for, while, etc. <br>
        {{ 2 + 2 }}, {{ user.name }}, ng-if="user.isLoggedIn"
      </p>
      <p> <strong> JavaScript Expression </strong> <br>
        Executed in the context of the global window object or current function. <br>
        Used directly in JS code (e.g., if (a > b), console.log(x + y)). <br>
        Fully supports all control structures. <br>
        2 + 2, user.name, if(user.isLoggedIn) { ... }

      </p>
    </div>



    <div class="box shadow p-2 mb-3" id="modules">
      <h2> MODULES, Bootstrap </h2>
      <p> Angular Module is basically a collection of related features/functionality. It groups multiple components and
        services under a single context. </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { BrowserModule } from '@angular/platform-browser'; 
    import { NgModule } from '@angular/core'; 
    import { AppComponent } from './app.component'; @NgModule({ 
    declarations: [ 
      AppComponent 
     ], 
     imports: [ 
      BrowserModule 
     ], 
     providers: [], 
     bootstrap: [AppComponent] 
     }) 
     export class AppModule { }
  </code>
</pre>
      <ol>
        <li> <strong> NgModule </strong> decorator is used to convert a plain Typescript/JavaScript class into Angular
          module. </li>
        <li> <strong> declarations: [AppComponent] </strong> - Declarations option is used to include components into
          the AppModulemodule. </li>
        <li> <strong> bootstrap: </strong> [AppComponent], Bootstrap option is used to set the root component of the
          AppModulemodule. </li>
        <li> <strong> providers: [], </strong> Providers option is used to include the services for the AppModulemodule.
        </li>
        <li> <strong> import{} </strong> imports option is used to import other modules into the AppModulemodule. </li>
      </ol>
    </div>


      <div class="box shadow p-2 mb-3" id="routing">
      <h2> Routing  </h2>
      <p> Routing in Angular is the mechanism that lets you navigate between different views (components) in a single-page application (SPA) without reloading the whole page. </p>

      <h2> <strong> 1. Setting Up Basic Routes </strong></h2>

      <pre>
        <code>
ts file
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

const routes: Routes = [
  { path: '', component: HomeComponent },       // Default route
  { path: 'about', component: AboutComponent }, // /about
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

// html ( app.component.html )

nav>
  a routerLink="/">Home /a>
  a routerLink="/about">About /a>
/nav>

<!-- Place where routed component will be shown -->
router-outlet> /router-outlet>


        </code>
      </pre>

<h2 class="mt-4"> 2. Route Parameters </h2>
<p> Route parameters let you pass dynamic values in the URL to a component. </p>
<pre>
<code>
In app-routing.module.ts:
{ path: 'user/:id', component: UserComponent }
In user.component.ts:
import { ActivatedRoute } from '@angular/router';
constructor(private route: ActivatedRoute) {
  this.route.params.subscribe(params => {
    console.log(params['id']); // Get the 'id' from URL
  });
}
</code>
</pre>

<h2 class="mt-4"> 3. Child Routes (Nested Routes) </h2>
<p> Child routes allow you to create routes within routes, useful for layouts or sections with sub-pages. </p>
<pre>
  <code>
ts
{ 
  path: 'products', 
  component: ProductsComponent,
  children: [
    { path: 'list', component: ProductListComponent },
    { path: 'details/:id', component: ProductDetailsComponent }
  ]
}

html 

router-outlet> /router-outlet> <!-- child routes load here -->


  </code>
</pre>


      </div>

    <div class="box shadow p-2 mb-3" id="services">
      <h2> SERVICES </h2>
      <p> Services is class providing a very specific functionality. The main purpose of the service is to make a
        certain feature reusable. </p>
      <h2> Use a Service in a Component </h2>
      <ul>
        <li> Inject the service in the constructor </li>
        <li> Call its methods </li>
      </ul>
      <h2> Data Sharing Between Components </h2>
      <ul>
        <li> Share user data </li>
        <li> Centralize API calls </li>
        <li> Store temporary app state </li>
      </ul>
      <h2> <strong> Advantages of Angular Services </strong> </h2>
      <ul>
        <li> <strong> Code Reusability </strong> Business logic is reusable across components </li>
        <li> <strong> Separation of Concerns </strong> Keeps components clean by offloading logic </li>
        <li> <strong> Centralized Data Access </strong> Fetch or update data from one place </li>
        <li> <strong> Dependency Injection </strong> Easy to inject and manage services </li>
        <li class="mt-2"> <strong> Disadvantages / Things to Watch For </strong></li>
        <li> <strong> Overuse </strong> Putting everything in a service can make it too bloated </li>
        <li> <strong> Tight Coupling </strong> Components might become too dependent on services </li>
        <li> <strong> Memory Leaks </strong> Unsubscribed Observables in services can cause memory issues </li>
      </ul>

      <h2> <strong> Use @Injectable({ providedIn: 'root' }) for global access </strong></h2>
      <h2> <strong> Handle Errors in Service </strong></h2>
      <pre>
  <code>
    getUsers(): Observable any[]> {
  return this.http.get any[]>(this.apiUrl).pipe(
    catchError(error => {
      console.error('API error', error);
      return throwError(() => new Error('Something went wrong!'));
    })
  );
}
  </code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="metadata">
      <h2> METADATA </h2>
      <p> Angular, metadata is used to provide additional information about a class, component, or service. </p>
    </div>


    <div class="box shadow p-2 mb-3" id="angularrun">
      <h2> How to run angular Project ? </h2>
      <p> When we run Angular application on the browser after that first file index.html loaded. Then, <br>
        <strong> Browser </strong> looks the main <strong> TypeScript file, main.ts </strong> <br>
        so there is the entry point of Angular application. <br> after than
        bootstraps file <strong> <br>
          than AppComponent (src/app.component.ts), </strong> <br>
        the root component of every Angular application. <br>
        The AppComponent renders its template (src/app.component.html) and uses the styles (src/app.component.css). <br>
        <strong> AppComponent </strong> name, i.e., app-root is used inside the <strong> src/index.html </strong>
        so that view of the angular application can be rendered.
      </p>
      <ol>
        <li> <strong> NgModule </strong> decorator is used to convert Typescript class into Angular module. </li>
        <li> <strong> declarations: [AppComponent] </strong> - Declarations option is used to include components into
          the AppModulemodule. </li>
        <li> <strong> bootstrap: </strong> [AppComponent], Bootstrap option is used to set the root component. </li>
        <li> <strong> providers: [], </strong> Providers option is used to include the services . </li>
        <li> <strong> import{} </strong> imports option is used to import other modules into the AppModulemodule. </li>
      </ol>
      <h2 class="mt-4"> <strong> BOOTSTRAP </strong> </h2>
      <p class="m-0 p-0"><strong> Bootstrap start the angular application by loading root component through main.ts file
        </strong></p>
      <p> <strong> Bootstrap process </strong> Bootstrap => main.ts => app component ( app-root> /app-root> ) =>
        index.html </p>

      <h2 class="mt-4"> <strong> Browser Behind Angular Application </strong> </h2>
      <p> Browser Load index.html ( app-root> /app-root> ) => <br> Main.ts (File Runs) => <br> Bootstrap Application => <br> Angular
        Replace app-root> /app-root> ( HTML from APP component ) <br>
        => Angular Setup DI Dependancy Injection ( Services, Routes, HTTP Client ) => Router read the URL => Component (
        Tree Based ) => Data Binding Event = Angular Render DOM
      </p>


    </div>


    <div class="box shadow p-2 mb-3" id="angularcli">
      <h2> ANGULAR CLI </h2>
      <p> Angular CLI (Command Line Interface) is a powerful tool that helps automate and streamline the development
        process for Angular applications. It provides a set of commands for creating, managing, and building Angular
        projects. </p>
    </div>

    <div class="box shadow p-2 mb-3" id="angularcontroller">
      <h2> Controllers in Angular </h2>
      <p> In AngularJS (Angular 1.x), controllers were used to manage the application's logic and data binding. However,
        in modern Angular (2+), controllers are replaced by components. </p>
    </div>

    <div class="box shadow p-2 mb-3" id="angularspa">
      <h2> SPA and CHALLENGING WORK / SHARED SERVICES </h2>
      <p> Single Page Application (SPA) is a web application that dynamically updates content without reloading the
        entire page.
        Faster Page Loads , Smooth User Experience, Efficient Data Fetching <strong> Examples - GMAIL, FACEBOOK,
          NETFLIX, TWITTER </strong> </p>
      <h2> CHALLENGING WORK </h2>
      <p> I was working on an Angular project where we used a reactive form with a select box for gender (Male and
        Female) multiple times across different components. Later, we realized that instead of repeating the same logic,
        we could create a reusable service for gender options, making the implementation more efficient and
        maintainable. </p>

      <h2> SHARED SERVICES </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        genders = [
            {"id": "male", "name": "Male"},
            {"id": "female", "name": "Female"},
            {"id": "other", "name": "Other"}
          ]

        select 
        option -  *ngFor="let gender of genders" value="{{gender.id}}" ,  {{gender.name}}
          
      </code>
    </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="architecture">
      <h2> Angular Architecture </h2>
      <p> Angular is a front-end framework developed by Google for building dynamic single-page applications (SPAs).
        <br> It follows a component-based architecture where the entire application is structured into modular, reusable
        components. <br> At its core, Angular applications are made up of modules, components, templates, directives,
        services, and dependency injection.<br> The root module, typically named AppModule, acts as the entry point of
        the application and can include multiple feature modules to organize different functionalities. These modules
        help in maintaining scalability by dividing the application into separate logical parts. </p>
      <p> A component in Angular is the fundamental building block of the UI. <br> Each component consists of three
        parts: an HTML template that defines the structure, a TypeScript class that contains business logic, and a CSS
        file that handles styling. </p>
      <p> To enhance the functionality of templates, Angular provides directives. Structural directives, such as *ngIf
        and *ngFor, modify the DOM by adding or removing elements dynamically, while attribute directives, such as
        [ngClass] and [ngStyle], change the appearance or behavior of elements. Additionally, pipes are used to
        transform and format data within templates. </p>
      <p> Services are singleton objects that can be injected into multiple components using Angular’s dependency
        injection (DI) system. This ensures better code reusability and separation of concerns. For handling HTTP
        requests. </p>
      <p> One of Angular’s most powerful features is routing, which enables navigation between different views without
        requiring a full page reload. The RouterModule manages the application’s routes and allows users to define
        URL-based navigation paths for different components. </p>
      <p> Under the hood, Angular’s change detection mechanism optimizes performance by updating only the necessary
        parts of the UI when data changes. It employs a unidirectional data flow with the ability to detect and update
        changes efficiently. </p>
      <p> Overall, Angular’s structured approach, modularity, and built-in functionalities make it an ideal choice for
        developing large-scale enterprise applications. </p>
    </div>

    <div class="box shadow p-2 mb-3" id="life-cycle">
      <h2> LIFE CYCLE </h2>
      <p> <strong> Lifecycle hooks in Angular are special methods that get called at different stages of a component’s
          lifecycle. </strong></p>

      <ol>
        <li> <strong> constructor </strong> - for variable initialization </li>
        <li> <strong> ngOnChanges() </strong> - Called when input properties change </li>
        <li> <strong> ngOnInit(){} </strong> - Called once after component initialization </li>
        <li> <strong> ngDoCheck() </strong> - Called during every change detection cycle </li>
        <li> <strong> ngAfterContentInit() </strong> - Called after content projection (<ng-content>) is initialized
        </li>
        <li> <strong> ngAfterContentChecked()</strong> - Called after projected content is checked </li>
        <li> <strong> ngAfterViewInit() </strong> - This hook is called after Angular has fully initialized the
          component's view <br>
          (i.e., after the HTML template is rendered and child components are loaded). </li>
        <li> <strong> ngAfterViewChecked() </strong> - Called after the component’s and child views are checked </li>
        <li> <strong> ngOnDestroy() </strong> Called just before the component is destroyed </li>
      </ol>
      <p> You should use <strong> ngAfterViewInit() </strong> when: <br> You need to interact with the DOM (e.g., via
        @ViewChild) <br> You need to trigger logic that depends on the fully initialized view <br> Like measuring
        elements, integrating third-party libraries, animations, etc. </p>

      <p> <strong> ngOnChanges() </strong> is only triggered when there are changes to input (@Input) properties. If a
        component has no input properties, or if no changes are made to them, the ngOnChanges() lifecycle hook will not
        be called. </p>

      <p> <strong> ngOnChanges() </strong> <strong> ngDoCheck() </strong> Different Between = </p>
      <p> <strong> ngOnChanges() </strong> Automatically called when Angular detects changes to input properties
        (@Input()). </p>
      <p> Reacting to updated input data from parent components.</p>
      <p> <strong> ngDoCheck() </strong> Called every time change detection runs., It manually or deep change tracking.
      </p>
      <p> <strong> “Change Detection Cycle” </strong> :- </p>
      <p> In Angular, a change detection cycle is the process where Angular checks your app to see if any data has
        changed, and if so, it updates the DOM to reflect changes. </p>
      <p> For examples - User input (input> typing) <br> Events (click, submit, etc.) <br> HTTP responses <br>
        setTimeout, setInterval <br> Promise or Observable resolution <br> Manually triggered with
        ChangeDetectorRef.detectChanges()</p>
      <p> if you click a button 5 times, ngDoCheck() will run 5 times.</p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
        <code>
          <h2> ngOnChanges() </h2>
          Examples - 
          => Child component --- 
          @Input() item: any;
          ngOnChanges(){
          alert("Data has been updated by parent component...")
          }
          HTML -- 
          {{item}}
      
       => PARENT COMPONENT
          name = 'coding'
          fun(){
           this.name = "Value has been chaged"
           }
          HTML --- 
          app-child item={{name}}> app-child
          button click="fun()"> click me button
        </code>
      </pre>

      <h2 class="mt-5"> Where I should variable write in constructor or ngOnInit in angular and why ? </h2>

      <p> <strong> Constructor - Use constructor() when: </strong></p>
      <ul>
        <li> You want to inject dependencies (services, etc.). </li>
        <li> You need to initialize simple variables </li>
        <li> constructor(private userService: UserService) {
          this.title = 'Hello World'; // simple assignment is okay here
          }</li>
      </ul>

      <p> <strong> Use ngOnInit() when : </strong></p>
      <ul>
        <li> You want to run code after the component is fully initialized. </li>
        <li> You need to access @Input properties, DOM elements, or perform API calls. </li>
        <li> You need to call functions that rely on bindings or Angular lifecycle hooks. </li>
        <li> ngOnInit() {
          this.userService.getUsers().subscribe(data => {
          this.users = data;
          });
          }
        </li>
      </ul>

      <p><strong> Difference between constructor and ngOnInit </strong></p>
      <ul>
        <li> <strong> Constructor </strong></li>
        <li> A TypeScript feature (not Angular-specific). </li>
        <li> Called immediately when the class is instantiated. </li>
        <li> Used mainly for dependency injection. </li>
        <li> Cannot access Angular bindings like @Input(), DOM elements, etc. </li>
        <li> Runs before Angular initializes the component. </li>
      </ul>

      <ul>
        <li> <strong> ngOnInit() </strong></li>
        <li> An Angular lifecycle hook (part of OnInit interface). </li>
        <li> Called by Angular after the constructor and after input properties (@Input()) are set. </li>
        <li> Fetching data from APIs</li>
        <li> Accessing @Input() values </li>
        <li> Running component initialization logic </li>
      </ul>

    </div>


    <div class="box shadow p-2 mb-3" id="optimize">
      <h2> OPTIMIZE ANGULAR PAGE </h2>
      <p> <strong> Use of Loaders everywhere possible </strong> Whenever API is call in is progress we need to show
        loader. So that user will know something is process going on. </p>

      <p> <strong> Avoid duplicate API call. </strong> For example, when creating a user or employee record, after
        filling in all the required fields and clicking the "Save" button, an API call is triggered. However, if the
        "Save" button is clicked multiple times quickly, multiple API requests are sent. It will be increases the
        loading time and server load.
        That's why we need api call in codition that onetime call on click. </p>

      <P><strong> Use Pagination for Large Data Sets </strong> When retrieving large amounts of data from an API, it's
        important to implement pagination. Instead of loading all records at once, we should load a limited number of
        items as 10 or 20 per page—and fetch more data as the user navigates through the pages. This approach helps
        optimize loading time and improves overall performance and user experience. </P>

      <p> <strong> Create Reusable Services for Common Form Data </strong> For example, if I'm using a reactive form
        with a gender dropdown (e.g., "Male" and "Female"), and this dropdown is required in multiple forms across the
        application, it's a good practice to create a reusable service to provide the gender options. This way, instead
        of duplicating the same code in every form, we can fetch the gender list from a single source. This improves
        code reusability, maintainability, and keeps the codebase clean and optimized. </p>
      <p>
        <strong> Delegate Certain Logic to the Backend for Better Frontend Performance </strong>
        Some logic or conditions should be handled on the backend to reduce the complexity and data load on the
        frontend. For example, implementing pagination on the backend ensures that only a limited set of data is sent to
        the frontend at a time. This helps improve performance, reduces loading time, and keeps the frontend code
        simpler and more efficient.
      </p>

      <h2> <strong> Bundle size </strong></h2>
      <p> Bundle size refers to the total size of all the JavaScript, CSS, and other assets that are downloaded to run
        your Angular application in the browser. </p>
      <p> Minimizing bundle size is critical for: </p>
      <ul>
        <li> Faster load time </li>
        <li> Better performance (especially on mobile) </li>
        <li> SEO and Core Web Vitals </li>
      </ul>
      <h2> Angular Build Optimizations </h2>
      <p> Angular CLI automatically applies the following during --prod build: </p>
      <ul>
        <li> AOT (Ahead-of-Time) Compilation </li>
        <li> Tree-shaking </li>
        <li> Minification </li>
        <li> Dead code elimination </li>
      </ul>

      <ol>
        <li> Optimize Change Detection </li>
        <li> Lazy Loading </li>
        <li> Reduce Bundle Size ( AOT AHEAD OF TIME ) </li>
        <li> Optimize Third-Party Libraries </li>
        <li> Optimize CSS & Styles, Otimize http, Minimize CSS & Use Critical CSS, CSS minification, Web Workers </li>
        <li> USE track by </li>
      </ol>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code>
            *ngFor="let item of items; trackBy: trackByFn">{{ item.name }}
              this.http.get('https://api.example.com/data', { cache: 'force-cache' });
          </code>
        </pre>

      <h2 class="mt-4"> Best tools and techniques for opimization </h2>
      <ol>
        <li> Angular CLI Built-in Tools
          <ul>
            <li> Enables Ahead-of-Time (AOT) compilation. </li>
            <li> Minifies JS/CSS, removes dev code. </li>
            <li> Enables tree-shaking (removes unused code). </li>
          </ul>
        </li>
        <li> Bundle Analysis Tools
          <ul>
            <li> Webpack Bundle Analyzer </li>
            <li> Visualize bundle sizes. </li>
            <li> command <br> ng build --stats-json <br>
              npx webpack-bundle-analyzer dist/stats.json </li>
          </ul>
        </li>
        <li> Code Splitting & Lazy Loading </li>
        <li> Tree Shaking and Dead Code Removal </li>
        <li> Lazy Load Images and Components <br> img [defaultImage]="placeholder" [lazyLoad]="imageUrl" /> </li>
        <li> Server-Side Rendering (SSR) with Angular Universal </li>
        <li> Service Worker and PWA , ng add @angular/pwa</li>
      </ol>

    </div>


    <div class="box shadow p-2 mb-3" id="accessibility">
      <h2> Accessibility (A11Y) </h2>
      <p> <em> "Accessibility in Angular means developing applications that are usable by all users, including those with disabilities. This involves using semantic HTML, ARIA attributes, Angular Material components with built-in a11y support, and ensuring keyboard and screen reader compatibility."</em></p>

      <p class="p-0 m-0"> Make your UI inclusive for everyone (including users with disabilities). </p>
      <p class="p-0 m-0"> Add alt text for images. </p>
      <p class="p-0 m-0"> Use ARIA attributes for better screen reader support. </p>
      <p class="p-0 m-0"> Ensure high color contrast for readability </p>
      <p class="p-0 m-0"> Minify CSS, JS and enable Gzip compression. </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code> const routes: Routes = [
            { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) },
            { path: '**', redirectTo: 'feature' } // Wildcard route (optional)
          ]; </code></pre>
    </div>


    <div class="box shadow p-2 mb-3" id="apiservices">

      <h2> API CALL RESTful APIs -- API serives </h2>
      <p> Angular, RESTful APIs allow the frontend to communicate with a backend server by making HTTP requests. Angular
        provides the HttpClient module to perform CRUD (Create, Read, Update, Delete) operations with APIs. </p>

      <h2 class="mt-4"> Why Do We Use APIs in Angular Projects ? </h2>
      API = Application Programming Interface <br>
      In Angular (a frontend framework), APIs allow your app to talk to a backend server or external services to:<br>
      <strong> 1. Get Data </strong><br>
      Example: Fetch product details, user info, or blog posts from a database through an API.<br>
      <strong> 2. Send Data </strong><br>
      Example: When a user submits a form (like login, registration), the data is sent via an API to the server.<br>
      <strong> 3. Update or Delete Data </strong><br>
      API allows your app to update or delete something in the backend (e.g., edit a profile, delete a comment).<br>
      <strong> 4. Secure & Scalable </strong><br>
      APIs enforce security, validation, and rules.<br>
      <h2 class="mt-3"> <strong> How Important is API in Angular? </strong> </h2>
      <p class="m-0 p-0"> Without APIs : Your Angular app is static – it can't fetch or update live data. </p>
      <p class="m-0 p-0"> You can’t store user info, login users, or interact with databases. </p>

      <h2 class="mt-3"> <strong> Common API Tools in Angular : </strong> </h2>
      <p class="m-0 p-0"> HttpClientModule for making API requests </p>
      <p class="m-0 p-0"> HttpClient.get(), post(), put(), delete() </p>
      <p class="m-0 p-0"> Uses Observables to handle async responses </p>
      <br>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
            ngOnInit() {
              this._http.get('users/user/details/'+this.user_id).subscribe((resposne: any) => {
                this.user = resposne.user
                console.log(resposne);
              })
            }
          </code></pre>

      <p class="mt-4"> <strong> What is different between Web API and Rest API </strong></p>
      <P> <strong> Web API (Web Application Programming Interface) </strong></P>
      <ul>
        <li> Definition: A Web API is a general term for any API that can be accessed over the web using the HTTP
          protocol. </li>
        <li> Purpose: It allows communication between client and server applications. </li>
        <li> Format: Can use any format like JSON, XML, or even HTML. </li>
        <li> Architecture: Can follow any architecture style, such as REST, SOAP, GraphQL, etc. </li>
      </ul>

      <P> <strong> REST API (Representational State Transfer API) </strong></P>
      <ul>
        <li> Definition: A specific type of Web API that follows the REST architecture. </li>
        <li> Stateless (each request is independent) </li>
        <li> Uses HTTP methods: GET, POST, PUT, DELETE </li>
        <li> Resource-based (each URL represents a resource) </li>
        <li> Uses standard response codes (like 200, 404, etc.) </li>
        <li> Data Format: Typically uses JSON, but can also support XML. </li>
      </ul>

      <hr>

      <P> <strong> When you call multiple APIs in the same Angular component, and one of them fails, it's important to
          handle errors gracefully so the app doesn’t break and other successful calls can still work. </strong></P>

<h2> <strong> Interview Tip: </strong></h2>
<p> "If one API fails, how will you handle it while calling multiple APIs in Angular?" </p>
<ol>
  <li> <strong> Use forkJoin when you want all must succeed. </strong></li>
  <li> Use catchError with forkJoin to allow partial success. </li>
  <li> Use switchMap/concatMap for sequential dependent APIs. </li>
  <li> You can also mention combineLatest if APIs can emit multiple times (less common for HTTP). </li>
</ol>
<pre>
  <code>
import { forkJoin } from 'rxjs';
import { catchError } from 'rxjs/operators';

forkJoin({
  api1: this.http.get('url1'),
  api2: this.http.get('url2'),
  api3: this.http.get('url3')
}).subscribe({
  next: result => {
    console.log('All APIs succeeded', result);
  },
  error: err => {
    console.error('One of the APIs failed', err);
    // Handle failure (show error message, etc.)
  }
});
  </code>
</pre>

      <p> <strong> Next Option - Best Practices to Manage Multiple API Calls </strong></p>
      <ul>
        <strong> 1. Use forkJoin (if all APIs must succeed) </strong>
        <li> forkJoin waits for all observables to complete. </li>
        <li> If one fails, the whole call fails — so use it only when all APIs are required. </li>
        <li> To manage failure: use catchError inside each observable to prevent the failure from breaking others. </li>
      </ul>

      <ul>
        <strong> 2. Use combineLatest (if continuous data updates are expected) </strong>
        <li> Emits when any observable emits, but keeps the latest value of all. </li>
        <li> Suitable when you expect real-time data or need non-blocking behavior. </li>
      </ul>

      <ul>
        <strong> 3. Use individual API calls separately </strong>
        <li> Call APIs one by one using .subscribe() or chained observables. </li>
        <li> Use try/catch (with catchError from RxJS) to handle each API separately. </li>
      </ul>

      <h2> Error Handling Strategy </h2>
      <ol>
        <li> Use catchError() operator from RxJS to handle individual failures. </li>
        <li> Show fallback UI or messages for the failed API section only. </li>
        <li> Do not block the component’s UI for one API failure. </li>
        <li> Log error for debugging or notify users gracefully. </li>
      </ol>

      <h2> What To Do When One Fails? </h2>
      <ul>
        <li> Don’t stop the other API calls — fail gracefully. </li>
        <li> Use default data, loading/error messages, or retry mechanism. </li>
        <li> Keep user experience smooth — show success sections even if one section has error. </li>
      </ul>

      <hr>

      <h2> <strong> API security </strong> </h2>
      <p class="m-0 p-0"> While it’s a frontend framework and can’t directly secure APIs, you can implement best
        practices to enhance frontend-side API security and communication. </p>

      <h2 class="mt-3"> Use Authentication (e.g., JWT) </h2>
      <p class="m-0 p-0"> Login flow: User logs in → Backend sends a JWT token → Save in Angular (e.g., in memory or
        localStorage). </p>
      <p class="m-0 p-0"> Attach token to each request using an HTTP interceptor. </p>

      <h2 class="mt-3"> Use HTTPS </h2>
      <p class="m-0 p-0"> Always serve your Angular app and API over HTTPS. </p>
      <p class="m-0 p-0"> Prevents Man-in-the-Middle (MITM) attacks. </p>

      <h2 class="mt-3"> Restrict CORS on Backend </h2>
      <p class="m-0 p-0"> Backend should only allow requests from your trusted domain. </p>
      <p class="m-0 p-0"> E.g., allow only https://yourapp.com in CORS settings. </p>

      <h2 class="mt-3"> Avoid Storing Sensitive Data in LocalStorage </h2>
      <p class="m-0 p-0"> Tokens in localStorage are accessible via JavaScript and vulnerable to XSS attacks. </p>
      <p class="m-0 p-0"> Use HttpOnly cookies if possible (requires backend support), or store JWTs in memory during a
        session. </p>

      <h2 class="mt-3"> Use Angular Route Guards </h2>
      <p class="m-0 p-0"> Protect certain routes in your Angular app using CanActivate.
        canActivate(route: ActivatedRouteSnapshot): boolean {
        return this.authService.isLoggedIn();
        }</p>

    </div>


<div class="box shadow p-2 mb-3" id="http-request">

<div class="my-4">
<p class="p-0 m-0"> <strong> How do you make HTTP requests in Angular? </strong></p>
<p> You use Angular's HttpClient module to make HTTP requests. </p>
<ul>
  <li> First, import HttpClientModule in AppModule. </li>
  <li> Inject HttpClient in your service or component. </li>
  <li> Use methods like get(), post(), put(), delete(). </li>
</ul>
</div>

<div class="my-4">
<p class="p-0 mb-2"> <strong> How to import and configure HttpClientModule in Angular ? </strong></p>
<pre>
<code>
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule
  ],
})
export class AppModule { }
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> Explain how to consume a REST API GET request in Angular. </strong></p>
<pre>
<code>
import { HttpClient } from '@angular/common/http';
constructor(private http: HttpClient) {}
getData() {
  this.http.get('https://api.example.com/data').subscribe(response => {
    console.log(response);
  });
}
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> How do you send data using POST request in Angular? </strong></p>
<pre>
<code>
postData(data: any) {
  return this.http.post('https://api.example.com/data', data);
}
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> How to handle HTTP error responses in Angular? </strong></p>
<pre>
<code>
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';

this.http.get('url').pipe(
  catchError(error => {
    console.error(error);
    return throwError(() => error);
  })
).subscribe();

</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> What is Interceptor in Angular and how is it used for API calls? </strong></p>
<p> An HTTP Interceptor is a middleware that intercepts HTTP requests and responses. You can use it to add headers (like auth tokens), handle errors globally, log requests, etc. </p>
<pre>
<code>
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    const cloned = req.clone({
      headers: req.headers.set('Authorization', 'Bearer TOKEN_HERE')
    });
    return next.handle(cloned);
  }
}
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> How to implement retry logic for failed API calls in Angular? </strong></p>
<pre>
<code>
import { retry } from 'rxjs/operators';

this.http.get('url').pipe(
  retry(3)
).subscribe();
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> How can you cancel an ongoing HTTP request in Angular? </strong></p>
<p> You can use RxJS Subject to trigger an unsubscribe: </p>
<pre>
<code>
private unsubscribe$ = new Subject<void>();

this.http.get('url').pipe(
  takeUntil(this.unsubscribe$)
).subscribe();

ngOnDestroy() {
  this.unsubscribe$.next();
  this.unsubscribe$.complete();
}
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> Explain how Observables work with HTTPClient. </strong></p>
<p> HttpClient methods like get(), post() return Observables. Angular subscribes to these Observables to handle async data streams, enabling operators like map, filter, catchError, etc., for transformation and error handling. </p>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> Difference between HttpClient and Http in Angular? </strong></p>
<ul>
<li> HttpClient (introduced in Angular 4.3) is a simplified, improved, and powerful API.</li>
<li> Http is deprecated. </li>
<li> HttpClient provides typed response objects, interceptors, progress events, etc. </li>
</ul>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> How to handle API loading states (show loader) globally in Angular? </strong></p>
<p> Use an HTTP Interceptor to track requests in progress: </p>
<pre>
<code>
@Injectable()
export class LoaderInterceptor implements HttpInterceptor {
  constructor(private loaderService: LoaderService) {}
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    this.loaderService.show();
    return next.handle(req).pipe(
      finalize(() => this.loaderService.hide())
    );
  }
}
</code>
</pre>
</div>



<div class="my-4">
<p class="p-0 mb-2"> <strong> What are RxJS operators commonly used with REST API in Angular? </strong></p>
<p> Use an HTTP Interceptor to track requests in progress: </p>
<pre>
<code>
map()
filter()
switchMap()
mergeMap()
concatMap()
catchError()
retry()
finalize()
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> How to handle multiple API calls and wait for all to finish? </strong></p>
<p> Use RxJS forkJoin: </p>
<pre>
<code>
forkJoin([
  this.http.get('url1'),
  this.http.get('url2')
]).subscribe(([response1, response2]) => {
  console.log(response1, response2);
});
</code>
</pre>
</div>


<div class="my-4">
<p class="p-0 mb-2"> <strong> Difference between Promise and Observable in HTTP Requests (Angular) </strong></p>
<ul>
<li> <strong> Promise </strong></li>
<li> Executes immediately when created.	 </li>
<li> Can handle only one response. </li>
<li> Does not support RxJS operators (map, filter).	</li>
<li> Cannot be cancelled once started.	 </li>
<li> Can chain using .then().	</li>
<li> Handled via .catch().	 </li>
<li> Rarely used in HTTP (old way).	 </li>
<li> <strong> Observable </strong></li>
<li> Executes only when subscribed. (Lazy by nature) </li>
<li> Can emit multiple values over time (Streams). </li>
<li> Supports powerful RxJS operators (map, filter, etc.) </li>
<li> Can be cancelled using unsubscribe(). </li>
<li> Uses operators like pipe(), switchMap(), etc. </li>
<li> Handled via catchError() operator. </li>
<li> Angular's HttpClient returns Observables. </li>
</ul>
</div>

<div class="my-4">
<p class="p-0 mb-2"> <strong> Example: Angular HTTP Request </strong></p>
<pre>
<code>
// Observable (Angular HttpClient default)
this.http.get('api/url').subscribe(data => {
  console.log(data);
});

// Promise (converted from Observable)
this.http.get('api/url').toPromise().then(data => {
  console.log(data);
});
</code>
</pre>
<h2 class="mt-4"> <strong> Which is better in Angular HTTP? </strong></h2>
<p> Angular’s HttpClient returns Observables because they provide more flexibility like cancellation, multiple values handling, and RxJS operators. Promises are useful for simple one-time responses but lack the stream capabilities and operators that Observables offer.</p>
</div>



</div>


    <div class="box shadow p-2 mb-3" id="validation">
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
              lead_form!: FormGroup
lead_fields = {
  name     : ['', Validators.required],
  email    : ['', Validators.required],
}
constructor( private _fb    : FormBuilder ){
  this._route.queryParams.subscribe(params => { this.tenant_id = params['id']})
}
ngOnInit(){this.initializeForm()}
initializeForm(){
  this.lead_form = this._fb.group(this.lead_fields)
  this.getLeads()
}
getLeads(){
  let params = [{"key": "tenant_id", "value": this.tenant_id},{"key": "limit", "value": 100}]
  this._http.get('leads/leads/', params).subscribe((response:any) => {
    this.leads = response;
    this.action = "Add"
  },(error: any) => {this.errorMessage(error)})
}
            </code></pre>
    </div>





    <div class="box shadow p-2 mb-3" id="crud">
      <h2> CRUD </h2>
      CREATE
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
    
  createLead(){
    this._http.post('leads/leads/', this.setPayload(this.lead_form.value)).subscribe((response: any) => {
      this.afterAction("Lead Saved")
    },(error: any) => {this.errorMessage(error)})
  }
  
  EDIT
  setPayloadForEdit(form: any){
    return {
      "name"     : form.name,
      "email"    : form.email,
    }
  }
  editLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)

    // delete payload.tenant_id
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)})
  }


  updateLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)
    // delete payload.tenant_id
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)})
  }

  deleteLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    this._http.delete('leads/leads/'+this.lead_id, params).subscribe((response:any) => {
      this.afterAction("Lead Deleted")
    },(error: any) => {this.errorMessage(error)})
  }
  </code></pre>
    </div>



    <div class="box shadow p-2 mb-3" id="upgrade">
      <h2> HOW TO UPGRADE OLD VERSION TO NEW VERSION </h2>
      <div>
        => Always backup your project before upgrading.
        => Use Git commits to track changes at each step.
        1. Check the Current Angular Version <br>
        ng version
        2. Update Angular CLI Globally <br>
        npm install -g @angular/cli
        3. ng update @angular/core@16 @angular/cli@16 <br>
        4. Update Other Dependencies <br>
        ng update
        -------------
        You should upgrade step by step from Angular 15 → 16 → 17 → 18 → 19 rather than jumping directly from Angular 15
        to Angular 19.
        If You Try Directly Updating from 15 to 19? <br>
        1. dependency conflicts and errors. <br>
        2. Some configurations (like angular.json) might break due to missing intermediate updates. <br>
        3. Third-party libraries might not support Angular 19<br>
      </div>

      <div>
        <h2> During angular project update 15 to 17 version, How to know which third party tools I have to update in
          angular ? </h2>
        <p> review third-party dependencies </p>
        1. Use ng update command<br>
        2. Check official Angular update guide<br>
        3. Look into package.json manually<br>
        4. Run npm outdated, This command shows all outdated packages, including third-party ones:<br>
        Check GitHub Issues or Docs for Major Libs<br>
      </div>

    </div>


    <div class="box shadow p-2 mb-3" id="rxjs">
      <h2> RxJS for Reactive Programming (RxJS) </h2>

      <p> RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables.
        It's used in Angular to handle asynchronous operations, events, and data streams. </p>

      <p class="mt-4"> <strong> Why RxJS is Used in Angular? </strong></p>
      <ul>
        <li> RxJS stands for Reactive Extensions for JavaScript. </li>
        <li> It is a library for reactive programming using Observables. </li>
        <li> Think of it like a tool to handle async data streams (like events, HTTP calls, user inputs, etc.) more
          efficiently. </li>
      </ul>

      <p class="mt-4"> <strong> Benefits of RxJS in Angular </strong> </p>
      <ul>
        <li>Observables - Easy to work with asynchronous operations like HTTP, events, and user inputs. </li>
        <li> Operators (like map, filter, switchMap) - Powerful tools to transform and manage data streams. </li>
        <li> Reactive Forms - Angular forms use observables behind the scenes. </li>
        <li> HTTP Client - Angular's HttpClient returns Observables, not Promises. </li>
        <li> Real-time Data - Ideal for apps with real-time features like chat, notifications, or live updates. </li>
      </ul>

      <p class="mt-4"> <strong> What if RxJS was not in Angular? </strong> </p>
      <ul>
        <li> You’d have to use Promises, callbacks, or manual subscriptions. </li>
        <li> Managing multiple async operations (like dependent HTTP calls, or canceling previous API calls) would be
          very complex. </li>
        <li> You'd lose powerful operators like debounceTime, switchMap, retry, etc., which simplify async logic. </li>
      </ul>


      <p><strong> Rxjs use in HTTP Request, Reactive Forms, Routing(params, guards), Event management, State Management
        </strong></p>

      <p> Rxjs operator - map, filter, etc </p>
      <p> Benefits - Powerful data transformation using operators</p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      <h2> Simple examples </h2>

      import { Observable } from 'rxjs';

let observable = new Observable((observer) => {
  setTimeout(() => {
    observer.next("Observable is working");
    observer.complete();
  }, 2000);
});

observable.subscribe({
  next: (result) => console.log(result),
  complete: () => console.log("Observable Completed")
});

    </code>
  </pre>

      <p><strong> JavaScript Promises make handling asynchronous operations like API calls, file loading, or time delays
          easier. </strong></p>
      <p> Difference between </p>

      <strong> Promise -- </strong>
      // Promise excute immediately when create promises. <br>
      // Pomise emit single value. Promise don't have operator . <br>
      // Promise cann't be cancel <br>
      <strong> Observable -- </strong>
      // Observable does not start untill subscription. <br>
      // Observable emit multiple value.<br>
      // Observable operator like map, filter, reduce. <br>
      // Observable can be cancel using unscribe method <br>

      <h2 class="mt-4"> * Promises - A Promise in JavaScript represents a value that may be available now, in the
        future, or never. </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    let myPromise = new Promise((resolve, reject) => {
      let success = true; // Change this to false to see the reject case
      setTimeout(() => {
        if (success) {
          resolve("Operation Successful!");
        } else {
          reject("Something went wrong!");
        }
      }, 2000);
    });
    myPromise
      .then(result => console.log(result)) // Runs when promise is resolved
      .catch(error => console.log(error)); // Runs when promise is rejected  
  </code>
</pre>

      <p> <strong> Observable is a stream of data that can emit multiple values over time. You can subscribe to an
          Observable to receive these values. </strong></p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  myObservable: Observable<number>;
    ngOnInit() {
      this.myObservable = new Observable(observer => {
        let count = 1;
        setInterval(() => {
          observer.next(count++); // Emits a value every second
        }, 1000);
  
      });
      this.myObservable.subscribe(value => {
        console.log('Received:', value);
      });
    }
</code></pre>

      <h2> RxJS Operators </h2>
      <p><strong> Filtered Values: {{ values }} </strong></p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  ngOnInit() {
    const numbers$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9);
    numbers$.pipe(
      filter(num => num % 2 === 0), // Filter even numbers
      map(num => num * 10) // Multiply each by 10
    )
    .subscribe(result => {
      this.values.push(result);
    });
  }
</code></pre>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    let observable = new Observable((observer) => {
      setTimeout(() => {
        observer.next("observable is working");
        observer.complete();
      }, 1000)
      })
      
      observable.subscribe({
        next: (result) => console.log(result),
        complete: () => console.log("Observable completed")
      })
  </code>
</pre>

      <h2> Example: Converting Promise to Observable </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  const promise = new Promise((resolve) => {
    setTimeout(() => resolve('Promise resolved!'), 2000);
  });

  // Convert Promise to Observable

  const observable$ = from(promise);
  observable$.subscribe(value => console.log(value));
</code></pre>

      <h2> Handling HTTP Request with Observable vs Promise </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    getData(): void {
      fetch('https://jsonplaceholder.typicode.com/posts')
        .then(response => response.json())
        .then(data => console.log(data))
        .catch(error => console.error(error));
    } 
  </code>
</pre>

      <h2> Observable with Multiple Values </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    const myObservable = new Observable(observer => {
      observer.next('Value 1');
      observer.next('Value 2');
      setTimeout(() => {
        observer.next('Value 3 (after delay)');
        observer.complete(); // Ends the stream
      }, 2000);
    });
    myObservable.subscribe(value => console.log(value));
  </code>
</pre>

      <h2> Cancelling an Observable </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  const observable$ = interval(1000); // Emits values every second
  const subscription: Subscription = observable$.subscribe(value => console.log(value));
  setTimeout(() => {
    console.log('Unsubscribing...');
    subscription.unsubscribe(); // Stops emissions
  }, 5000);
</code></pre>

    </div>


    <div class="box shadow p-2 mb-3" id="rxjsoperator">
      <h2> RxJS Operators All Defination</h2>
      <p> <strong> Map </strong> Map operator use for our data transform according to need.
        We get any data we can change by map operator and it return new observable with modify data . </p>
      <p> <strong> Filter </strong> - filter operator emits only those values from the source Observable that pass a
        specified condition (predicate). </p>
      <p> <strong> Forkjoin </strong> - forkJoin is used to run multiple HTTP requests in parallel and get all their
        results once all are completed. </p>
      <p><strong> SwitchMap </strong> - switchMap is an RxJS operator used to switch to a new observable every time the
        source emits a value. If a new value comes in before the previous inner observable completes, switchMap cancels
        the previous one and switches to the latest. </p>
      <p> <strong> ConcatMap </strong> concatMap is an RxJS operator that maps each value to an inner observable, queues
        them, and subscribes to them one after the other — maintaining the order and waiting for each one to complete
        before moving to the next. </p>
      <p><strong> MergeMap </strong> - mergeMap operator is basically a combination of two operators – merge and map.
        mergeMap emitted value to inner observable and will subscribe to all observables and merge. </p>
      <p><strong>DebounceTime</strong> - DebounceTime is an RxJS operator It waits for the user to stop typing for a
        certain time before doing anything.</p>
      <p><strong> pluck </strong> - Pluck is an RxJS operator that lets you pull out a specific property (or nested
        property) from each emitted object. </p>
      <p> <strong> Error Handling </strong> </p>
      <p> <strong> Error Handling Operators: </strong> These operators handle errors in observables. </p>
      <p> <strong> catchError: </strong> Catches errors and returns a fallback observable. </p>
      <p> <strong> retry: </strong>Retries an observable a specified number of times upon error. </p>
      <p> <strong> retryWhen: </strong> Retries an observable based on a condition. </p>

      <h2> Switch Map and Exhaust different between</h2>
      <p> Switch Map - Cancels the previous inner observable and switches to new one </p>
      <p> ExhaustMap - Ignores new inner observables if one is already active </p>
      <p> Switch Map - Auto-complete, type-ahead, real-time search </p>
      <p> ExhaustMap - Login, signup, form submission (one at a time) </p>
      <p> Switch map - Only latest is processed, rest are canceled </p>
      <p> ExhaustMap - Only first is processed, others are ignored </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    Switch Map - 
    this.searchInput.valueChanges.pipe(
  debounceTime(300),
  switchMap(query => this.searchService.search(query))
).subscribe(result => {
  this.results = result;
});

  </code>
</pre>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    exhaustMap -
    this.loginForm.valueChanges.pipe(
  exhaustMap(credentials => this.authService.login(credentials))
).subscribe(response => {
  // only one login request will be processed at a time
});

  </code>
</pre>

      -----------------------------
      <h2> RxJS Operators </h2>
      <h2> Map </h2>
      <p> <strong> rxjs map() transforms each item emitted by an Observable. </strong>
        <br> Map operator use for our data transform according to need.
        We get any data we can change by map operator and it return new observable with modify data . <br>
        example - map(data => transform)
      </p>

      <p> <strong> From </strong> Basically coverts array data (any data iterable) into an observable. meaning it will
        emit each item if the array one by one, in sequence </p>

      <hr>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>

export class MapComponent {

  sub1!: Subscription
  msg1: any

  sub2!: Subscription
  msg2: any

 constructor(){}

 ngOnInit(){

  //Simple Examples 01

  const broadCastingVideo = interval(1000)

  this.sub1 = broadCastingVideo.pipe(
    map(data => 'Video '+ data)
  )
  .subscribe((response: any) => {
    console.log(response);
    this.msg1 = response;
  })

  setTimeout(() => {
    this.sub1.unsubscribe()
  }, 10000)


 //Map Logic Examples 02

 this.sub2 = broadCastingVideo.pipe(
  map(data => 'Video '+ data * 10)
 )
 
 .subscribe((response: any) => {
  this.msg2 = response
 })

 setTimeout(() => {
  this.sub2.unsubscribe()
 }, 10000)


  //Examples 03 For Objects

  const members = from([
    {id: 1, name: 'Anup'},
    {id: 1, name: 'Pankaj'},
    {id: 1, name: 'Tanmay'},
    {id: 1, name: 'Ashish'},
    {id: 1, name: 'Husnain'},
    {id: 1, name: 'Rajesh'},
    ])

    members.pipe(
      map(data => data.name)
    )
    .subscribe((response: any) => {
      console.log('Check--->', response);
    })

 }
    
  
}

HTML ===
{{msg1}}




       -------------
	   --------------

       Nested Object 

       const source = of({ address: { city: 'New York' } }, { address: { city: 'London' } });
    
    const example = source.pipe(
      map(value => value?.address?.city)
    );
    
    example.subscribe(city => console.log(city));

    </code>
  </pre>

      <hr>

      <h2> Filter by Employee data, Maxmimum salary, name length, search </h2>
      <p> <strong> filter operator emits only those values from the source Observable that pass a specified condition
          (predicate). </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>

  filterEmployee: any = []
  searchText: any;

  constructor(){}

  ngOnInit(){
    this.employeeDetails()
  }

  employees = [
  { name: 'Alice', designation: 'Developer', salary: 70000 },
  { name: 'Bob', designation: 'Manager', salary: 90000 },
  { name: 'Charlie', designation: 'Intern', salary: 30000 },
  { name: 'Diana', designation: 'Developer', salary: 80000 }
];

employeeDetails(){
  this.filterEmployee = this.employees.filter(employee => employee.salary < 90000 )
  //this.filterEmployee = this.employees.filter(employee => employee.name.length > 3 )
}
------------------
  // RXJS FILTER OPERATOR 
  // employeeDetails() {
  //   from(this.employees).pipe(
  //     filter(emp => emp.name.length > 3),
  //     toArray() // Collect filtered results into an array
  //   ).subscribe(filtered => {
  //     this.filterEmployee = filtered;
  //     console.log('Filtered Employees:', this.filterEmployee);
  //   });
  // }
------------------ 
  // RxJS Filter Employees with Salary Greater Than X
  // employeeDetails(){
  //   from(this.employees).pipe(
  //     filter(emp => emp.salary > 75000),
  //     toArray()
  //   ).subscribe(res => this.filterEmployee = res);
  // }
------------------
  // // RxJS Filter by Designation (e.g., Only Developers)
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp => emp.designation === 'Developer');
  // }
------------------
  // RxJS Filter by Name Starting with a Specific Letter
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp => emp.name.startsWith('A'));
  // }
------------------
   // RxJS Filter by Multiple Conditions (e.g., Developer with High Salary)
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp =>
  //     emp.designation === 'Developer' && emp.salary > 75000
  //   );
  // }
------------------
    // RxJS Search Employees by Name (Dynamic)
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp =>
  //     emp.name.toLowerCase().includes(this.searchText.toLowerCase())
  // );
  // }
------------------
  //RxJs Highest Score
  // employeeDetails(){
  // this.filterEmployee = [...this.employees]
  // .sort((a, b) => b.salary - a.salary)
  // .slice(0, 3);  // top 3
  // }
  
  ------------------
  
  HTML 
  
  //input type="text" class="form-control" [(ngModel)]="searchText" (input)="employeeDetails()" placeholder="Search"
  
  table class="table table-bordered mt-4">
    thead>
        tr>
            td> Name </td>
            td> Designation </td>
            td> Salary </td>
        /tr>
    /thead>
    tbody>
        tr *ngFor="let employee of filterEmployee">
            td> {{employee.name}} </td>
            td> {{employee.designation}}  </td>
            td> {{employee.salary}}  </td>
        /tr>
    /tbody>
/table>

</code>
</pre>

      <hr>

      <h2> Forkjoin </h2>
      <p><strong> forkJoin is used to run multiple HTTP requests in parallel and get all their results once all are
          completed. </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
ngOnInit() {
    this.loadData();
  }

  loadData() {
    const userDetails = this.http.get('https://jsonplaceholder.typicode.com/users/1');
    const userPosts = this.http.get('https://jsonplaceholder.typicode.com/posts?userId=1');

    forkJoin([userDetails, userPosts]).subscribe(
      ([user, posts]) => {
        console.log('User Details:', user);
        console.log('User Posts:', posts);
      },
      error => {
        console.error('One of the requests failed:', error);
      }
    );
  }
</code>
</pre>


      <hr>

      <h2> SwitchMap </h2>
      <p> switchMap is an RxJS operator used to switch to a new observable every time the source emits a value. If a new
        value comes in before the previous inner observable completes, switchMap cancels the previous one and switches
        to the latest. </p>
      <h2> Basic Examples </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      
import { Component } from '@angular/core';
import { HeaderComponent } from "../../../../header/header.component";
import { HttpSharedService } from '../../../../http-shared.service';
import { FormControl, FormsModule, NgForm, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { debounceTime, distinctUntilChanged, switchMap } from 'rxjs';

@Component({
  selector: 'app-switchmap',
  imports: [HeaderComponent, ReactiveFormsModule, CommonModule, FormsModule],
  templateUrl: './switchmap.component.html',
  styleUrl: './switchmap.component.css'
})
export class SwitchmapComponent {
  
  searchControl = new FormControl();
  products: any[] = [];

  constructor(private http: HttpSharedService) {}

  ngOnInit(): void {
  this.searchControl.valueChanges.pipe(
    debounceTime(300),
    distinctUntilChanged(),
    switchMap((term) => this.http.get(`products/search?q=${term}`))
  ).subscribe((res: any) => {
    this.products = res.products;
  });
  this.getProduct();
}

  getProduct() {
    this.http.get('products').subscribe((response: any) => {
      this.products = response.products;
    });
  }

}


HTML 

input
    type="text"
    [formControl]="searchControl"
    placeholder="Search..."
    class="form-control"
  />

    table class="table table-bordered mt-5" *ngIf="products.length">
        thead>
            tr>
                td> Product title /td>
                td> Product Brand /td>
                td> Product Category /td>
            /tr>
      /thead>
        tbody>
            tr *ngFor="let product of products">
                td> {{product.title}} /td>
                td> {{product.brand}} /td>
                td> {{product.category}} /td>
            /tr>
        /tbody>
    /table>

    </code>
  </pre>

      <h2> Another Example switchMap : Chained API Calls </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code> this.route.params.pipe(
    switchMap(params => this.userService.getUserById(params['id']))
  ).subscribe(user => {
    console.log('User data:', user);
  });
  </code>
</pre>

      <hr>

      <h2> ConcatMap </h2>
      <p> concatMap is an RxJS operator that maps each value to an inner observable, queues them, and subscribes to them
        one after the other — maintaining the order and waiting for each one to complete before moving to the next.</p>

      <p> <strong> mergeMap vs concatMap </strong> </p>
      meregeMap = Subscribes to all inner observables immediately <br>
      cancatMap = Waits for the previous inner observable to complete <br>
      meregeMap = Faster overall <br>
      cancatMap = Slower, but ordered <br>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { from } from 'rxjs';
import { concatMap, delay } from 'rxjs/operators';

from([1, 2, 3]).pipe(
  concatMap(val => {
    console.log('Requesting:', val);
    return of(`Processed ${val}`).pipe(delay(1000));
  })
).subscribe(result => console.log(result));

  </code>
</pre>

      <h2> Real World Example </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    saveUser(userData: any) {
      return this.http.post('/api/saveUser', userData);
    }
    
    notifyUser(userId: string) {
      return this.http.post(`/api/notifyUser/${userId}`, {});
    }
    
    doAll(userData: any) {
      of(userData).pipe(
        concatMap(data => this.saveUser(data)),
        concatMap((savedUser: any) => this.notifyUser(savedUser.id))
      ).subscribe(() => {
        this.router.navigate(['/dashboard']);
      });
    }
    
  </code>
</pre>
      <h2> File upload que </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    uploadFiles(files: File[]) {
      from(files).pipe(
        concatMap(file => this.uploadService.upload(file))
      ).subscribe(response => {
        console.log('Uploaded:', response);
      });
    }    
  </code>
</pre>

      <hr>

      <h2> MergeMap in Rxjs Angular, MergeAll </h2>
      <p> mergeMap operator is basically a combination of two operators – merge and map.
        mergeMap emitted value to inner observable and will subscribe to all observables and merge. </p>

      <h2> Simple Examples </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
export class MergemapComponent {

  getData(data: any){
    return of (data + 'Video Uploaded')
  }

  ngOnInit(){

     //Example 01

    const source = from(['Tech', 'Comedy', 'News']);
    source.pipe(
      map( response => this.getData(response))
    )
    .subscribe((response: any) => {
      console.log(response)
    })

    //.subscribe(response => response.subscribe( response2 => {
      //console.log(response2);
    //}))

     //Example 02 MergeAll

     source.pipe(
      map( response => this.getData(response)),
      mergeAll()
    )
    .subscribe((response: any) => {
      console.log(response)
    })

    //Example 02 Mergemap

     source.pipe(
      mergeMap( response => this.getData(response)),
    )
    .subscribe((response: any) => {
      console.log(response)
    })

  }
}
</code>
</pre>

      <h2> Real-world Example in Angular: Parallel API Calls </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    getUserById(id: number) {
      return this.http.get(`/api/users/${id}`);
    }
    
    fetchAllUsers(ids: number[]) {
      from(ids).pipe(
        mergeMap(id => this.getUserById(id))
      ).subscribe(user => {
        console.log('User:', user);
      });
    }
    
  </code>
</pre>

      <hr>

      <h2> DebounceTime </h2>
      <p> debounceTime(ms) waits for a pause in emissions from the source observable.
        It only emits the latest value after the given time (in ms) has passed without another emission. </p>
      <p> <strong> DebounceTime is an RxJS operator It waits for the user to stop typing for a certain time before doing
          anything. </strong> </p>

      <h2> Basic Examples </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { fromEvent } from 'rxjs';
import { debounceTime, map } from 'rxjs/operators';

const input = document.getElementById('myInput');

fromEvent(input, 'input').pipe(
  map((e: any) => e.target.value),
  debounceTime(500)
).subscribe(value => {
  console.log('User stopped typing:', value);
});

  </code>
</pre>

      <h2> Real-World Angular DebounceTime Example: Search Box </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';
import { debounceTime } from 'rxjs/operators';

@Component({
  selector: 'app-search',
  template: `input [formControl]="searchControl" placeholder="Search...">`
})
export class SearchComponent {
  searchControl = new FormControl();

  ngOnInit() {
    this.searchControl.valueChanges.pipe(
      debounceTime(300)
    ).subscribe(value => {
      console.log('Searching for:', value);
      // Call your API or service here
    });
  }
}

  </code>
</pre>

      <hr>

      <h2> pluck </h2>
      <p> pluck is an RxJS operator that lets you pull out a specific property (or nested property) from each emitted
        object. </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { from } from 'rxjs';
import { pluck } from 'rxjs/operators';

const source$ = from([
  { name: 'Alice' },
  { name: 'Bob' },
  { name: 'Charlie' }
]);

source$.pipe(
  pluck('name')
).subscribe(name => console.log(name));


//output
Alice
Bob
Charlie
  </code>
</pre>

      <h2> Another Example: From DOM Events </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { fromEvent } from 'rxjs';
import { pluck } from 'rxjs/operators';

const input = document.getElementById('myInput');

fromEvent(input, 'input').pipe(
  pluck('target', 'value')
).subscribe(val => {
  console.log('Typed value:', val);
});

  </code>
</pre>

      <h2> ForkJoin operator </h2>

      ForkJoin is an RxJS operator that takes in multiple observables and returns a single observable that emits the
      last emitted value from each of the input observables, once all input observables complete.

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code> 
import { forkJoin, of, timer } from 'rxjs';
import { delay } from 'rxjs/operators';

const obs1 = of('A').pipe(delay(1000)); // emits 'A' after 1s
const obs2 = of('B').pipe(delay(2000)); // emits 'B' after 2s

forkJoin([obs1, obs2]).subscribe({
  next: ([res1, res2]) => console.log('Results:', res1, res2),
  complete: () => console.log('All done.')
});

</code>
</pre>

      <h2> Filter operator </h2>
      filter operator in RxJS is used to emit values from an observable that pass a certain condition (predicate). It
      works like the Array.prototype.filter() method but on an observable stream.

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code> 
import { from } from 'rxjs';
import { filter, map } from 'rxjs/operators';

// Sample employee data
const employees = [
  { id: 1, name: 'Alice', salary: 40000 },
  { id: 2, name: 'Bob', salary: 60000 },
  { id: 3, name: 'Charlie', salary: 55000 },
  { id: 4, name: 'David', salary: 30000 }
];

// Create observable from employee array
from(employees).pipe(
  // Filter employees with salary > 50000
  filter(emp => emp.salary > 50000),
  // Optionally extract only the salary or full employee object
  map(emp => ({ name: emp.name, salary: emp.salary }))
).subscribe({
  next: data => console.log('High salary employee:', data),
  complete: () => console.log('Completed')
});

</code>
</pre>

    </div>


    <div class="box shadow p-2 mb-3" id="rxjsoperatorlive">
      <h2> Map Example </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-users',
  standalone: true,
  imports: [CommonModule],
  template: ``
})
export class UsersComponent {
  users: any[] = [];

  constructor(private http: HttpClient) {
    this.getUsers();
  }

  getUsers() {
    this.http.get<any>('https://yourapi.com/users')
      .pipe(
        map(response => response.users) // Only extract users array
      )
      .subscribe((users) => {
        this.users = users;
        console.log('Users:', this.users);
      });
  }
}

    </code>
  </pre>
      <p></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      // example.service.ts

@Injectable({
  providedIn: 'root'
})
export class ExampleService {
  constructor(private http: HttpClient) {}

  getLiveData() {
    return this.http.get<any>('https://api.example.com/data').pipe(
      map(response => {
        // You can transform the response here
        return response.data.map((item: any) => ({
          id: item.id,
          name: item.name.toUpperCase(),  // for example, make names uppercase
          active: item.status === 'active'
        }));
      })
    );
  }
}

    </code>
  </pre>


      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      // Filter
      // 1. Service: Making API Call
// user.service.ts
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, from } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}

  getUsers(): Observable<any[]> {
    return this.http.get<any[]>('https://api.example.com/users');
  }
}
<hr>

2. Component: Use filter Operator

// user.component.ts
import { Component, OnInit } from '@angular/core';
import { UserService } from './user.service';
import { map } from 'rxjs/operators';

@Component({
  selector: 'app-user',
  template: `
    div *ngFor="let user of activeUsers">
      {{ user.name }}
    /div>
  `
})
export class UserComponent implements OnInit {
  activeUsers: any[] = [];

  constructor(private userService: UserService) {}

  ngOnInit() {
    this.userService.getUsers()
      .pipe(
        map(users => users.filter(user => user.isActive)) // filter the array
      )
      .subscribe(filteredUsers => {
        this.activeUsers = filteredUsers;
      });
  }
}


// 🔁 Example Using filter on Emitted Values:
import { of } from 'rxjs';
import { filter } from 'rxjs/operators';

of(1, 2, 3, 4, 5)
  .pipe(filter(value => value % 2 === 0))
  .subscribe(val => console.log(val)); // Output: 2, 4


    </code>
  </pre>

    </div>

    <div class="box shadow p-2 mb-3" id="error">
      <h2> ERROR HANDLING </h2>

      <p> Error handling in Angular means managing what happens when an HTTP request or some code fails — for example,
        if a server is down, the user enters wrong credentials, or the internet connection is lost. </p>

      <p><strong> How Error Handling Works </strong></p>
      <div>
        <strong> Try to Make a Request </strong> <br>
        Angular sends a request to the server (like saving data or logging in). <br>
        <strong> Response Comes Back </strong> <br>
        If the response is successful, Angular continues normally.<br>
        But if something goes wrong (like a 404 or 500 error), it triggers the error block.<br>
        <br>
        <strong> Catch the Error </strong> <br>
        Angular lets you "catch" the error and decide what to do — such as:<br>
        Show a friendly error message to the user<br>
        Log the error for debugging<br>
        Retry the request<br>
        Redirect to another page
        <br>
        <br>
      </div>

      <p> <strong> Manually Globally error handle </strong> </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { ErrorHandler, inject } from "@angular/core";

export class MyErrorHandler implements ErrorHandler {
  error: any;
    // private error = inject(ErrorService)
  handleError(error: any) {
    console.log("Error occure : ", error)
    if(error.status == 422){
        let message = 'required fileds: '
        let params_required = error.error.detail.map((entity: any) => `${entity.loc[1]}`)
        console.log(message + params_required)
        this.error.setError(message + params_required)
    }
    if(error.status == 404){
        console.log("Please check your api url")
        this.error.setError("Please check your api url")
    }
    if(error.status == 500){
        console.log("Please check your network")
        this.error.setError("Please check your network")
    }
  }
}

================

In main.ts 
 providers: [
    ...appConfig.providers,
    importProvidersFrom(BrowserAnimationsModule),
    provideToastr(),
    provideRouter(routes),
    {provide: ErrorHandler, useClass: MyErrorHandler}
  ]

</code>
</pre>

      <p> <strong> Server Error Status </strong> </p>
      500 - Internal Server Error,
      502 - Bad Gateway,
      503 - Service Unavailable,
      400 - Bad Request ,
      401 - Unauthorized ,
      403 - Forbidden,
      404 - Not Found,
      200 - Ok status,
      201 - Created – Resource was created,
      204 - No Content – Success but no response body
      <br>

      <p> <strong> Normal Error Handling with API call </strong> </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
this.http.get('/api/data').subscribe({
  next: res => console.log(res),
  error: (err: HttpErrorResponse) => {
    if (err.status === 0) {
      console.error('Network error or CORS issue');
    } else if (err.status === 500) {
      console.error('Server error!');
    } else if (err.status === 404) {
      console.error('Not found');
    }
  }
});

</code>
</pre>
      <br>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';

this.http.get('https://api.example.com/data')
  .pipe(
    catchError(error => {
      console.error('Request failed:', error);
      return throwError(() => error);
    })
  )
  .subscribe();
  
...............

1. Create a Global Error Interceptor
intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        // Global error logic here
        console.error('HTTP Error:', error);

        if (error.status === 0) {
          this.toastr.error('Network error. Please check your connection.');
        } else if (error.status === 401) {
          this.toastr.error('Unauthorized. Please login.');
        } else if (error.error?.message) {
          this.toastr.error(error.error.message); // From server
        } else {
          this.toastr.error('Something went wrong.');
        }

        return throwError(() => error); // Rethrow the error
      })
    );
	
...............


createUser() {
  this.http.post('users/add', this.setPayLoad(this.user_form.value)).subscribe({
    next: (response: any) => {
      this.getUser();
      this.resetForm();
    },
    error: (err) => {
      console.error('Create user error:', err);
      // Handle error message - show to user
      this.errorMsg = err?.error?.message || 'Something went wrong while creating user.';
    }
  });
}


</code>
</pre>
    </div>


    <div class="box shadow p-2 mb-3" id="rxjssubject">
      <h2> SUBJECT </h2>
      <p> Subjects are a special type of Observable it allows values multicasted to many observers.
        <br> it is Observable and observer also on same time. I can subscribe and emmit both in subject
      </p>
      <p> <strong> Multicasted </strong> - Which we will start subscribe after then we get data. we can not get
        subscribe before data. just like Live stream. </p>

      <h2> Behavior SUBJECT </h2>
      <p> BehaviorSubject is a special type of Subject. A Behavior Subject holds one value. When it is subscribed it
        emits the value immediately. </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      import { BehaviorSubject } from 'rxjs';
      behaviorSubject = new BehaviorSubject<number>(0); // initial value is 0
      ngOnInit() {
      behaviorSubject.subscribe(value => console.log('Subscriber 1:', value)); // Subscriber 1: 0
      behaviorSubject.next(1); // Subscriber 1: 1
      behaviorSubject.subscribe(value => console.log('Subscriber 2:', value)); // Subscriber 2: 1
      behaviorSubject.next(2); 
      // Subscriber 1: 2
      // Subscriber 2: 2
      }
    </code>
  </pre>


      <h2 class="mt-4"> Subject and Behavior Subject </h2>

      1. Subject
      <ul>
        <li> No Initial Value </li>
        <li> Does not emit the last value to new subscribers. </li>
        <li> Starts emitting only after next() is called. </li>
        <li> Think of it as a broadcast system — it only pushes what it gets at that moment. </li>
      </ul>
      2. BehaviorSubject
      <ul>
        <li> Requires an initial value </li>
        <li> Always emits the latest value to new subscribers. </li>
        <li> Useful for storing and broadcasting state. </li>
      </ul>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    1. Subject Example
    const sub = new Subject<number>();
    sub.subscribe(val => console.log('Sub1:', val));
    sub.next(1); // Sub1: 1
    sub.next(2); // Sub1: 2

    sub.subscribe(val => console.log('Sub2:', val)); 
    sub.next(3); // Sub1: 3, Sub2: 3 (but Sub2 missed 1 & 2)

  </code>
</pre>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    2. BehaviorSubject Example
    const bSub = new BehaviorSubject number>(0); // initial value is 0
    bSub.subscribe(val => console.log('BSub1:', val)); // BSub1: 0
    bSub.next(1); // BSub1: 1
    bSub.next(2); // BSub1: 2

    bSub.subscribe(val => console.log('BSub2:', val)); // BSub2: 2 (latest value)
  </code>
</pre>

      <h2 class="mt-4"> Replay Subject </h2>
      <p> Replay subject is a variant of subject. It emits old value adn emit those value to new subscribe. </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { ReplaySubject } from 'rxjs';
    replaySubject = new ReplaySubject(2); // buffer size = 2
    ngOnInit() {
      this.replaySubject.next(1);
      this.replaySubject.next(2);
      this.replaySubject.next(3);
      this.replaySubject.subscribe(value => console.log('Subscriber:', value));
    }
  </code>
</pre>


      <h2> Async Subject </h2>
      <p> Emits last value after completion </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      asyncSubject = new AsyncSubject()

      ngOnInit() {
     
        this.asyncSubject.next(1);
        this.asyncSubject.next(2);
        this.asyncSubject.next(3);

        this.asyncSubject.subscribe(value => console.log('Subscriber 1:', value));

        this.asyncSubject.subscribe(value => console.log('Subscriber 2:', value));

        this.asyncSubject.next(4);
        this.asyncSubject.complete(); // Now it emits 4 to both
      }

    </code>
  </pre>

      <p> <strong>BehaviorSubject is a type of RxJS Subject </strong> </p>
      <ul>
        <li> Always stores the latest value it has emitted. </li>
        <li> When a new subscriber subscribes to it, it immediately receives the current value (even if it subscribed
          after the value was emitted). </li>
        <li> BehaviorSubject is commonly used in services to manage state or shared data - Keeping track of the current
          user.Sharing filter criteria between components. </li>

      </ul>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<strong>
import { BehaviorSubject } from 'rxjs';

export class DataService {
  private countSubject = new BehaviorSubject<number>(0); // initial value is 0
  count$ = this.countSubject.asObservable(); // expose as observable to subscribers

  updateCount(newCount: number) {
    this.countSubject.next(newCount); // emit new value
  }
}

</strong>
</pre>


      <h2> RxJS SUBJECT //Create a Shared Service </h2>
      <p> Subject in RxJS is a special type of Observable that allows values to be multicasted to multiple subscribers.
      </p>
      <p> <strong> Create a Shared Service </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    private dataSubject = new Subject<string>(); // Create Subject
      data$ = this.dataSubject.asObservable(); // Expose as Observable
      sendData(message: string) {
        this.dataSubject.next(message); // Send data
      }
  
     <strong> Send Data from Component 1 (Sender)  </strong> 
      
      button (click)="sendMessage()">Send Message button
  
      constructor(private dataService: DataService) {}
  
      sendMessage() {
      this.dataService.sendData("Hello from Sender!");
      }
  
      <strong> Receive Data in Component 2 (Receiver) </strong> 
  
      <p>Received: {{ receivedMessage }}</p>
  
    receivedMessage: string = "";
  
    constructor(private dataService: DataService) {}
  
    ngOnInit() {
      this.dataService.data$.subscribe(message => {
        this.receivedMessage = message; // Receive data
      });
    }
  
  </code>
</pre>
    </div>



    <div class="box shadow p-2 mb-3" id="ngrx">
      <h2> NgRx (Redux for Angular) </h2>
      <p> NgRx is a state management library for Angular applications that implements the Redux pattern using
          RxJS. <br> Uses Actions, Reducers, Store, Effects, and Selectors. </p>


      <strong> TS Actions examples - </strong>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        export const addItem = createAction('[Cart] Add Item', props<{ item: string }>());
        export const removeItem = createAction('[Cart] Remove Item', props<{ item: string }>());
      </code>
    </pre>
      <h2> STATE OF STRUCTURE </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
          export const initialState = { count: 0 };
          export const counterReducer = createReducer(
          initialState,
          on(increment, (state) => ({ count: state.count + 1 })),
          on(decrement, (state) => ({ count: state.count - 1 }))
        );
      </code>
    </pre>
      <h2> NGXS (Simpler alternative to NgRx) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        @State<number>({ name: 'counter', defaults: 0 })
          export class CounterState {
            @Action(Increment)
            increment(ctx: StateContext<number>) {
              const state = ctx.getState();
              ctx.setState(state + 1);
            }
          }
      </code>
    </pre>
      <h2> SignalStore </h2>
      <p> Introduced in Angular 17 as a lightweight, reactive state management solution. Uses signals instead of
        Observables. </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        count = signal(0);
        increment() {
          this.count.set(this.count() + 1);
        }
      </code>
    </pre>
      <h2 class="mt-2"> ngRx Store? </h2>
      <p> ngRx Store is a state management library for Angular applications. It is based on Redux and helps manage
        application state and using actions, reducers, and selectors. </p>

        <ol>
          <li> ngRx Store helps manage global state in Angular apps. </li>
          <li> It follows Redux principles with actions, reducers, and selectors. </li>
          <li> Effects handle async operations like API calls. </li>
          <li> Improves scalability, performance, and debugging. </li>
        </ol>

        <p class="p-0 m-0"> <strong> Redux pattern </strong> is a state management approach where state, Actions, Reducers </p>
        <p> <strong> Pure function </strong> is a function which is Always returns the same output for the same input <br> 
          ( function add(a: number, b: number) {
  return a + b;
} )</p>

      <ol>
        <li> <strong> Actions – </strong>It is plain objects, and Define what happens in our application (e.g., "Add Product", "Delete User"). </li>
        <li> <strong> Reducers – </strong> Handle state changes based on actions., <br> Pure functions that take the current state and an action, and return a new state without mutating the old one.  </li>
        <li> <strong> State – </strong> The single source of truth for the app. </li>
        <li> <strong> Selectors – </strong> Retrieve specific data from the store. </li>
        <li> <strong> Effects – </strong> Services and Handle asynchronous operations like API calls. </li>
      </ol>
<div class="mb-5"> 
<h2> Store </h2>
<p> NgRx, the Store is a centralized container that holds the entire application state, it a single source of truth that components can read from and write to through actions. </p>
<ul>
  <li> Store Flow in NgRx </li>
  <li> Component dispatches an Action → </li>
  <li> Reducer updates the State → </li>
  <li> Store holds the new state </li>
  <li> Updated Store notifies components using Selectors. </li>
</ul>


<h2> Why use NgRx instead of Service-based state management? </h2>
<ul>
  <li> Predictable state updates </li>
  <li> Centralized single source of truth </li>
  <li> Works well for large, complex apps </li>
</ul>
</div>


<pre>
  <code>
// Selector Example
export const selectUsers = createSelector(
  selectUserState,
  state => state.users
);
  </code>
</pre>

<hr>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        <strong>
          Installation <br>
          ng add @ngrx/store <br>
          ng add @ngrx/effects <br>
        </strong>

 <strong> * Actions </strong>       
import { createAction } from '@ngrx/store';
export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');
export const reset = createAction('[Counter] Reset');

<strong> * Create Reducer </strong>
import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';
export const initialState = 0;
export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => state + 1),
  on(decrement, (state) => state - 1),
  on(reset, () => 0)
);

<strong> * Register Store </strong>

  import { StoreModule } from '@ngrx/store';
  import { counterReducer } from './counter.reducer';
  imports: [
  StoreModule.forRoot({ count: counterReducer }) // Register reducer
  ],

  <strong> * Store in Components </strong>
import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

@Component({
  selector: 'app-counter',
  template: `
    <p><strong> Counter: {{ count$ | async }} </strong> </p>
    button (click)="increment()">Increment</button>
    button (click)="decrement()">Decrement</button>
    button (click)="reset()">Reset</button>
  `
})
export class CounterComponent {
  count$ = this.store.select('count'); // Select state
  constructor(private store: Store<{ count: number }>) {}
  increment() { this.store.dispatch(increment()); }
  decrement() { this.store.dispatch(decrement()); }
  reset() { this.store.dispatch(reset()); }
}

      </code>
    </pre>

      <h2>Transition Between Two States in Angular</h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

@NgModule({
  imports: [
    BrowserAnimationsModule
  ]
})
export class AppModule {}
</code>
</pre>
      <h2> Create Animation in the Component </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { Component } from '@angular/core';
import { trigger, state, style, animate, transition } from '@angular/animations';

@Component({
  selector: 'app-demo',
  template: `
    div [@openClose]="isOpen ? 'open' : 'closed'" class="box">
      Toggle Me!
    div>
    button (click)="toggle()">Toggle button>
  `,
  animations: [
    trigger('openClose', [
      state('open', style({
        height: '200px',
        backgroundColor: 'lightgreen'
      })),
      state('closed', style({
        height: '100px',
        backgroundColor: 'lightcoral'
      })),
      transition('open <=> closed', [
        animate('0.5s ease-in-out')
      ])
    ])
  ],
  styles: [`.box { width: 200px; margin: 20px auto; text-align: center; }`]
})
export class DemoComponent {
  isOpen = true;

  toggle() {
    this.isOpen = !this.isOpen;
  }
}

</code>
</pre>


    </div>


    <div class="box shadow p-2 mb-3" id="spa">
      <h2> SPA </h2>
      <p> Single Page Application (SPA) is a web application that dynamically updates content without reloading the
        entire page.
        Faster Page Loads , Smooth User Experience, Efficient Data Fetching
        Examples - GMAIL, FACEBOOK, NETFLIX, TWITTER </p>
    </div>

    <div class="box shadow p-2 mb-3" id="shared">
      <h2> CHALLENGING WORK / SHARED SERVICES </h2>
      <p> I was working on an Angular project where we used a reactive form with a select box for gender (Male and
        Female) multiple times across different components. Later, we realized that instead of repeating the same logic,
        we could create a reusable service for gender options, making the implementation more efficient and
        maintainable. </p>
      <h2> Shared Servcies </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    genders = [
    {"id": "male", "name": "Male"},
    {"id": "female", "name": "Female"},
    {"id": "other", "name": "Other"}
  ]
  select>
    option *ngFor="let gender of genders" value="{{gender.id}}"> {{gender.name}} </option>
  select>
  </code>
</pre>
    </div>


    <div class="box shadow p-2 mb-3" id="newfeatures">
      <p><strong> Standalone components in Angular are components that can operate independently without requiring a
          module. <br> This feature, introduced in Angular 14 and becoming the default in Angular 17. <br>
          This feature simplifies component development and reuse, making it easier to build and maintain large-scale
          applications. </strong></p>

<p> <strong>  Use one standalone component inside another component </strong></p>
<ol>
<li> Import the standalone component into the component where you want to use it. </li>
<li> Add that standalone component to the imports array of the component’s metadata (inside @Component). </li>
<li> After that, you can use its selector tag directly in the template of the importing component. </li>
<li> This works because standalone components are self-contained — they don’t need to be declared in an NgModule, </li>
</ol>


      <h2> Standalone components Advantages </h2>

      <ol>
        <li> No Need for NgModules <br>
          You can directly define and use a component without declaring it inside a module. </li>
        <li> Simpler and Faster Setup <br>
          Less boilerplate code — cleaner and more readable. </li>
        <li> Improved Code Reusability <br>
          Standalone components are easier to reuse across different modules or lazy-loaded routes. </li>
        <li> Better Tree-Shaking & Performance <br>
          Smaller bundle size because Angular includes only what is actually used. </li>
        <li> Easier Lazy Loading <br>
          Great for routing — components can be directly lazy-loaded without a wrapper module. </li>
        <li> Aligns with Modern Frontend Practices <br>
          Makes Angular more similar to other frameworks like React or Vue (component-first design). </li>
        <li> standalone: true </li>
        <li> Use in Rounting <br>
          { path: 'home', component: HomeComponent } // if HomeComponent is standalone
        </li>
      </ol>

      <h2> NEW FEATURES IN ANGULAR </h2>
      <p> <strong> => New Features and Updates in Angular 15 </strong></p>
      <ol>
        <li> Standalone API – No Need for NgModules </li>
        <li> Directive Composition API – Reuse Logic Easily
          * Allows directives to be combined into a single component easily. </li>
        <li> Improved Performance with Better Tree Shaking </li>
        <li> Enhanced Router Features
          * Lazy loading components directly (without NgModule).
          <pre style="white-space: pre-wrap; word-wrap: break-word;">
        <code>
          const routes: Routes = [
          { path: 'dashboard', loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent) }];
        </code>
      </pre>
        </li>
        <li> Stable Image Directive (NgOptimizedImage) - NgOptimizedImage improves image performance. </li>
        <li> Better Material UI Components </li>
      </ol>

      <p> <strong> => Angular 17, released in November 2023, brought a major set of improvements to performance
        </strong></p>
      <ol>
        <li> New Declarative Control Flow Syntax - @-if, @-for, @-switch </li>
        <li> Deferrable Views with @-defer </li>
        <li> Built-in Control Flow Enabled by Default </li>
        <li> Standalone component the Default, removing the need for NgModules </li>
        <li> Performance Improvements </li>
      </ol>

      <p> <strong> => New Features and Updates in Angular 19 <br> ​Angular 19, released in November 2024 </strong></p>
      <ol>
        <li> Standalone Components by Default </li>
        <li> Incremental Hydration (Developer Preview) <br>
          * This feature enhances server-side rendering by allowing developers to incrementally hydrate parts of their
          application. Using the @ defer syntax </li>
        <li> Route-Level Render Mode (Developer Preview) <br>
          * Angular 19 introduces the ability to control the rendering strategy of individual routes </li>
        <li> Enhanced Reactivity with linkedSignal and resource() </li>
        <li> Angular Material: New Time Picker Component </li>
        <li> Two-Dimensional Drag & Drop in CDK </li>
      </ol>

      <p> <strong> Angular 18 – New Features & Highlights </strong></p>
      <ol>
        <li> Stable Signals API </li>
        <li> Signal Inputs in Components </li>
        <li> Control Flow Syntax (Stable) </li>
        <li> Zoneless Change Detection (Experimental) </li>
        <li> Angular CLI & Dev Tools Improvements
          <ol>
            <li> Smaller bundle sizes by default </li>
            <li> Improved dev-server performance </li>
            <li> Better diagnostics and error messages </li>
          </ol>
        </li>
      </ol>

      <p> <strong> Stable Signals API </strong></p>
      <ul>
        <li> Angular Signals (introduced experimentally in v16) is now fully stable. </li>
        <li> A reactive state management system that replaces RxJS for many use cases. </li>
      </ul>
      <pre>
    <code>
import { signal } from '@angular/core';
const counter = signal(0);
function increment() {
  counter.set(counter() + 1);
}

//Signals automatically trigger UI updates when changed.
    </code>
  </pre>
      <h2 class="mt-4"> <strong> Signal Inputs in Components </strong></h2>
      <pre>
    <code>
      @Component({
  selector: 'child',
  standalone: true,
  template: '{{ name() }}'
})
export class ChildComponent {
  @Input() name = signal('');
}


    </code>
  </pre>
      <p> <strong> Control Flow Syntax (Stable) </strong></p>
      <pre>
    <code>
     
      @for (user of users; track user.id) {
 {{ user.name }}
} @empty {
  No users found
}

    </code>
  </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="state">

      <h2> State Management in Angular </h2>
      <p> State management in Angular is the process of handling application data efficiently across components,
        services, and routes. Local State, Component State, Service State (App-Level State) </p>

      <h2> How to handle state management </h2>
      <p> <strong> 1. @Input() / @Output() — Parent-child communication </strong>, </p>
      <p> <strong> 2. Service with BehaviorSubject </strong> <br> Multiple components need to read and update shared
        data <br>
        You want a simple reactive way to subscribe to changes </p>
      <p> Intermediate: Services + Local Storage </p>
      <p> Advanced: NgRx (Redux for Angular) </p>

      <h2> <strong> NgRx One-Page Revision Sheet </strong></h2>

      <p>
        🏪 <strong> 1. STORE </strong><br>
        Definition: <br>
        Global storage for all app data (state).<br>
        Easy Line:<br>
        The store is like a central database where all Angular components share and get data.
      </p>


      <p>
        🏪 <strong> 1. ACTIONS </strong><br>
        Definition: <br>
        Objects that tell what event just happened in the app. <br>
        Easy Line:<br>
        Actions are commands like “ADD_USER” or “DELETE_TODO” that tell the store something needs to change. <br>
        Examples <br>
        ts - { type: '[Todo] Add Task', task: 'Learn NgRx' }
      </p>

      <p>
        🏪 <strong> 1. EFFECTS </strong><br>
        Definition: <br>
        Used to perform external work (like API calls) after an action. <br>
        Easy Line:<br>
        When an action needs to fetch data from server, effects do that job and send back results.
      </p>

      <p>
        🏪 <strong> 1. REDUCERS </strong><br>
        Definition: <br>
        Pure functions that receive an action and return the new state. <br>
        Easy Line:<br>
        Reducers decide how the state should change when an action happens. <br>
        Important Rule: <br>
        Reducers never do API calls, they just return new state.
      </p>

      <p>
        🏪 <strong> 1. SELECTORS </strong><br>
        Definition: <br>
        Functions to get specific parts of the state from the store.
        <br>
        Easy Line:<br>
        Selectors help you easily pick data like user name, cart count, etc., from the global store.
      </p>


      <h2> What is state management? </h2>
      <p> State refers to the data or UI condition of your application at any given point in time. </p>
      <p> <strong> State Management </strong> is the process of: </p>
      <ul>
        <li> Keeping track of the application’s state, </li>
        <li> Updating it based on user interaction or API calls, </li>
        <li> Ensuring that components reflect the updated state. </li>
      </ul>
      <h2> 2. Local Component State vs Global State </h2>
      <ul>
        <li> <strong> Local State </strong></li>
        <li> Stored within a single component using @Input(), @Output(), or local variables </li>
        <li> Easy to manage for small apps </li>
        <li> No reusability </li>
      </ul>

      <ul>
        <li> <strong> Global State </strong></li>
        <li> Shared across multiple components via services or libraries like NgRx </li>
        <li> Best for large apps with shared data like user info, cart, auth </li>
        <li> Reusable and consistent across the app </li>
      </ul>

      <p> <strong> Example: </strong></p>
      <ul>
        <li> Local: Form input field </li>
        <li> Global: Logged-in user info used in header, sidebar, and profile page </li>
      </ul>

      <p> <strong> 3. Why is State Management Needed in Angular Applications? </strong></p>
      <ul>
        <li> <strong> As applications grow: </strong> </li>
        <li> More components start sharing and modifying the same data </li>
        <li> Manual data flow becomes hard to manage and leads to bugs </li>
        <li> You need centralized control and predictable updates </li>
      </ul>

      <ul>
        <li> <strong> State management (like NgRx) helps by: </strong></li>
        <li> Centralizing data in a single place (store) </li>
        <li> Using actions to update it predictably </li>
        <li> Making state traceable (via Redux DevTools) </li>
        <li> Improving maintainability and scalability </li>
      </ul>

      <p> <strong> NgRx is based on the Redux pattern, which has 3 main principles: </strong></p>
      <ul>
        <li> <strong> Actions </strong> Events that describe what happened (e.g. loadUsers, addToCart) </li>
        <li> <strong> Reducers </strong> Pure functions that take state + action and return new state </li>
        <li> <strong> Store </strong> A single object that holds the state of your application </li>
      </ul>

      <p> <strong> Flow </strong></p>
      <ol>
        <li> Component dispatches an Action </li>
        <li> Reducer handles it and returns new state </li>
        <li> Store updates and components subscribe to it </li>
      </ol>

      <table>
        <tr>
          <td>
            <strong> Component </strong> <br>
            dispatch(action)
          </td>
        </tr>
        <tr>
          <td>
            <strong> Action </strong> <br>
            Example: loadUsers
          </td>
        </tr>
        <tr>
          <td>
            <strong> Effect </strong> <br>
            (optional async logic like API call)
          </td>
        </tr>
        <tr>
          <td>
            <strong> Reducer </strong> <br>
            Handles the action, updates the state
          </td>
        </tr>
        <tr>
          <td>
            <strong> Store </strong> <br>
            Central state container
          </td>
        </tr>
        <tr>
          <td>
            <strong> Selector </strong> <br>
            Used to read state in components
          </td>
        </tr>
        <tr>
          <td>
            <strong>Component </strong> <br>
            (subscribed to state changes)
          </td>
        </tr>
      </table>

      <p class="mt-4"> <strong> Q: Can you explain the NgRx flow with an example? </strong></p>
      <p> <strong> User list feature. </strong> When the component initializes, it dispatches an action like
        loadUsers(). This triggers an NgRx effect, which calls the user API using HttpClient. On success, it dispatches
        loadUsersSuccess({ users }). The reducer listens to this action and updates the store with the fetched user
        list. The component then uses a selector like selectAllUsers to access and display this data. </p>

      <p> <strong> Visual Example: Shopping Cart Feature </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    📦 Actions:
    addItem({ product })
    removeItem({ productId })
    clearCart()

    🧠 Reducer:
    on(addItem, (state, { product }) => ({
      ...state,
      items: [...state.items, product]
    }))

    🏪 Store (State):
    {
      cart: {
        items: [/* array of products */],
        total: 3
      }
    }

    🔍 Selector:
    export const selectCartItems = createSelector(
      selectCartState,
      (cart) => cart.items
    );

    💡 Usage in Component:

    this.store.select(selectCartItems).subscribe(items => {
    this.productsInCart = items;
  });

  </code>
</pre>


      <h2 class="mt-5"> <strong> Mini Project — "NgRx To-Do List App" </strong> </h2>
      <p> <strong> Manage a list of tasks using NgRx Store, Actions, Reducers, Selectors, and Effects </strong></p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
1. Action (todo.actions.ts)

import { createAction, props } from '@ngrx/store';
import { Todo } from '../models/todo.model';

export const loadTodos = createAction('[Todo] Load Todos');
export const loadTodosSuccess = createAction('[Todo] Load Todos Success', props<{ todos: Todo[] }>());
export const addTodo = createAction('[Todo] Add Todo', props<{ todo: Todo }>());
export const deleteTodo = createAction('[Todo] Delete Todo', props<{ id: number }>());

=========

 2. Reducer (todo.reducer.ts)

import { createReducer, on } from '@ngrx/store';
import { addTodo, deleteTodo, loadTodosSuccess } from '../actions/todo.actions';
import { Todo } from '../models/todo.model';

export const initialState: Todo[] = [];

export const todoReducer = createReducer(
  initialState,
  on(loadTodosSuccess, (_, { todos }) => todos),
  on(addTodo, (state, { todo }) => [...state, todo]),
  on(deleteTodo, (state, { id }) => state.filter(t => t.id !== id))
);

=====

3. Selector (todo.selectors.ts) 

import { createFeatureSelector, createSelector } from '@ngrx/store';
import { Todo } from '../models/todo.model';

export const selectTodos = createFeatureSelector<Todo[]>('todos');

=========

4. Effect (todo.effects.ts) — for fake API

import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { loadTodos, loadTodosSuccess } from '../actions/todo.actions';
import { of } from 'rxjs';
import { delay, map, switchMap } from 'rxjs/operators';

@Injectable()
export class TodoEffects {
  loadTodos$ = createEffect(() => this.actions$.pipe(
    ofType(loadTodos),
    switchMap(() =>
      of([
        { id: 1, title: 'Buy milk' },
        { id: 2, title: 'Learn NgRx' }
      ]).pipe(delay(1000)) // simulate API
    ),
    map(todos => loadTodosSuccess({ todos }))
  ));

  constructor(private actions$: Actions) {}
}

  </code>
</pre>


      <p class="mt-4"> Q1: What is the purpose of the Store in NgRx? </p>
      <p> ✅ A: The store holds the entire state of the application and provides a way to dispatch actions and subscribe
        to state updates.</p>

      <p class="mt-4"> Q2: What is an Action? </p>
      <p> ✅ A: Actions are events that describe something that happened, like addTodo or loadUsers.</p>

      <p class="mt-4"> Q3: How do Effects help in NgRx?</p>
      <p> ✅ A: Effects listen for actions and handle side effects like HTTP calls. They don't update the state directly,
        but dispatch success/failure actions that the reducer handles.</p>

      <p class="mt-4"> Q4: Why should reducers be pure functions? </p>
      <p> ✅ A: So they are predictable, testable, and only depend on their inputs—no API calls or randomness. </p>

      <p class="mt-4"> Q5: How would you structure state for a large app (e.g., Auth + Products + Cart)?</p>
      <p> ✅ A: Use feature modules with their own slice of state. Register them using StoreModule.forFeature(...) and
        organize selectors/actions/reducers accordingly. </p>

      <p class="mt-4"> Q6: What are meta-reducers? </p>
      <p> ✅ A: Functions that wrap other reducers to add common logic like logging, hydration, or error handling. </p>

    </div>


    <div class="box shadow p-2 mb-3" id="signals">
      <h2> <strong> SIGNALS </strong> </h2>

      <p><strong> Signal introduced? </strong></p>
      <ul>
        <li> Angular 16 (Released in May 2023) – Signals were introduced as a developer preview. </li>
        <li> Angular 17 & 18 – Signals became more stable and integrated in the framework. </li>
        <li> Angular 18+ – Angular continues to enhance signals (like with @model, if, etc.) </li>
      </ul>

      <p><strong> Signal Defination </strong></p>
      <p> Signal is reactive value in angular. automatically active UI updates when it changes. </p>

      <p class="mt-4"> <strong> Angular (before Signals) </strong></p>
      <p> Normally in Angular, when a value changes, Angular uses Zone.js and change detection to update the DOM: </p>
      Example - title = 'Angular';
      <ul>
        <li> If you update it like this.title = 'New Title'; </li>
        <li> Angular checks the whole component tree to see what bindings changed </li>
        <li> Then it updates the DOM </li>
      </ul>

      <p> <strong> signal() — UI Updates Automatically </strong></p>
      <p>
        @Component({ <br>
        selector: 'app-demo',<br>
        template: `
        h2>{{ title() }} /h2><br>
        button (click)="changeTitle()">Change /button><br>
        `<br>
        })
        <br> export class DemoComponent {<br>
        title = signal('Hello Angular');<br>

        changeTitle() {<br>
        this.title.set('Angular Signals');<br>
        }<br>
        }
      </p>
      <p> What happens here </p>
      <ul>
        <li> title() is bound to the template </li>
        <li> When you call this.title.set(...): </li>
        <li> The signal notifies Angular </li>
        <li> Only the DOM part using title() is re-rendered </li>
        <li>No need for Zone.js or change detection manually </li>
      </ul>

      <p class="mt-4"> <strong> Why should I use Signals? </strong></p>
      <p> Because Signal Easier to understand than observables and RxJS and Signals automatically track dependencies
        <br>
        Signal works Fast change detection, For signal No need to subscribe/unsubscribe manually like in observables
      </p>

      <p><strong> Explanation </strong></p>
      <ul>
        <li> <strong> signal(0) </strong> – creates a signal with initial value 0. </li>
        <li> <strong> count() </strong> – used like a function to read the value. </li>
        <li> <strong> count.set() </strong> – used to update the value. </li>
        <li> UI will auto-update when signal changes. </li>
      </ul>

      <p> <strong>Writable vs Computed Signals? </strong></p>
      <ul>
        <li> Writable Signal - A signal you can directly .set() or .update(), create - signal()</li>
        <li> Computed Signal - A read-only signal based on other signals, computed() </li>
      </ul>

      <p><strong> Computed & Effects </strong></p>
      <ul>
        <li> <strong> computed() </strong> Create derived signals like computed properties. </li>
        <li> <strong> effect() </strong> Run side effects when signal value changes. </li>
      </ul>

      <p class="mt-4"> <strong> What problem do Signals solve in Angular? </strong></p>
      <ul>
        <li> <strong> Angular relies on Zone.js to patch async operations and check the entire component tree after any
            event (e.g., button click, HTTP call). </strong> <br> Signals remove the need for Zone.js <br> Only the
          parts of the UI that depend on a signal re-render </li>
        <li>
          <strong> Problem </strong> : Angular lacked a native reactive state management like Vue (ref, computed) or
          React (useState, useEffect). Developers had to use: @Input() / @Output(), Services with BehaviorSubject <br>
          <strong> help </strong> : Built-in reactivity via signal(), computed(), effect(), No need for external
          libraries or RxJS unless needed
        </li>
        <li> Complex derived state <br> computed() makes it declarative & clean </li>
      </ul>

      <p class="mt-4"> <strong> Can Signals be used in Services or just in Components? </strong> </p>
      <p> Yes! Signals can absolutely be used in Angular Services, not just in components — and in fact, using Signals
        in services is one of the best ways to manage shared state across your application. </p>


      <p> An <strong> interface </strong> is a TypeScript feature used to define the shape of an object. </p>

      <p class="m-0 p-0"> <strong> Angular 18 Signal with @signal Decorator </strong></p>
      <p> Instead of count = signal(0), you write @signal count = 0. </p>



<!-- 1. Signals are reactive primitives introduced in Angular for fine-grained reactivity.
2. They hold a value and notify dependents when that value changes — like observables but simpler.
3. Change detection is automatically triggered when a signal's value is updated.
4. This removes the need for manual `ChangeDetectorRef` or `@Input` tracking in many cases.
5. Signals work well with `OnPush`, providing predictable and efficient updates.
6. They're a key part of Angular's move toward a more reactive, zoneless future. -->

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<h2>signal Basic Scenario Example – Counter </h2>
<code>
<h2>Counter: {{ count() }}</h2>
button (click)="increment()">Increment</button>
button (click)="decrement()">Decrement</button>
TS - 
count: Signal<number> = signal(0); // define signal 
increment() { this.count.set(this.count() + 1); } // update Signal 
decrement() { this.count.set(this.count() - 1); }
</code>
</pre>

      <h2 class="mt-4"> How to use Signals with Angular Forms? ( computed() Example ) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
** computed() Example 

Form.ts 

import { Component, signal, computed } from '@angular/core';
import { HeaderComponent } from '../header/header.component';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-product-filter',
  imports: [HeaderComponent, CommonModule],
  templateUrl: './product-filter.component.html',
  styleUrl: './product-filter.component.css'
})
export class ProductFilterComponent {

  firstName = signal('');
  lastName = signal('');
  fullName = computed(()=> this.firstName() + this.lastName())

}

HTML FILE 

div class="mt-5">
div class="flex"> 
input type="text" class="form-control" #firstNameField [value]="firstName()" (input)="firstName.set(firstNameField.value)" placeholder="First Name">
input type="text" class="form-control" #lastNameField [value]="lastName()" (input)="lastName.set(lastNameField.value)" placeholder="Last Name">
/div>
h3> Full Name : {{fullName()}} /h3>
/div>

</code>
</pre>

      <h2 class="mt-4"> Effect Example </h2>
      <p> It reactively runs the function whenever any used signal changes.</p>
      <pre>
  <code>
    //counter.component.ts 

import { Component, signal, effect } from '@angular/core';
@Component({
  selector: 'app-counter',
  template: `
    h3>Counter: {{ count() }} /h3>
    button (click)="increment()">Increment /button>
  `
})
export class CounterComponent {
  count = signal(0);

  constructor() {
    // 👀 Effect runs whenever `count()` changes
    effect(() => {
      console.log('Counter changed to:', this.count());
    });
  }

  increment() {
    this.count.set(this.count() + 1);
  }
}

///output 
Counter changed to: 0
Counter changed to: 1
Counter changed to: 2

  </code>
</pre>

      <p class="mt-4"> <strong> Angular 18 Signal Create, Update, Access Signal Value </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
<h2 class="m-0 p-0"> Create and Access, Use computed, Array, Obj </h2>

TS FILE

import { ChangeDetectionStrategy, Component, computed, signal } from '@angular/core';
import { HeaderComponent } from "../header/header.component";

@Component({
  selector: 'app-signal',
  imports: [HeaderComponent],
  templateUrl: './signal.component.html',
  styleUrl: './signal.component.css',
})
export class SignalComponent {
  
  firstName = signal("Santosh");
  lastName = signal("Chandarvanshi");
  rollNumber = signal<number>( 123 )

  fullName = computed(()=> this.firstName() + this.lastName())

// Access City List
  cityList = signal(["Delhi" , "Delhi NCR"])

// Access Object Name
   studentObj = signal({
    name: "Pragyansh",
    city: "Delhi"
  })

==========

 // Change First Name ( Uses set used to update the value )

 changeName(){
    this.firstName.set("Anjali")
  }


// Add city Name ( Uses Rest Operator )  
addCity(){
    this.cityList.set([...this.cityList(), "Jaipur"])
   }

// Change city Name ( Uses Rest Operator ) 
changeStudentCity(){
    this.studentObj.set({...this.studentObj(), city:"Noida"})
   }


}

==== 

IN HTML 

div class="container mt-5">
<p class="m-0 p-0"> <strong> For Access only </strong> </p>
div class="row">
    div class="col-lg-3"> {{firstName()}} {{lastName()}} /div>
    div class="col-lg-1"> {{rollNumber()}} /div>
    div class="col-lg-3"> {{fullName()}}  /div>
    div class="col-lg-3"> {{cityList()}}  /div>
    div class="col-lg-2">  {{studentObj().name}}, {{studentObj().city}} /div>
/div>

<hr>

div class="row mt-5">
    div class="col-lg-7"> button class="btn btn-success" (click)="changeName()"> Change First Name /button>/div>
    div class="col-lg-3"> button class="btn btn-success" (click)="addCity()"> Add City Name /button>/div>
    div class="col-lg-2"> button class="btn btn-success" (click)="changeStudentCity()"> Change City Name /button>
/div>


/div>

  </code>
</pre>
      <hr>
      <h2> signal with changeDetection </h2>
      <pre>
  <code>

import { ChangeDetectionStrategy, Component, computed, signal } from '@angular/core';
import { HeaderComponent } from "../header/header.component";

@Component({
  selector: 'app-signal',
  imports: [HeaderComponent],
  templateUrl: './signal.component.html',
  styleUrl: './signal.component.css',
   //changeDetection: ChangeDetectionStrategy.OnPush
})
export class SignalComponent {
  
  firstName = signal("Santosh");
  lastName = signal("Chandarvanshi");

//courseName: string = "JAVA";

 constructor(){
    const fname = this.firstName();
    setTimeout(() => {
      
      this.firstName.set("Dot Net");
      //this.courseName = "HTML"

    }, 3000);
  }

}

====

In HTML 

div class="col-lg-3"> 
  {{firstName()}} {{lastName()}} 
       // {{courseName}}
  /div>

  </code>
</pre>


      <h2 class="mt-4"> Signals vs @Input() </h2>
      <p> Signals and @Input() are both used to pass or manage data in Angular, but they serve different purposes and
        can also be used together. </p>
      <p> Use @Input() for parent-to-child communication, and use Signals when you need local reactivity, derived state,
      </p>
      <h2> Can You Use Both Together? </h2>
      <p> Yes, You can receive an @Input() and wrap it into a Signal for further reactive processing. </p>

      <pre>
  <code>
TS 
@Input() title = '';
titleSignal = computed(() => this.title); // reactive
HTML 
child [title]="titleSignal()" />
  </code>
</pre>

      <h2 class="mt-4"> Signals vs BehaviorSubject </h2>
      <ul>
        <li> Reactivity Type - Signal Synchronous, BehaviorSubject - Push-based, observable stream </li>
        <li> Data Access - Signal .value() and BehaviorSubject - .value() </li>
        <li> Subscriptions - Signal Automatic via computed, effect , BehaviorSubject Manual via .subscribe() </li>
      </ul>

      <h2 class="mt-4"> Traditional Change Detection in Angular? </h2>
      <p> <strong> Traditional CD Flow: </strong></p>
      <ul>
        <li> You change some value (e.g., this.name = 'John') </li>
        <li> Zone.js detects the change (via events, setTimeout, etc.) </li>
        <li> Angular checks the whole component tree </li>
        <li> Updates DOM if bindings changed </li>
      </ul>

      <p> <strong> Signals </strong></p>
      <p> Angular Signals are a reactive state management system built into Angular (v17+), offering: </p>
      <ul>
        <li> Fine-grained reactivity </li>
        <li> Synchronous updates </li>
        <li> No reliance on Zone.js </li>
        <li> Can work in "zone-less" apps </li>
      </ul>


      <h2 class="mt-3"> <strong> sharing data in component using signal </strong></h2>
      <p> <strong> Scenario </strong></p>
      <ul>
        <li> Parent sends name to child using @Input() </li>
        <li> Child wraps name as a signal() for reactive use </li>
      </ul>


      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
  1. Parent Component (app.component.ts)
  @Component({
  selector: 'app-root',
  template: ``
})
export class AppComponent {}
====
2. Prent Component (app,component.html)
app-user-card [name]="'Angular Developer'"> /app-user-card>
===
3.  Child Component (user-card.component.ts)

import { Component, Input, signal, OnChanges, SimpleChanges } from '@angular/core';
@Component({
  selector: 'app-user-card',
  template: `<p>Hello, {{ nameSignal() }}!</p>`
})
export class UserCardComponent implements OnChanges {
  @Input() name: string = '';

  nameSignal = signal(''); // signal for local reactivity

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['name']) {
      this.nameSignal.set(this.name); // update signal on input change
    }
  }
}
====
4. user-card.component.html 
Hello, {{ nameSignal() }}!
========
Output 
Hello, Angular Developer!

</code>
</pre>




      <h2> Product List with Category Filters using Angular Signals </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>

    *product-filter.ts

import { Component, signal, computed } from '@angular/core';
import { HeaderComponent } from '../header/header.component';
import { CommonModule } from '@angular/common';

interface Product {
  id: number;
  name: string;
  category: 'electronics' | 'clothing' | 'home';
}

@Component({
  selector: 'app-product-filter',
  imports: [HeaderComponent, CommonModule],
  templateUrl: './product-filter.component.html',
  styleUrl: './product-filter.component.css'
})
export class ProductFilterComponent {

  products = signal Product[]>([
    { id: 1, name: 'Laptop', category: 'electronics' },
    { id: 2, name: 'T-Shirt', category: 'clothing' },
    { id: 3, name: 'Microwave', category: 'home' },
    { id: 4, name: 'Shoes', category: 'clothing' },
    { id: 5, name: 'Fan', category: 'home' }
  ]);

  selectedCategory = signal<'all' | 'electronics' | 'clothing' | 'home'>('all');

  filteredProducts = computed(() => {
    const category = this.selectedCategory();
    if (category === 'all') return this.products();
    return this.products().filter(p => p.category === category);
  });

  setFilter(cat: 'all' | 'electronics' | 'clothing' | 'home') {
    this.selectedCategory.set(cat);
  }

}

====

*Product Filter 

div class="container mt-5">
h2>Product List with Filters (Signals) /h2>
div class="filters">
  strong>Filter by Category: /strong>
  button (click)="setFilter('all')">All /button>
  button (click)="setFilter('electronics')">Electronics /button>
  button (click)="setFilter('clothing')">Clothing /button>
  button (click)="setFilter('home')">Home /button>
/div>
ul>
  li *ngFor="let product of filteredProducts()">
    {{ product.name }} ({{ product.category }})
  /li>
/ul>
/div>

  </code>
</pre>


      <h2> Reactive Task Manager (Using Angular Signals) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
   * Core Logic (task-manager.component.ts)

    import { Component, signal, computed, effect } from '@angular/core';
import { HeaderComponent } from "../header/header.component";
import { CommonModule } from '@angular/common';

interface Task {
  id: number;
  title: string;
  completed: boolean;
}

@Component({
  selector: 'app-task-manager',
  imports: [HeaderComponent, CommonModule],
  templateUrl: './task-manager.component.html',
  styleUrl: './task-manager.component.css'
})
export class TaskManagerComponent {

newTaskTitle = signal('');
  tasks = signal<Task[]>([]);

  // Computed signals
  completedTasks = computed(() => this.tasks().filter(task => task.completed));
  pendingTasks = computed(() => this.tasks().filter(task => !task.completed));

  // Log updates
  constructor() {
    effect(() => {
      console.log('Task List Updated:', this.tasks());
    });
  }

  addTask() {
    if (!this.newTaskTitle().trim()) return;
    const newTask: Task = {
      id: Date.now(),
      title: this.newTaskTitle(),
      completed: false
    };
    this.tasks.update(tasks => [...tasks, newTask]);
    this.newTaskTitle.set('');
  }

  toggleTask(taskId: number) {
    this.tasks.update(tasks =>
      tasks.map(task =>
        task.id === taskId ? { ...task, completed: !task.completed } : task
      )
    );
  }

  deleteTask(taskId: number) {
    this.tasks.update(tasks => tasks.filter(task => task.id !== taskId));
  }

  updateTaskTitle(event: Event) {
  const input = event.target as HTMLInputElement;
  this.newTaskTitle.set(input.value);
}

}


====

Template (task-manager.component.html)

div class="container">
div class="task-container">
h2>Signal-based Task Manager /h2>
div class="d-flex">
input class="form-control" type="text" [value]="newTaskTitle()" (input)="updateTaskTitle($event)" placeholder="Add a task"/>
button (click)="addTask()" class="btn btn-success">Add Task /button>
/div>
ul>
    li *ngFor="let task of tasks()">
      input type="checkbox" [checked]="task.completed" (change)="toggleTask(task.id)" />
      span [class.completed]="task.completed">{{ task.title }} /span>
      button (click)="deleteTask(task.id)">❌ /button>
    /li>
  /ul>
  div class="stats">
    ✅ Completed: {{ completedTasks().length }} |
    🔄 Pending: {{ pendingTasks().length }}
  /div>
/div>
/div>

  </code>
</pre>




    </div>

    <div class="box shadow p-2 mb-3" id="lazy">
      <h2> Lazy Loading </h2>
      <p> Lazy loading in Angular is a design pattern that improves the performance of an application by loading feature
        modules only when they are needed. Instead of loading all modules during the initial load of the application,
        Angular delays the loading of certain modules until the user navigates to a route associated with that module.
        This reduces the initial bundle size, resulting in faster application load times and a more responsive user
        experience. </p>
      <p> To implement lazy loading, you define your feature modules with their own routing configuration and set them
        up in the main routing file using the loadChildren property. This property tells Angular to load the module
        dynamically. For example, in your app-routing.module.ts, you might add a route like this: </p>
      <p> For example, suppose you have an Angular application with multiple feature modules, like a dashboard, user
        profile, settings, and reports. Instead of loading all these modules when the application starts, you can
        "configure lazy loading" to load these modules only when the user navigates to them. </p>

      <h2> <strong> Why Use Lazy Loading? </strong></h2>
      <ul>
        <li> Faster initial load </li>
        <li> Better performance </li>
        <li> Improves scalability </li>
      </ul>
      <p> <strong> app-routing.module.ts (after running above) </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        const routes: Routes = [
  {
    path: 'products',
    loadChildren: () =>
      import('./products/products.module').then(m => m.ProductsModule),
  },
];
      </code>
     </pre>
      <p> loadChildren → tells Angular to load the module only when route is accessed. </p>

      <h2> What Happens Behind the Scenes? </h2>
      <ul>
        <li> App loads only AppModule </li>
        <li> User clicks /products </li>
        <li> Angular fetches the ProductsModule asynchronously </li>
        <li> Displays the component </li>
      </ul>

      <h2> <strong> 1: Lazy Load Module with Route Guard </strong></h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    app-routing.module.ts
    import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { AuthGuard } from './auth.guard'; // create this

const routes: Routes = [
  {
    path: 'dashboard',
    canActivate: [AuthGuard], // ✅ Guard applied here
    loadChildren: () =>
      import('./dashboard/dashboard.module').then(m => m.DashboardModule),
  },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}

  </code>
</pre>

      <h2> <strong> 2: Create Auth Guard </strong></h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private router: Router) {}

  canActivate(): boolean {
    const isLoggedIn = true; // simulate login
    if (!isLoggedIn) {
      this.router.navigate(['/login']);
      return false;
    }
    return true;
  }
}

    </code>
    </pre>


    </div>

    <div class="box shadow p-2 mb-3" id="change">

      <h2> CHANGE DETECTION </h2>

      <p> Change Detection in Angular is the mechanism that keeps the view (HTML) in sync with the component's data
        (TypeScript). <br>
        Whenever data in your component changes (like a variable value), Angular automatically updates the DOM to
        reflect the new value.
        This is what we call Change Detection. </p>

      <p> <strong> Simply Analogy - </strong> Think of your component as a "control room" and your HTML view as the "TV
        screen".
        Whenever something changes in the control room, Angular sends a signal to the screen to update it. </p>

      <h2> <strong> How Change Detection Works in Angular? </strong> </h2>
      <p> Angular uses a Change Detection Tree that checks every component: </p>
      <ol>
        <li> Angular checks component properties (variables). </li>
        <li> If anything changes, Angular re-renders that component’s view. </li>
        <li> This checking is triggered automatically by:
          <ul>
            <li> Events (e.g., button click) </li>
            <li> Timers (e.g., setTimeout, setInterval) </li>
            <li> Observables (e.g., HttpClient, RxJS) </li>
            <li> User input (e.g., form changes) </li>
          </ul>
        </li>
      </ol>

      <h2> What Triggers Change Detection? </h2>
      <ul>
        <li> Event Binding - (click), (keyup) etc. </li>
        <li> setTimeout / setInterval - Timed logic </li>
        <li> HTTP calls (HttpClient) - API Response </li>
        <li> @Input() property change - Data passed from parent </li>
        <li> Angular lifecycle - ngOnInit, ngDoCheck, etc. </li>
      </ul>


      <h2> Change Detection Strategy (Default vs OnPush) </h2>
      Angular offers two strategies for change detection:
      <ol>
        <li> Default Change Detection </li>
        <li> OnPush Change Detection </li>
      </ol>

      <h2> 1. Default (default behavior) </h2>
      <ol>
        <li> Angular checks the component and all children every time. </li>
        <li> More automatic, but may be less efficient in large apps. </li>
      </ol>

      <h2> 2. OnPush Change Detection </h2>
      <p> In Angular, OnPush Change Detection is a strategy used to optimize performance by reducing how often Angular
        checks for changes in the component's view. </p>
      <ul>
        <li> Angular checks a component only if: An @Input() changes by reference, An event inside the component
          triggers it </li>
      </ul>

      <h2> Manual Change Detection (Advanced) </h2>
      <p> You can manually tell Angular to detect changes using ChangeDetectorRef. </p>

      <p> <strong> When Angular triggers OnPush detection: </strong></p>
      <ol>
        <li> @Input() reference changes: <br>
          If a component receives a new reference via an @Input(), Angular will trigger change detection. </li>
        <li> Observable emits new value: <br>
          If the component uses async pipe with an observable, and the observable emits a new value, it updates the
          view. </li>
        <li> Manually triggered: <br> You can manually mark a component for check using services like
          ChangeDetectorRef.markForCheck() or force an update with detectChanges(). </li>
        <li> Events inside the component: <br> DOM events (clicks, input) inside the component still trigger detection.
        </li>
      </ol>

      <h2> Why use OnPush? </h2>
      <ul>
        <li> Better performance, especially in large apps. </li>
        <li> Fewer unnecessary change detection cycles. </li>
      </ul>
      It’s most useful in high-performance apps, large lists, or components with infrequent changes.

      <h2 class="mt-4"> OnPush Change Detection with Live Data Examples </h2>

      <small>
        For Below code how it work = In this component, I’ve implemented ChangeDetectionStrategy.OnPush to optimize
        performance by avoiding automatic change detection.
        When I fetch user data from an API using HttpClient, Angular doesn't automatically detect the changes due to the
        OnPush strategy. So, I manually call ChangeDetectorRef.detectChanges() after a short delay to force Angular to
        update the view.
        This demonstrates how OnPush doesn’t track internal changes unless triggered by new references or manual change
        detection. It’s useful when working with large apps or when you want to avoid unnecessary checks for performance
        optimization.
      </small>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code>

 1. change-detection.component.ts 

import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Inject, inject, OnInit } from '@angular/core';
import { HeaderComponent } from "../header/header.component";
import { CommonModule } from '@angular/common';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-change-detection',
  imports: [HeaderComponent, CommonModule],
  templateUrl: './change-detection.component.html',
  styleUrl: './change-detection.component.css',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ChangeDetectionComponent {

  http = inject(HttpClient);
  users:any[] = [];

  constructor(
    // private cdRef: ChangeDetectorRef // For Manually Trigger
  ){}

  ngOnInit(){
    this.getUser()
  }

  getUser(){
    this.http.get('https://dummyjson.com/users').subscribe((response: any) => {
      this.users = response.users;
      // setTimeout(() => {
      //   this.cdRef.detectChanges() // For Manually Trigger
      // }, 5000);
    })
  }
  reloadUI(){} //manually trigger change detection
}

==============

 2. change-detection.component.html 

div class="container mt-5">
h1 class="mb-4"> Change Detection /h1>
table class="table table-bordered">
    thead>
        tr>
            th> First Name /th>
            th> Last Name /th>
            th> Email Address /th>
            th> Phone Number /th>
        /tr>
    /thead>
    tbody>
        tr *ngFor="let user of users">
            td> {{user.firstName}} /td>
            td> {{user.lastName}} /td>
            td> {{user.email}} /td>
            td> {{user.phone}} /td>
        /tr>
    /tbody>
/table>
button (click)="reloadUI()" class="btn btn-success mb-5"> Reload UI /button>
/div>
           
            
          </code>
        </pre>



      <p> <strong> Default Change Detection Examples :- </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code> 
            count = 0;
            increment() {
              this.count++;
            }
          </code>
          Count: {{ count }}
          button (click)="increment()">Increment</button>
        </pre>

      <h2> Onpush </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code>
            app-onpush [data]="message"></app-onpush>
            button (click)="updateMessage()">Update Message</button>
            Ts 
            message = 'Hello';
            updateMessage() {
              this.message = 'Hello, Angular!';
            }
        </code>
      </pre>

      <h2 class="mt-4"> zone.js </h2>
      <p> zone.js is a library used by Angular to automatically detect when to update the UI (DOM) after asynchronous operations. </p>
      <p> <strong> Why Angular Uses zone.js? </strong></p>
      <p> Angular has Change Detection — it checks for changes and updates the view. But how does Angular know when to run it? </p>
<ul>
  <li> <strong> How It Works Internally? </strong></li>
  <li> It patches async methods like: </li>
  <li> setTimeout, setInterval, Promise.then, </li>
  <li> XMLHttpRequest (used in HTTP calls) </li>
</ul>

    </div>

    <div class="box shadow p-2 mb-3" id="microfronted">
      <h2> <strong> Micro Frontend </strong> </h2>

      <ul>
        <li> <strong> What is Micro Frontend Architecture? </strong></li>
        <li> Micro Frontend (MFE) is a design pattern where a large frontend application is divided into smaller,
          independent apps (micro frontends). </li>
        <li> Each micro frontend is developed, deployed, and maintained independently. </li>
        <li> It's like Microservices, but for frontend UI. </li>
      </ul>

      <ul>
        <li> <strong> Why Use Micro Frontend in Angular? </strong></li>
        <li> Scalability: Large applications can be split into smaller manageable parts. </li>
        <li> Independent Deployment: Each micro frontend can be developed, tested, and deployed independently. </li>
        <li> Technology Agnostic: Different teams can use different frameworks (Angular, React, Vue) if needed. </li>
        <li> Better Maintainability: Smaller codebases are easier to maintain. </li>
      </ul>

      <h2> <strong> Steps to Implement Micro Frontend in Angular </strong> </h2>
      <p> Let's assume we have: </p>
      Shell App (Host Application) → Main container that loads micro frontends. <br>
      Remote App 1 (Micro App 1) <br>
      Remote App 2 (Micro App 2) <br>

      <h2 class="mt-4"> <strong> How It Works (High Level) </strong></h2>
      <ul>
        <li> Host App (Shell): Loads layout + micro-frontends </li>
        <li> Remote Apps: Micro-frontends built and exposed as modules </li>
        <li> Use Module Federation (Webpack 5) to load remotes dynamically </li>
      </ul>

      <h2> <strong> Micro-Frontend in Angular (via Module Federation) </strong></h2>
      <p> <strong> Step 1: </strong> Install Webpack Module Federation Plugin <br> ng add
        @angular-architects/module-federation </p>
      <p> <strong> Step 2: </strong> Create Shell & Remote Apps <br>
        ng new shell --routing --style=scss <br>
        ng generate application mfe-products --routing
      </p>
      <p> <strong> Step 3: </strong> Configure Module Federation <br> Update webpack.config.js or webpack.config.mjs for
        both apps. </p>
      <p> <strong> Shell App </strong></p>
      <pre>
            <code> 
              // shell/webpack.config.mjs
remotes: {
  'mfeProducts': 'mfeProducts@http://localhost:4201/remoteEntry.js'
}
            </code>
          </pre>
      <p> <strong> Remote App (mfe-products): </strong></p>
      <pre>
            <code>
              // mfe-products/webpack.config.mjs
name: 'mfeProducts',
exposes: {
  './Module': './src/app/products/products.module.ts',
}
            </code>
          </pre>
      <p> <strong> Step 4: </strong> Load Remote Module in Shell </p>
      <pre>
            <code>
              app.routes.ts 
              {
  path: 'products',
  loadChildren: () =>
    loadRemoteModule({
      type: 'module',
      remoteEntry: 'http://localhost:4201/remoteEntry.js',
      exposedModule: './Module',
    }).then(m => m.ProductsModule)
}

            </code>
          </pre>

    </div>


    <div class="box shadow p-2 mb-3" id="webpack">

      <h2> Webpack </h2>
      <p> In Angular, Webpack is used internally by the Angular CLI to bundle, <br> 
        for optimize, and serve our application. <br> 
        We usually don’t configure it manually, but it’s responsible for converting our code into browser-ready, optimized files. </p>

      <p> It takes all the code and assets (JavaScript, CSS, images, etc.) in your project, bundles them together, and
        outputs optimized files for the browser. </p>

      <h2> <strong> Webpack in Angular </strong></h2>
      <p> Angular uses Webpack under the hood via the Angular CLI. </p>
      <p> You don’t need to configure it manually unless you’re doing advanced stuff like: </p>
      <ul>
        <li> Custom builds </li>
        <li> Micro-frontends (using Module Federation) </li>
        <li> Third-party integration </li>
      </ul>
    </div>


    <div class="box shadow p-2 mb-3" id="pitfalls">
      <h2> <strong> Best Practices vs. ❌ Common Pitfalls in Angular (Performance Focused) </strong></h2>
      <ul>
        <li> <strong> Best Practice </strong></li>
        <li> Use OnPush change detection strategy </li>
        <li> Lazy-load feature modules with loadChildren </li>
        <li> Use trackBy in *ngFor to avoid full DOM re-renders </li>
        <li> Use pure pipes and avoid heavy logic in templates </li>
        <li> Use *ngIf and *ngFor together carefully </li>
        <li> Optimize image loading (lazy load, compress, use srcset) </li>
        <li> <strong> Common Pitfall </strong></li>
        <li> Using default change detection everywhere (ChangeDetectionStrategy.Default) </li>
        <li> Eager loading everything in AppModule </li>
        <li> Not using trackBy → leads to unnecessary DOM changes </li>
        <li> Doing complex calculations directly inside the HTML </li>
      </ul>

    </div>

    <div class="box shadow p-2 mb-3" id="aggrid">
      <h2> <strong> ag-Grid vs. ngx-datatable (Angular Table Libraries) </strong></h2>

      <p> <strong> 1. ag-Grid (Now called AG Grid) </strong></p>
      <ul>
        <li> Large datasets </li>
        <li> Enterprise-level apps </li>
        <li> Advanced features like grouping, pivot, Excel export </li>
      </ul>
      <p> <strong> Keyfeatures </strong> Virtual Scroll , Server-side Pagination, Filtering & Sorting, Excel Export,
        Custom Cell Templates </p>
      <p> Installation - npm install ag-grid-community ag-grid-angular </p>
      <pre>
    <code>
      Basic Usage:
      import { AgGridModule } from 'ag-grid-angular';

@NgModule({
  imports: [AgGridModule.withComponents([])],
})
export class AppModule {}

    </code>
  </pre>

      <pre>
    <code>
      import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `<ag-grid-angular
               class="ag-theme-alpine"
               [rowData]="rowData"
               [columnDefs]="columnDefs"
               style="width: 100%; height: 400px;">
             </ag-grid-angular>`,
})
export class AppComponent {
  columnDefs = [
    { field: 'name' },
    { field: 'age' },
    { field: 'email' }
  ];
  rowData = [
    { name: 'John', age: 28, email: 'john@example.com' },
    { name: 'Jane', age: 34, email: 'jane@example.com' }
  ];
}

//support
gridApi.exportDataAsExcel();

    </code>
  </pre>

      <h2> 2. ngx-datatable </h2>
      Best For:
      Mid-size apps
      Simple use cases
      Quick, styled data tables
      <p> Installation : npm install @swimlane/ngx-datatable </p>
      <p> <strong> Basic Usage </strong></p>
      <pre>
  <code>
    import { NgxDatatableModule } from '@swimlane/ngx-datatable';

@NgModule({
  imports: [NgxDatatableModule]
})
export class AppModule {}

  </code>
</pre>

      <pre>
  <code>
    @Component({
  selector: 'app-root',
  template: `
    <ngx-datatable
      class="bootstrap"
      [rows]="rows"
      [columns]="columns"
      [columnMode]="'force'"
      [headerHeight]="40"
      [footerHeight]="40"
      [rowHeight]="'auto'">
    </ngx-datatable>
  `
})
export class AppComponent {
  columns = [{ prop: 'name' }, { name: 'Age' }, { name: 'Email' }];
  rows = [
    { name: 'Alice', Age: 23, Email: 'alice@gmail.com' },
    { name: 'Bob', Age: 30, Email: 'bob@gmail.com' }
  ];
}

  </code>
</pre>

      <p> <strong> If you’re building an admin dashboard with thousands of records, go with ag-Grid </strong></p>
      <p> <strong> If you just want a fast, clean, customizable table for CRUD — ngx-datatable is easy to plug in
        </strong></p>
    </div>


    <div class="box shadow p-2 mb-3" id="ssr">
      <h2> SSR </h2>
      <p> SSR - server-side rendering (SSR) is a process that involves rendering pages on the server, resulting in
        initial HTML content which contains initial page state. </p>
    </div>


    <div class="box shadow p-2 mb-3" id="aot">
      <h2> How to use multiple API in angular ? + AOT JIT </h2>
      <p> Angular, We can use multiple APIs in different ways.
        Using forkJoin (Parallel API Calls - Best for Independent APIs) </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
                <code>
                  forkJoin([
                  this.http.get('https://api.example.com/users'),
                  this.http.get('https://api.example.com/posts')
                ]).subscribe(([users, posts]) => {
                  console.log('Users:', users);
                  console.log('Posts:', posts);
                });
                </code>
              </pre>
      <p> AOT - Ahead of time compilation at build time application runs. <br>
        JIT - Just in time </p>

      <h2> Different AOT AND JIT </h2>
      <ol>
        <li> JIT (Just-in-Time) Compilation: </li>
        <li> Happens at runtime in the browser. </li>
        <li> Compiles the Angular application in the browser as it loads. </li>
        <li> Faster development builds but slower performance in production. </li>
      </ol>

      <ol>
        <li> AOT (Ahead-of-Time) Compilation: </li>
        <li> Happens during the build phase before the application is run. </li>
        <li> Compiles the application into efficient JavaScript code ahead of time, which leads to faster loading and
          better performance. </li>
        <li> Recommended for production builds. </li>
      </ol>
    </div>


    <div class="box shadow p-2 mb-3" id="viewchild">
      <h2> @VIEW Child </h2>
      <p> @ViewChild is a decorator in Angular that allows us to access and interact with child components, directives,
      </p>
      <h2> @view child examples </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    @ViewChild('heading') headingElement!: ElementRef;
    ngAfterViewInit() {
      console.log('Text content:', this.headingElement.nativeElement.textContent);
    }
    changeText() {
      this.headingElement.nativeElement.textContent = 'Text Changed!';
      this.headingElement.nativeElement.style.color = 'red';
    }

    ------- HTML ------ 

    h2 #heading>Welcome to Angular!</h2>
    button (click)="changeText()">Change Text</button>

  </code>
</pre>

      <H2>@ViewChildren (Multiple Element or Component References) </H2>
      <p><strong> child.component.ts </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    greet() {
      return 'Hello from Child Component!';
    }
  </code>
</pre>

      <p><strong> parent.component </strong></p>
      app-child></app-child> <br>
      app-child></app-child> <br>
      app-child></app-child> <br>
      button (click)="callChildrenMethods()">Call All Child Methods</button>

      <p><strong> parent.component ts </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    @ViewChildren(ChildComponent) children!: QueryList<ChildComponent>;
      ngAfterViewInit() {
        this.children.forEach((child, index) => {
          console.log(`Child ${index + 1}: ` + child.greet());
        });
      }
      callChildrenMethods() {
        this.children.forEach((child) => alert(child.greet()));
      }
  </code>
</pre>

    </div>


    <div class="box shadow p-2 mb-3" id="databinding">
      <h2> DATA BINDING </h2>

      <ul>
        <li> <strong> Interpolation ({{ }}) → </strong> Inserts dynamic values from component to template as text. </li>
        <li> <strong> Property Binding ([ ]) → </strong> Binds component data to an HTML element/property. </li>
        <li> <strong> Event Binding (( )) → </strong> Listens to DOM events and calls component methods. </li>
        <li> <strong> Two-way Binding ([( )]) → </strong> Synchronizes data between component and template in both directions. </li>
      </ul>

      <h2> Event Binding </h2>
      <p><strong> Event binding is the process of targeting an event in a HTML element. </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  TS
  clickEvent(){
    console.log("event binding")
  }
  clickEvent2(val:string){
    console.log(val)
  }
-------
  HTML 
  button type="button" (click)="clickEvent()"> Event Binding </button>
  input type="text" #box (keyup)="clickEvent2(box.value)" placeholder="Event Keyup">
</code>
</pre>
      <h2> Property Binding </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    TS 
    isDisabled = true
    defaultName = "santosh"
    imgUrl = "assets/imags/icon.png"

    HTML
    input type="text" [disabled]="isDisabled">
    input type="text" [value]="defaultName">
    img [src]="imgUrl" alt="">
  </code>
</pre>
      <h2> Attribute Binding </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    TS 
    columnSpan = 3
    placeholder1 = "First Name"

    HTML
    td [attr.colspan]="columnSpan">Content</td>
    input type="text" [attr.placeholder]="placeholder1" name="username" required>
  </code>
</pre>
      <h2> Class Binding </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    TS
    isActive = true
    isSuccess = true;
    isError = false;

    HTML
    div [class.active]="isActive"> Hello /div>
    div [ngClass]="['class-one', true ? 'class-two' : false]"> Box /div>
    div [ngClass]="{'success': isSuccess, 'error': isError}"> Status /div>
  </code>
</pre>

      <h2> Style Binding </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    TS
    bgColor = 'yellow'

    HTML 
    div [style.backgroundColor]="bgColor"> Santosh div>
  </code>
</pre>

      <P> Data binding is one of the most elements for creating communication between the DOM and the component. </P>
      <h2> Two-way Binding Example </h2>
      <p> when the data in the model changes, the changes are reflected in the view and when the data in the view
        changes it is reflected in the model - [(ngModel)]</p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      userInput: string = '';  // Model property
      input type="text" [(ngModel)]="userInput" placeholder="Type something..." />
      p>You typed: {{ userInput }}</p>
    </code>
  </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="datatransfer">
      <h2> Using a Shared Service with a Subject/BehaviorSubject </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
	<code>
	Create a shared service:
	// data.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private dataSource = new BehaviorSubject<any>(null);
  currentData = this.dataSource.asObservable();

  changeData(data: any) {
    this.dataSource.next(data);
  }
}
	</code>
	</pre>
      <h2> In Component A (sending component): </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
	<code>
	
	 
	 constructor(private dataService: DataService) {}

		sendData() {
		  this.dataService.changeData('Hello from Component A');
		}

	</code>
	</pre>
      <h2> In Component B (receiving component): </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
	<code>
	dataFromA: any;

constructor(private dataService: DataService) {}

ngOnInit() {
  this.dataService.currentData.subscribe(data => {
    this.dataFromA = data;
  });
}

	</code>
	</pre>

      <h2> Using Angular Router (if navigating with data) </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
-sender component
this.router.navigate(['/target'], { state: { message: 'Hello' } });
- Receive componet
constructor(private router: Router) {
  const nav = this.router.getCurrentNavigation();
  const state = nav?.extras.state as { message: string };
  console.log(state.message);
}

</code>
</pre>


    </div>


    <div class="box shadow p-2 mb-3" id="decorator">
      <h2> DECORATOR </h2>
      <p> <strong> Decorator is a function that add metadata to a class. @component, @directives, @ngModule, @input,
          @output, @hostListener </strong> </p>

      <h2> Decorators Types </h2>
      <div class="mb-3">
        <strong> 1. Class Decorators <br> </strong>
        These are used to define classes as Angular like components, modules, directives, etc.<br>
        <strong> @Component </strong> - Declares a class as a component and provides metadata like selector, template,
        styles, etc. <br>
        <strong> @Directive </strong> Declares a class as a directive. Used to extend the behavior of elements. <br>
        <strong> @Injectable </strong> Marks a class as available to be injected as a dependency. <br>
        <strong> @NgModule </strong> Declares a class as an Angular module and provides metadata about the module.
      </div>

      <div class="mb-4">
        <strong> 2. Property Decorators <br> </strong>
        Used to decorate properties inside classes. <br>
        <strong> @Input </strong> - Declares an input property to receive data from a parent component. <br> - @Input()
        title: string;
        <br>
        @Output - Declares an output property that emits events to the parent component. <br>
        @Output() clicked = new EventEmitter<void>(); <br>
        </void>
        <strong> @ViewChild / @ViewChildren </strong> , Accesses child component(s) or element(s) in the component's
        view. <br>
        <strong> @ContentChild / @ContentChildren </strong> Accesses projected content inside <ng-content>.
      </div>

      <div class="mb-4">
        <strong> 3. Method Parameter Decorators </strong> <br>
        @Inject - Specifies a custom provider token when injecting a dependency. <br>
        @Optional - Marks a dependency as optional. If it’s not found, Angular will pass null.
      </div>


      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        import { Component } from '@angular/core';
        @Component({
          META DATA
          selector: 'app-ngfor',
          standalone: true,
          imports: [CommonModule, HeaderComponent],
          templateUrl: './ngfor.component.html',
          styleUrl: './ngfor.component.css'
        })
        export class NgforComponent { }
      </code>
    </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="directive">
      <h2> Directive </h2>
      <p> <strong> Directives are classes that enhance the feature of a HTML element. </strong> </p>
      <ol>
        <li> Component Directives (Most Common) <br> Technically, components are a type of directive with a template.
        </li>
        <li> <strong> Structural Directives (Modify the DOM Structure) </strong> <br>
          <p> Structural directives change the DOM by adding, removing, or manipulating elements. </p>
          *ngIf → Condition-based rendering. <br>
          *ngFor → Loops over collections. <br>
          *ngSwitch → Switch-case logic. <br>
        </li>
        <li> <strong> Attribute Directives </strong> (Modify the appearance or behavior of elements)

<p> Attribute directives change the styling or behavior of elements without altering the structure. </p>
Examples: [ngClass], [ngStyle], custom attribute directives.
<pre class="mt-4">
  <code>
p [ngClass]="{'highlight': isActive}">Styled text /p>
p [ngStyle]="{'color': textColor}">Dynamic color /p>
  </code>
</pre>
<hr>
          <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        constructor(private el: ElementRef) {
          el.nativeElement.style.backgroundColor = 'yellow';
        }
        p appHighlight>This text will have a yellow background.</p>
      </code>
     </pre>
        </li>
      </ol>

      <ol>
        <li> ElementRef → Direct access to the DOM element. </li>
        <li> Renderer2 → Safe way to modify the DOM. </li>
        <li> @HostListener → Handles events inside directives. </li>
        <li> @HostBinding → Binds properties to the host element. </li>
        <li> @Input() → Passes values into the directive. </li>
      </ol>

      <h2> Custom Directive </h2>

      <h2> Simple Angular custom directive </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        ng generate directive changeBg
        ------

        // change-bg.directive.ts
        import { Directive, ElementRef, HostListener, Renderer2 } from '@angular/core';

        @Directive({
          selector: '[appChangeBg]'
        })
        export class ChangeBgDirective {

          private isColored = false;

          constructor(private el: ElementRef, private renderer: Renderer2) {}

          @HostListener('click') onClick() {
            this.isColored = !this.isColored;
            const color = this.isColored ? 'lightblue' : 'white';
            this.renderer.setStyle(this.el.nativeElement, 'background-color', color);
          }
        }

        ----- 

        <!-- parent.component.html or app.component.html -->
      button appChangeBg>Click me to change background /button>

      </code>
    </pre>

      <br>

      <h2> Accept dynamic color as input </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        @Input('appChangeBg') color = 'yellow'; // default

        @HostListener('click') onClick() {
          const bg = this.isColored ? 'white' : this.color;
          this.renderer.setStyle(this.el.nativeElement, 'background-color', bg);
          this.isColored = !this.isColored;
        }

        ------ 

        button [appChangeBg]="'pink'"> Click me /button>

      </code>
    </pre>

      <br>

      <h2> Work on multiple elements (like multiple buttons or divs) <br> Accept a color as input <br> Apply or remove a
        CSS class (instead of inline styles) </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    1. Create Class 
    .custom-bg {
  background-color: lightblue;
  transition: background-color 0.3s ease;
}

--------------

2. Update the Directive

// change-bg.directive.ts
import { Directive, ElementRef, HostListener, Input, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appChangeBg]'
})
export class ChangeBgDirective {
  private isActive = false;

  @Input('appChangeBg') bgClass: string = 'custom-bg'; // default class

  constructor(private el: ElementRef, private renderer: Renderer2) {}

  @HostListener('click') toggleBg() {
    this.isActive = !this.isActive;

    if (this.isActive) {
      this.renderer.addClass(this.el.nativeElement, this.bgClass);
    } else {
      this.renderer.removeClass(this.el.nativeElement, this.bgClass);
    }
  }
}


-----

 3. Use in HTML on multiple elements

 <!-- Works on multiple buttons -->
button appChangeBg>Button 1 /button>
button appChangeBg>Button 2 /button>

<!-- Apply custom class -->
button [appChangeBg]="'my-highlight'">Custom Class /button>

<!-- Works on divs too -->
div appChangeBg style="padding: 10px;">Div 1 /div>
div appChangeBg>Div 2 /div>

----------- 

 4. Optional: Custom class

.my-highlight {
  background-color: hotpink;
  color: white;
  font-weight: bold;
}


  </code>
</pre>

      <br>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        custom Directive Command - ng g d directive-name (cdirective)
        @Input() color!:string;
    
        constructor(private el: ElementRef) {} //Refrence DOM elements, //void is a type that represents the absence of a value
    
        ngOnInit(): void { 
        // this.el.nativeElement.style.backgroundColor = 'red';
            this.el.nativeElement.style.backgroundColor = this.color;
        }
        &lt;p cdirective color="red"&gt; Form &lt;/p&gt;
    -------------------------

   <h2>// onclick change the background color or toggle  </h2> 
    
    import { Directive, ElementRef, HostListener, Input, OnInit } from '@angular/core';

    @Directive({
      selector: '[toggleColor]'
    })
    export class ToggleColorDirective implements OnInit {
      @Input() defaultColor: string = 'yellow'; // Default background color
      @Input() highlightColor: string = 'red';  // Color to toggle on click
    
      private isHighlighted = false;
    
      constructor(private el: ElementRef) {}
    
      ngOnInit(): void {
        this.el.nativeElement.style.backgroundColor = this.defaultColor;
      }
    
      @HostListener('click') onClick() {
        this.isHighlighted = !this.isHighlighted;
        this.el.nativeElement.style.backgroundColor = this.isHighlighted
          ? this.highlightColor
          : this.defaultColor;
      }
    }
    
     HTML 

    button 
  toggleColor 
  [defaultColor]="'yellow'" 
  [highlightColor]="'red'" 
  class="px-4 py-2 rounded-md border">
  Click Me
/button>
     
     
        ---------------- 
      @Directive({
        selector: '[websanto]', // Custom attribute selector
      })
    
      @Input() color: string = ''; // Input property for color
    
      constructor(private el: ElementRef) {}
    
      ngOnInit() {
        this.el.nativeElement.style.backgroundColor = this.color; // Apply color
      }
    in HTML 
    &lt;button websanto color="red">Submit&lt;/buttonp&gt;
      </code>
    </pre>

      <br>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        //highlight-india.directive.ts

        import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';

@Directive({
  selector: '[appHighlightIndia]',
  standalone: true,
  imports: [CommonModule]
})
export class HighlightIndiaDirective {
  constructor(private el: ElementRef, private renderer: Renderer2) {}

  @HostListener('click')
  onClick() {
    // Delay to allow options to render if needed
    setTimeout(() => {
      const options = this.el.nativeElement.options;
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        if (option.text.trim().toLowerCase() === 'india') {
          this.renderer.setStyle(option, 'color', 'red');
          this.renderer.setStyle(option, 'textDecoration', 'underline');
        }
      }
    });
  }
}


------------------

app.component.ts

import { Component } from '@angular/core';
import { HighlightIndiaDirective } from './highlight-india.directive';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [HighlightIndiaDirective],
  template: `
    h2>Select a Country /h2>
    select appHighlightIndia>
      option>USA/option>
      option>Canada/option>
      option>UK/option>
      option>Germany/option>
      option>Australia/option>
      option>France/option>
      option>Italy/option>
      option>Japan/option>
      option>India/option>
      option>Brazil/option>
    /select>
  `
})
export class AppComponent {}

      </code>
    </pre>

    </div>

    <div class="box shadow p-2 mb-3" id="input">
      <h2> @Input, @output </h2>
      <p> @Input and @Output are used for communication between parent and child components </p>

      <h2> Step-by-Step: Parent to Child Data Sharing </h2>
      <h2> Child Component (child.component.ts) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>Message from Parent: {{ message }}</p>`
})
export class ChildComponent {
  @Input() message: string = '';
}

  </code>
</pre>
      <p> <strong> 2. Parent Component (parent.component.ts) </strong> </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    h2>Parent Component/h2>
    app-child [message]="parentMessage">/app-child>
  `
})
export class ParentComponent {
  parentMessage: string = 'Hello from Parent!';
}


//output 
Parent Component
Message from Parent: Hello from Parent!
  </code>
</pre>
      <p> @Input() is used in child to receive data. <br>
        [] square brackets used in parent HTML to bind a variable. </p>

      ============

      <h2> Sharing data between parent and multiple child components </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    1. Parent Component (Holds the Button & Shared State)

    // parent.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    button (click)="changeBackground()">Change Background/button>
    app-child [changeColor]="isColorChanged">/app-child>
    app-child [changeColor]="isColorChanged">/app-child>
  `
})
export class ParentComponent {
  isColorChanged = false;

  changeBackground() {
    this.isColorChanged = !this.isColorChanged;
  }
}
-------------- 

// 2. Child Component (Listens via @Input) 

// child.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `
    div [ngStyle]="{'background-color': changeColor ? 'lightblue' : 'lightgray'}"
         style="width: 200px; height: 100px; margin: 10px; border: 1px solid #ccc;">
      Child Box
    /div>
  `
})
export class ChildComponent {
  @Input() changeColor: boolean = false;
}

  </code>
</pre>


      <p> <strong> example child ts </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code class="whitespace-pre! language-html">
        @Input() message!: string; 
        template: `&lt;p&gt; Message from Parent: {{ message }} &lt;/p&gt; `,  
      </code>
    </pre>
      <p> <strong> parent ts </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code> parentMessage = 'Hello, Child!'; </code></pre>

      <p> <strong> @output examples - child ts - </strong></p>
      @Output() messageEvent = new EventEmitter<string>();
        sendMessage() {
        this.messageEvent.emit('Hello, Parent!'); // Sending data to parent
        }
        <p> <strong> Parent ts - </strong></p>
        template : `
        app-child (messageEvent)="receiveMessage($event)"> - app-child
        <p>Received Message: {{ receivedMessage }}</p>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        receivedMessage = ''; <br>
    receiveMessage(message: string) {
      this.receivedMessage = message; // Updating receivedMessage from child
    }  
      </code>
    </pre>

        <h2> @input Examples </h2>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
	<code>
	child.component.ts
	import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `p>Hello {{ name }}!p>`
})
export class ChildComponent {
  @Input() name!: string;
}

-- parent.component.html
app-child [name]="'Angular Learner'"> app-child>

	</code>
	</pre>


        <h2> @output Examples </h2>
        <p> It allows a child component to send data to the parent component using an event. </p>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
	<code>
	child.component.ts
	import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `button (click)="sendData()">Send button>`
})
export class ChildComponent {
  @Output() messageEvent = new EventEmitter<string>();

  sendData() {
    this.messageEvent.emit('Hello from Child!');
  }
}

---------

Prent component html 

app-child (messageEvent)="receiveMessage($event)"> app-child>
p>{{ message }} /p>

---------

parent.component.ts

export class ParentComponent {
  message = '';

  receiveMessage(data: string) {
    this.message = data;
  }
}


	</code>
	</pre>

    </div>


<div class="box shadow p-2 mb-3" id="ngfor">
<h2> Ngfor, forloop </h2>
<p> In Angular, *ngFor is a structural directive that repeats a portion of the template for each item in a collection (array or iterable). </p>
<p> <strong> *ngIf </strong></p>
<p> In Angular, *ngIf is a structural directive that conditionally includes or removes an element from the DOM based on a boolean expression. </p>

<p>"<strong> ng-container </strong> is used to group elements without adding extra HTML to the DOM. <strong> ng-template </strong> stores a block of HTML/Angular code that is not rendered by default and can be rendered later using ngTemplateOutlet or structural directives." </p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
employees = [
{
id: 1,
name: "Santosh Kumar",
age: 30,
department: "Human Resources",
salary: 5000000
},
&lt;tr *ngFor="let employee of employees"&gt;  &lt;tr&gt;
----------------------
isVisiable:boolean = false 
&lt;h2 *ngIf="isVisiable"&gt; Welcome to NgIf &lt; h2 &gt;
----------------------
  </code>
</pre>

  <h2> Ngfor and NgIf </h2>
  <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
TS 
public staffs = [
{ staff_name: "Rakesh", age:35, salary:50000, },
{ staff_name: "Mohan", age:35, salary:100000, },
{ staff_name: "Sohan", age:35, salary:30000, },
{ staff_name: "Jhannu", age:35, salary:100000, },
{ staff_name: "Pradeep", age:35, salary:50000, },
{ staff_name: "Kailash", age:35, salary:100000, },
{ staff_name: "Jhunjhunwala", age:35, salary:100000, }
  ]

  HTML 

  li *ngFor="let staff of staffs"> 
ng-container *ngIf="staff.salary < 50000; else highsalary">
{{staff.staff_name}} {{staff.salary}}
/ng-container>
ng-template #highsalary>
  div style="background-color: #ececec;">   {{staff.staff_name}} {{staff.salary}} div>
/ng-template>
/li>

NODATA

div *ngIf="employees && employees.length > 0; else nodata"> 
  div *ngFor="let emp of employees">
  ng-container *ngIf="emp.salary > 400000; else highsalary">
 span style="color: red;">  {{emp.name}} /span>
  /ng-container>
  ng-template #highsalary>
  {{emp.name}}
  /ng-template>
  /div>
  /div>
  ng-template #nodata> p> No Data /p>/ng-template>

    -------------- 

<h2> Toggle </h2>
TS
isVisiable = true
toggleButton(){
  this.isVisiable = !this.isVisiable
} 

HTML 
div *ngIf="isVisiable" class="mt-10"> This message for isVisiable /div>
button type="button" (click)="toggleButton()"> Show and Hide /button>

  </code>
</pre>

  <h2> @HostListener </h2>
  @HostListener is a decorator in Angular that lets you listen to DOM events on the host element of a directive or
  component.
  You use it when you want to react to events like clicks, mouse movements, key presses, etc., directly on the
  element where your directive or component is applied.



</div>


    <div class="box shadow p-2 mb-3" id="scrolltop">
      <h2> SCROLLTOP</h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        private showClass = 'show-scroll-button';
  constructor(private el: ElementRef, private renderer: Renderer2) {}
  ngOnInit() {
    this.renderer.addClass(this.el.nativeElement, 'scroll-to-top');
  }
  @HostListener('window:scroll', [])
  onWindowScroll(){
    if(window.scrollY > 200){
      this.renderer.addClass(this.el.nativeElement, this.showClass);
    } else {
      this.renderer.removeClass(this.el.nativeElement, this.showClass);
    }
  }
  @HostListener('click') onclick(){
    window.scrollTo({ top:0, behavior: 'smooth'});
  }
      </code>
    </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="add-remove">
      <h2> ADD AND REMOVE CLASS </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    @HostListener('click') onClick() {
      this.isHighlighted = !this.isHighlighted;
  
      if (this.isHighlighted) {
        // Add class to clicked element
        this.renderer.addClass(this.el.nativeElement, 'active');
  
        // Remove class from other elements
        this.removeClassFromOtherElements();
      } else {
        // Remove class from this element
        this.renderer.removeClass(this.el.nativeElement, 'active');
      }
    }
  </code>
</pre>
    </div>

    <div class="box shadow p-2 mb-3" id="accordion">
      <h2> Custom Accordion and Tabs </h2>
      <pre>
  <code>
   // Accordion 
TS 
// component.ts
accordionItems = [
  { title: 'Section 1', content: 'Content for section 1' },
  { title: 'Section 2', content: 'Content for section 2' },
];

activeIndex: number | null = null;

toggle(index: number) {
  this.activeIndex = this.activeIndex === index ? null : index;
}
=====
HTML 
div *ngFor="let item of accordionItems; let i = index">
  div (click)="toggle(i)" style="cursor: pointer; font-weight: bold;">
    {{ item.title }}
  /div>
  div *ngIf="activeIndex === i">
    {{ item.content }}
  /div>
/div>

//TABS 
HTML 
ul class="tab-header">
  li *ngFor="let tab of tabs; let i = index"
      [class.active]="selectedTab === i"
      (click)="selectTab(i)">
    {{ tab.label }}
  /li>
/ul>

div class="tab-content">
  {{ tabs[selectedTab].content }}
/div>

//TS 
tabs = [
  { label: 'Tab 1', content: 'Content 1' },
  { label: 'Tab 2', content: 'Content 2' }
];

selectedTab = 0;

selectTab(index: number) {
  this.selectedTab = index;
}

//css 
.tab-header {
  list-style: none;
  display: flex;
}
.tab-header li {
  padding: 10px;
  border: 1px solid #ccc;
  cursor: pointer;
}
.tab-header li.active {
  background: #007bff;
  color: white;
}
.tab-content {
  border: 1px solid #ccc;
  padding: 10px;
}

  </code>
</pre>
    </div>


    <div class="box shadow p-2 mb-3" id="pipe">
      <h2> PIPE, CUSTOM PIPE, PURE, IMPURE <a href="#custompipe-examples"> Example </a></h2>

      <p> <strong> Pipes are a special operator in Angular template expressions that allows you to transform data
          declaratively in your template. </strong></p>
      <h2> What is the difference between a Pipe and a Directive? </h2>
      <p> <strong> Pipes </strong> transform data in templates (date, uppercase). <br>
        <strong> Directives </strong> modify the behavior of DOM elements (ngIf, ngFor).
      </p>
      <h2> What are pure Pipes? </h2>
      <p> Pure pipes are executed only when a "pure change" is detected in the input value. <br> By default, all
        pipelines are pure </p>

      <h2> What are Impure Pipes? </h2>
      <p> Angular calls an impure pipe for each change detection cycle, independent of the change in the input fields.
        For each of these pipes, several pipe instances are produced. </p>

      <h2> Disadvantages of Impure Pipes </h2>
      <p class="p-0, m-0"> 1. Performance Issues -- Impure pipes run every time Angular checks for changes, which could
        be many times per second. </p>
      <p class="p-0, m-0"> 2. Unnecessary Computations - Even if the input data hasn’t changed, the pipe still executes.
      </p>
      <p class="p-0, m-0"> 3. Hard to Debug - Since impure pipes run so frequently, it can be difficult to track down
        performance bottlenecks or unintended behaviors. </p>

      <br>
      <p> <strong> pure - Only when input data changes , Faster , Static data transformations </strong></p>
      <p> <strong> impure - On every change detection cycle, Slower </strong></p>

      <h2> What is Pipe transform Interface in Angular? </h2>
      <p> An interface used by pipes to accomplish a transformation. Angular calls the transform function with the value
        of a binding as the first argument and any arguments as the second parameter in list form. This interface is
        used to implement custom pipes. </p>

      <h2> 1. Capitalize First Letter Pipe </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
capitalize.pipe.ts

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'capitalize'
})
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    if (!value) return '';
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}


HTML 

p> {{ 'hello' | capitalize }} /p>  <!-- Output: Hello -->

  </code>
</pre>

      <h2> 2. Shorten Text Pipe </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
shorten.pipe.ts

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'shorten'
})
export class ShortenPipe implements PipeTransform {
  transform(value: string, limit: number = 10): string {
    if (!value) return '';
    return value.length > limit ? value.substring(0, limit) + '...' : value;
  }
}

Use in HTML 

p> {{ 'Angular is awesome!' | shorten:7 }}  /p>  <!-- Output: Angular... -->

  </code>
</pre>

      <h2> 3. Multiply Number Pipe </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'multiply'
})
export class MultiplyPipe implements PipeTransform {
  transform(value: number, factor: number): number {
    return value * factor;
  }
}

// Use in HTML 

p> {{ 5 | multiply:3 }} /p>  <!-- Output: 15 -->

  </code>
</pre>

      <br>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      Uppercase: {{ 'hello world' | uppercase }}

today: Date = new Date();
&lt;p&gt;Full Date: {{ today | date:'fullDate' }}&lt;/p&gt;

========== 

    import { Pipe, PipeTransform } from '@angular/core';
 @Pipe({
  name: 'tranformpipe'
})
export class TranformpipePipe implements PipeTransform {
  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }
}

  </code>
</pre>

      <br>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>

 <strong> custom Pipe, PipeTransform </strong>

pipeTransform use - PipeTransform is an interface from the @angular/core package that allows you to create custom pipes. 
transform(value: string): string
----------- 

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'genderTitle'
})

export class GenderTitlePipe implements PipeTransform {

  transform(value: string, gender: string): string {
    if (gender.toLowerCase() === 'male') {
      return 'Mr. ' + value;
    } else {
      return 'Miss. ' + value;
    }
  }

}

    {{employee.name | genderTitle:employee.gender }}

    </code>
  </pre>


      <p> <strong> FILTER IMPURE PIPE EXAMPLES </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      pure: false
      transform(items: any[], searchText: string): any[] {
        if (!items || !searchText) {
          return items;
        }
        return items.filter(item =>
          item.toLowerCase().includes(searchText.toLowerCase())
        );

        <strong>   use in component </strong>
        searchText: string = '';
        i     tems: string[] = ['Angular', 'React', 'Vue', 'Svelte'];
        <strong> use in template </strong>
        input type="text" [(ngModel)]="searchText" placeholder="Search..." />
        ul>
          li *ngFor="let item of items | filterItems:searchText">
            {{ item }}
          /li>
        /ul>
    </code>
  </pre>


      <h2> <strong> Impure Pipe: filterByProperty </strong> </h2>

      <pre>
    <code>
      filter-by-property.pipe.ts

      import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filterByProperty',
  pure: false //  Impure Pipe
})
export class FilterByPropertyPipe implements PipeTransform {
  transform(items: any[], property: string, value: any): any[] {
    if (!items || !property || value === undefined || value === null) return items;
    return items.filter(item => item[property] === value);
  }
}

// HTML 
tr *ngFor="let user of users | filterByProperty: 'role': 'admin'">
  td>{{ user.name }} /td>
/tr>
    </code>
  </pre>

      2. Pure Version Using Component Filtering + trackBy

      <pre>
    <code>
      //app.component.ts 

  export class AppComponent {
  users = [
    { id: 1, name: 'John', role: 'admin' },
    { id: 2, name: 'Jane', role: 'user' },
    { id: 3, name: 'Mike', role: 'admin' }
  ];

  selectedRole = 'admin';

  get filteredUsers() {
    return this.users.filter(user => user.role === this.selectedRole);
  }

  trackById(index: number, item: any) {
    return item.id;
  }
}

//html 
tr *ngFor="let user of filteredUsers; trackBy: trackById">
  td>{{ user.name }} /td>
/tr>


    </code>
  </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="global-variable">
      <h2> Using a Global Variable for data transfer </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        ts - let sharedData: any;
        Sender - sendData() {
          sharedData = "Data from Sender";
        }
        Receive - receivedData = sharedData;
      </code>
    </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="spying">
      <h2> Spying on a Method in Angular (Jasmine & SpyOn) </h2>
      <p>
      <p> <strong> jASMINE - </strong></p>
      Jasmine is a behavior-driven development (BDD) framework for testing JavaScript applications. <br>
      It does not depend on any external libraries and is commonly used for unit testing in Angular. <br>
      In Angular unit testing, spying on methods is a common practice to track method calls, prevent actual execution,
      and return mock values. This is done using Jasmine’s spyOn function.
      </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      export class MyComponent {
        myMethod() {
          console.log('Original method executed');
        }
      
        anotherMethod() {
          this.myMethod(); // Calls myMethod internally
        }
      }  
    
     -- Spy on an Observable	
     spyOn(service, 'methodName').and.returnValue(of(fakeData))
    
     --Spy on a service method
     spyOn(service, 'methodName')

    </code>
  </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="chart">
      <h2> CHART IMPLEMENTS </h2>
      <div>
        <p> <strong> Bar chart and Pie chart Installation </strong></p>
        <p> <strong> ng2-charts - v4 support with angular 15 </strong> </p>
        <p> <strong> npm install according to doc </strong></p>
        <p> <strong> Global configuration </strong></p>
        <p> <strong> providers </strong></p>
        <p> <strong> ngcharconfiguration in module </strong></p>
        <p> <strong> code copy markup and ts code </strong> </p>
        <p> <strong> using dependancy --legacy-peer-deps </strong></p>
      </div>
    </div>


    <div class="box shadow p-2 mb-3" id="counter">
      <h2> Counter </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
1. ng generate component counter

2. counter.component.ts
   import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  templateUrl: './counter.component.html',
})
export class CounterComponent {
  count = 0;

  increment() {
    this.count++;
  }

  decrement() {
    this.count--;
  }
}

============

3. counter.component.html

div style="text-align: center; margin-top: 50px;">
  h2>Counter Example /h2>
  h3>{{ count }} /h3>
  button (click)="increment()">+ /button>
  button (click)="decrement()">- /button>
/div>

----------

4. Use this component in app.component.html
app-counter> /app-counter>

    </code>
  </pre>

    </div>


    <div class="box shadow p-2 mb-3" id="dynamicInput">
      <h2> Dynamic Input Field Add More </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      1. ng generate component dynamic-input

      2. dynamic-input.component.ts

      import { Component, OnInit } from '@angular/core';
import { FormArray, FormBuilder, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-dynamic-input',
  templateUrl: './dynamic-input.component.html',
})
export class DynamicInputComponent implements OnInit {
  myForm!: FormGroup;

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.myForm = this.fb.group({
      inputs: this.fb.array([this.fb.control('')]) // default one input field
    });
  }

  get inputs(): FormArray {
    return this.myForm.get('inputs') as FormArray;
  }

  addInput(): void {
    this.inputs.push(this.fb.control(''));
  }

  removeInput(index: number): void {
    this.inputs.removeAt(index);
  }

  onSubmit(): void {
    console.log(this.myForm.value);
  }
}

--------------

3. dynamic-input.component.html

div style="padding: 20px;">
  form [formGroup]="myForm" (ngSubmit)="onSubmit()">
    div formArrayName="inputs">
      div *ngFor="let input of inputs.controls; let i = index">
        input [formControlName]="i" placeholder="Enter value {{ i + 1 }}" />
        button type="button" (click)="removeInput(i)" *ngIf="inputs.length > 1"> Remove /button>
      /div>
    /div>

    button type="button" (click)="addInput()">Add More /button>

    button type="submit"> Submit /button>
  /form>
/div>

    </code>
  </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="routeguards">
      <h2> Route Guards in Angular </h2>
      <p> Angular Guards are services that control access to routes in an Angular application. They are used to protect
        routes from unauthorized access or to prevent unwanted navigation. Common types of guards include: </p>
      <ul>
        <li> CanActivate: Protect Route Access <br> CanActivate is used to determine whether a user can navigate to a
          specific route or not. It runs before the route is loaded. </li>
        <li> CanDeactivate: Prevent Leaving the Route <br> CanDeactivate is used to ask the user before navigating away
          from a component, typically if a form is dirty/unsaved </li>
        <li> CanLoad: Determines if a module can be loaded lazily. </li>
      </ul>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      constructor(private router: Router) {}
      canActivate(): boolean {
        const isLoggedIn = !!localStorage.getItem('user');
        if (!isLoggedIn) {
          this.router.navigate(['/login']); // Redirect to login if not authenticated
          return false;
        }
        return true;
      }
    </code>
  </pre>
      <p> <strong> Applying Route Guard to Routes </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      const routes: Routes = [
    { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] }
  ];
    </code>
  </pre>

      <h2> Dynamic Menu </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      TS
      role = 'admin'; // or 'client'

menus_list = [
  {
    title: 'Admin Dashboard',
    icon: 'bx bx-user',
    link: '/admin-dashboard',
    role: 'admin'
  },
  {
    title: 'User details',
    icon: 'bx bx-user',
    link: '/user-details',
    role: 'admin'
  },
  {
    title: 'Services Manage',
    icon: 'bx bx-user',
    link: '/services-manage',
    role: 'admin'
  },
  {
    title: 'Client Dashboard',
    icon: 'bx bx-user',
    link: '/client-dashboard',
    role: 'client'
  },
  {
    title: 'Profile',
    icon: 'bx bx-user',
    link: '/profile',
    role: 'client'
  },
  {
    title: 'Client Leads',
    icon: 'bx bx-user',
    link: '/client-leads',
    role: 'client'
  }
];

// Filtered menu based on role
get filteredMenus() {
  return this.menus_list.filter(item => item.role === this.role);
}


HTML 

ul>
  li *ngFor="let menu of filteredMenus">
    a [routerLink]="menu.link">
      <i [class]="menu.icon"></i> {{ menu.title }}
    /a>
  /li>
/ul>

    </code>
  </pre>


    </div>


    <div class="box shadow p-2 mb-3" id="di">
      <h2> Dependency Injection (DI) in Angular </h2>

      <p> <strong> Dependency Injection in Angular means providing a class its dependencies (like services) from outside
          rather than creating them itself. </strong></p>
      <h2> How it Works </h2>
      1. Create a Service (Dependency) <br>
      A service contains logic or data that you want to use across components.

      <h2> Simple Example in Angular </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    1. Create a Service (Dependency)

    // logger.service.ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class LoggerService {
  log(message: string) {
    console.log('Log:', message);
  }
}

2. Inject Service in Component

// user.component.ts
import { Component } from '@angular/core';
import { LoggerService } from './logger.service';

@Component({
  selector: 'app-user',
  template: ``
})
export class UserComponent {
  constructor(private logger: LoggerService) {}
  createUser() {
    this.logger.log('User created');
  }
}

=========

HTML 
button (click)="createUser()"> Create User /button>

  </code>
</pre>
      <p> Now Angular will automatically inject an instance of LoggerService into UserComponent. </p>

      <h2> How Dependency Injection Works in Angular </h2>
      <ol>
        <li> You mark a class as @Injectable. </li>
        <li> Angular maintains a container (Injector). </li>
        <li> When a component needs a service, Angular looks into the container. </li>
        <li> Angular creates and injects the dependency when needed. </li>
      </ol>

      <h2> <strong> What does providedIn: 'root' do in Angular? </strong> </h2>

      <P>
        "providedIn: 'root' registers the service with the root injector automatically, making it a singleton throughout
        the app. It's part of Angular's tree-shakable providers system, reducing boilerplate and improving performance
        by only including the service in the bundle if it's actually used."
      </P>
      <ul>
        <li> providedIn: 'root' tells Angular to automatically create and provide the service in the root injector
          (i.e., application-wide). </li>
        <li> So you don’t need to add the service manually in the providers array of any module. </li>
      </ul>

      <h2> <strong> How it works: </strong></h2>
      <ul>
        <li> Angular creates a single instance (singleton) of the service and shares it across the whole app. </li>
        <li> This is part of tree-shakable providers — Angular only includes the service if it’s used somewhere. </li>
      </ul>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    @Injectable({
  providedIn: 'root'  // Angular will create a single instance (singleton)
})
export class UserService {
  getUser() {
    return 'John Doe';
  }
}
  </code>
</pre>
      2. Inject Service into a Component <br>
      You "inject" the service into the component’s constructor.

      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
@Component({...})
export class UserComponent {
  constructor(private userService: UserService) {}

  ngOnInit() {
    console.log(this.userService.getUser());
  }
}

</code></pre>

      <p> DI is a design pattern in Angular used for managing dependencies (services, components, etc.). <br>
        * Instead of creating objects manually, Angular injects them automatically. <br>
        * Uses @Injectable() decorator for services. <br>
        <strong> => Create Serives </strong>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
      getData() {
        return ['Angular', 'React', 'Vue'];
      }
      <strong> => Inject the Service into a Component </strong>
      frameworks: string[];
      constructor(private dataService: DataService) {  // 🔹 Inject Service Here
        this.frameworks = this.dataService.getData();
      }
      {{ frameworks }}
    </code></pre>
    </div>



    <div class="box shadow p-2 mb-3 mt-5" id="form">
      <h2> <strong> Angular Form </strong> </h2>
      <p> Angular, there are three main types of forms : </p>

      <h2> <strong> 1. Template-Driven Forms </strong></h2>
      <ul>
        <li> Built in the template (HTML) using Angular directives like [(ngModel)]. </li>
        <li> Suitable for simple forms. </li>
        <li> Uses FormsModule. </li>
        <li class="mt-2"> <strong> Features: </strong></li>
        <li> Easy to use and understand </li>
        <li> Two-way data binding </li>
        <li> Validation via HTML and Angular directives </li>
      </ul>
      <p class="mt-2"> <strong> Example </strong></p>
      <pre>
  <code>
    form #form="ngForm">
      input name="username" [(ngModel)]="username" required>
    /form>
  </code>
</pre>

      <h2 class="mt-4"> <strong> 2. Reactive Forms (Model-Driven Forms) </strong></h2>
      <p> These forms are built in the component class using FormGroup, FormControl, and FormBuilder, </p>
      <ul>
        <li> Built in the component class using FormGroup, FormControl, and FormBuilder. </li>
        <li> Suitable for complex or dynamic forms. </li>
        <li> Uses ReactiveFormsModule. </li>
        <li class="mt-2"> <strong> Features : </strong></li>
        <li> More scalable and testable </li>
        <li> Fine-grained control </li>
        <li> Powerful validation and state tracking </li>
        <li> Uses RxJS observables </li>
      </ul>

      <h2> <strong> Key Building Block </strong></h2>
      <ul>
        <li> <strong> FormControl </strong> – tracks the value and validation of an individual input. </li>
        <li> <strong> FormGroup </strong> – groups multiple FormControls. </li>
        <li> <strong> FormBuilder </strong> – a helper service to simplify form creation. </li>
        <li> <strong> Validators </strong> – used for form validation (e.g., required, minlength). </li>
      </ul>

      <p class="mt-2"> Example </p>
      <pre>
<code>
TS 
loginForm = {
userform : ['', Validators.required]
}

HTML 

form [formGroup]="loginForm">
  input formControlName="username">
/form>
</code>
</pre>


      <h2 class="mt-4"> Restrict only numbers in an input field </h2>
      <p> Using Validators.pattern with Reactive Forms </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';

@Component({
  selector: 'app-number-input',
  templateUrl: './number-input.component.html',
})
export class NumberInputComponent {
  form: FormGroup;

  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      numberField: ['', [Validators.required, Validators.pattern('^[0-9]*$')]],
    });
  }

  get numberField() {
    return this.form.get('numberField');
  }
}


//html
form [formGroup]="form">
  input type="text" formControlName="numberField" />
  div *ngIf="numberField?.invalid && numberField?.touched">
    Only numbers are allowed.
  /div>
/form>

  </code>
</pre>

      <h2 class="mt-4"> Method 2: Prevent Non-Numeric Keystrokes (Optional) keypress </h2>
      <pre>
  <code>
    input
  type="text"
  formControlName="numberField"
  (keypress)="allowOnlyNumbers($event)"
/>

//ts
allowOnlyNumbers(event: KeyboardEvent) {
  const charCode = event.which ? event.which : event.keyCode;
  if (charCode < 48 || charCode > 57) {
    event.preventDefault();
  }
}


  </code>
</pre>

      <h2 class="mt-4"> <strong> 3. Dynamic Forms </strong></h2>
      <ul>
        <li> A subtype of Reactive Forms where form fields are generated at runtime, often from a config or API. </li>
        <li class="mt-2"> <strong> Useful for: </strong></li>
        <li> Form builders </li>
        <li> Dynamic UI configurations </li>
      </ul>

      <p class="mt-2"> <strong> Example </strong></p>
      <pre>
  <code>
fields = [
{ type: 'text', name: 'email', label: 'Email' },
{ type: 'password', name: 'password', label: 'Password' }
];
  </code>
</pre>

      <h2 class="mt-4"> <strong> Difference between template-driven and reactive forms? </strong></h2>
      <p> Template-driven forms are defined in the HTML using directives like [(ngModel)]. Reactive forms are defined in
        the component class using FormGroup and FormControl. Reactive forms give more control and are easier to test and
        validate.</p>
      <hr>
      <ul>
        <li>
          <p> .dirty is a property that tells whether the form (or form field) has been modified by the user.
            <br> .dirty is true if the user has changed the form field or form value <br> .dirty is false if the user
            hasn’t touched or changed anything
          </p>
        </li>
        <li> .dirty - User has changed the value </li>
        <li> .touched - User has focused + left the field </li>
        <li> .untouched - User has never interacted with field </li>
      </ul>
    </div>


    <div class="box shadow p-2 mb-3" id="form-crud">
      <h2> FORM validation </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    lead_form!: FormGroup
lead_fields = {
  name     : ['', Validators.required],
  email    : ['', Validators.required],
}
constructor( private _fb    : FormBuilder ){
  this._route.queryParams.subscribe(params => { this.tenant_id = params['id']})
}
ngOnInit(){this.initializeForm()}
initializeForm(){
  this.lead_form = this._fb.group(this.lead_fields)
  this.getLeads()
}
getLeads(){
  let params = [{"key": "tenant_id", "value": this.tenant_id},{"key": "limit", "value": 100}]
  this._http.get('leads/leads/', params).subscribe((response:any) => {
    this.leads = response;
    this.action = "Add"
  },(error: any) => {this.errorMessage(error)})
} 
  </code>
</pre>

      <h2> crud </h2>

      <p> Full Crud Operation </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    export class CmsComponent {

      @ViewChild('close') closed!: ElementRef
      @ViewChild('close1') close1!: ElementRef
      
      pages: any
      cms_form!: FormGroup
      page: any
      action: string = "Add"
    
        cms_fields = {
        title   : ['', Validators.required],
        slug    : ['', Validators.required] ,
        content : ['', Validators.required]
        }
    
      constructor(
        private _http: HttpSharedService,
        private _fb: FormBuilder,
      ){ this.initializeForm() }
    
      ngOnInit(){this.getPages()}
    
      resetForm(){
        this.action = "Add"
        this.initializeForm()
      }
    
      initializeForm(){this.cms_form = this._fb.group(this.cms_fields)}
    
      getPages(){
        this._http.get('cms').subscribe((response: any) => {
          this.pages = response; 
        }, (error) => {
           console.log(error.messages)
        })
      }
    
      setPage(page: any, action: string){
        this._http.get('cms/'+page.id).subscribe((response:any) => {
          this.page = response;
          this.checkAction(action)
        }, (error) => {
           console.log(error)
        })
      }
    
      addNew(){
        this.resetForm()
      }
    
      checkAction(action: any){
        if(action == 'edit'){
          this.action = 'Edit'
          this.patchPage()
        }
      }
    
      patchPage(){
        this.cms_form.patchValue({
          title    : this.page.title,
          slug     : this.page.slug,
          content  : this.page.content
        })
      }
    
      deactivatePlan(){
        this._http.delete("cms/"+this.page.id).subscribe((response: any) => {
          this.getPages()
          this.resetForm()
          this.close1.nativeElement.click()
          console.log ("Page Deactivated")
        }, (error: any) => {
          console.error('Check--->', error.messages);
        })
      }
    
      setPalyLoad(form: any){
        return {
          title         : form.title,
          slug          : form.slug,
          content       : form.content,
          is_published  : this.page ? this.page.is_active : true,
        }
      }
    
      saveForm(){this.action === "Add" ? this.createPage() : this.updatePage()}
    
      createPage(){
        this._http.post('cms', this.setPalyLoad(this.cms_form.value)).subscribe((response: any) => {
          this.resetForm()
          this.getPages()
          this.closed.nativeElement.click()
          console.log("Page created successfully!")
        }, (error) => {
          console.error("Error:", error);
        })
      }
    
      //forEdit
      updatePage(){
        this._http.put('cms/'+this.page.id, this.setPalyLoad(this.cms_form.value)).subscribe((response: any) => {
          this.resetForm()
          this.getPages()
          this.closed.nativeElement.click()
          console.log("Page updated successfully!")
        }, (error) => {
           console.error("Error", error)
        })
      }
    }
  </code>
</pre>


      <p> <strong> Create </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  createLead(){
    this._http.post('leads/leads/', this.setPayload(this.lead_form.value)).subscribe((response: any) => {
      this.afterAction("Lead Saved")
    },(error: any) => {this.errorMessage(error)})
  }
</code>
</pre>

      <p> <strong> setpayLoad </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    setPayloadForEdit(form: any){
      return {
        "name"     : form.name,
        "email"    : form.email,
      }
    }
  </code>
</pre>

      <p> <strong> Edit </strong></p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code> 
  editLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)}) 
  }
</code>
</pre>

      <p> <strong> Updated Crud </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    updateLead(){
      let params = [{"key": "tenant_id", "value": this.tenant_id}]
      const payload = this.setPayloadForEdit(this.lead_form.value)
      this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
        this.afterAction("Lead Update")
      },(error: any) => {this.errorMessage(error)}) 
    }
  </code>
</pre>

      <p> <strong> Delete Crud </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    deleteLead(){
      let params = [{"key": "tenant_id", "value": this.tenant_id}]
      this._http.delete('leads/leads/'+this.lead_id, params).subscribe((response:any) => {
        this.afterAction("Lead Deleted")
      },(error: any) => {this.errorMessage(error)})
    }
  </code>
</pre>
    </div>


    <div class="box shadow p-2 mb-3" id="graphql">
      <h2> GRAPHQL </h2>
      <p> GraphQL is a powerful alternative to REST for querying and mutating data in Angular applications. It allows
        clients to request exactly the data they need, reducing over-fetching and improving performance.
      </p>
      <p> npm install @apollo/client graphql </p>
      <p> Benefits of Using GraphQL in Angular </p>
      <ul>
        <li> Fetch only the data you need </li>
        <li> Reduce API calls with a single query </li>
        <li> Strongly typed schema </li>
        <li> Real-time updates with subscriptions </li>
      </ul>
    </div>


    <div class="box shadow p-2 mb-3" id="vresion-upgrade">
      <h2> HOW TO UPGRADE OLD VERSION TO NEW VERSION </h2>
      <div>
        => Always backup your project before upgrading. <br>
        => Use Git commits to track changes at each step.<br>
        1. Check the Current Angular Version<br>
        ng version<br>
        2. Update Angular CLI Globally<br>
        npm install -g @angular/cli<br>
        3. ng update @angular/core@16 @angular/cli@16<br>
        4. Update Other Dependencies<br>
        ng update<br>
        -------------
        You should upgrade step by step from Angular 15 → 16 → 17 → 18 → 19 rather than jumping directly from Angular 15
        to Angular 19.<br>
        If You Try Directly Updating from 15 to 19?<br>
        1. dependency conflicts and errors.<br>
        2. Some configurations (like angular.json) might break due to missing intermediate updates.<br>
        3. Third-party libraries might not support Angular 19<br>
      </div>
      <div class="mt-5">
        <h2> During angular project update 15 to 17 version, How to know which third party tools I have to update in
          angular ? </h2>
        <p> review third-party dependencies </p>
        1. Use ng update command<br>
        2. Check official Angular update guide<br>
        3. Look into package.json manually<br>
        4. Run npm outdated, This command shows all outdated packages, including third-party ones:<br>
        Check GitHub Issues or Docs for Major Libs<br>
      </div>
    </div>


    <div class="box shadow p-2 mb-3" id="storage">
      <h2> Local Storage </h2>
      <p> <strong> Local Storage - </strong> Web storage API stores data in our browser, and no any specific time for
        expiration. </p>
      <p> <strong> Session Storage - </strong> In Session Storage also web storage API stores data in our current
        browser and tab. When you close the tab so after that all data is cleared. </p>
      <p> <strong> Cookies - </strong> Small pieces of data stored in the browser and sent to the server with every HTTP
        Request. </p>
      <ul>
        <li> Data remains even after closing/reopening the browser </li>
        <li> Available across all tabs/windows of the same origin </li>
        <li> Storage limit Around 5MB per origin </li>
        <li> Store user preferences, theme settings, authentication tokens, etc. </li>
      </ul>
      <h2> SessionStorage </h2>
      <ul>
        <li> Data is cleared when the browser/tab is closed </li>
        <li> Available only within the same tab </li>
        <li> Store temporary data like form input, session-based UI state, etc. </li>
      </ul>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    // Store data
    localStorage.setItem('username', 'Santosh');
    // Retrieve data
    const username = localStorage.getItem('username');
    console.log(username); // Output: Santosh
    // Remove data
    localStorage.removeItem('username');
    // Clear all data
    localStorage.clear();
  </code>
 </pre>

      <h2> USING SESSION STORAGE </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  sessionStorage.setItem('sessionUser', 'JohnDoe');
 </code></pre>

      Using the Service in a Component
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code> 
  saveData() {
    this.storageService.setLocalStorage('user', { name: 'Santosh', role: 'Admin' });
    this.storageService.setSessionStorage('sessionUser', { name: 'Guest' });
  }
  loadData() {
    const user = this.storageService.getLocalStorage('user');
    const sessionUser = this.storageService.getSessionStorage('sessionUser');
    console.log('Local User:', user);
    console.log('Session User:', sessionUser);
  }
  clearData() {
    this.storageService.clearLocalStorage();
    this.storageService.clearSessionStorage();
  }
</code>
</pre>
      button (click)="saveData()">Save Data</button>
    </div>


    <div class="box shadow p-2 mb-3" id="authentication">
      <p> <strong> Authentication means "Who are you?" </strong></p>
      <p> When you try to log in to an application, you need to prove your identity. For example, if your name is Ram,
        you must provide some credentials (like a username and password) to prove that you are indeed Ram. If the
        credentials match, the system authenticates you and grants access. This process of verifying your identity is
        called Authentication.</p>

      <p> <strong> Authorization means "What are you allowed to do?"</strong> </p>
      <p> Once you're logged into the application, you have access to a database — but can you delete tables, update
        records, insert new data, or are you limited to just read only ? This control over what you can or cannot do
        within the system is called Authorization. </p>


      <p> <strong> Authentication </strong> Who are you? (Login verification) </p>
      <p> <strong> Authorization </strong> What are you allowed to do? (Role-based access) </p>

      <p> <strong> Step-by-Step: How Authentication & Authorization Work in Angular </strong></p>
      <h2> 1. User Logs In (Authentication) </h2>
      <ul>
        <li> User fills out login form (email/password). </li>
        <li> Angular sends login data to a backend API. </li>
        <li> Backend validates the credentials and returns a token (usually JWT). </li>
      </ul>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
// auth.service.ts
login(email: string, password: string) {
  return this.http.post('/api/login', { email, password });
}
  </code>
</pre>
      <h2> 🔹 2. Token is Stored (Typically in LocalStorage) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code> // After login success
localStorage.setItem('token', tokenFromServer);
</code>
</pre>
      <h2> 3. Include Token in Future Requests (with HTTP Interceptor) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    // token.interceptor.ts
intercept(req: HttpRequest<any>, next: HttpHandler): Observable HttpEvent<any>> {
  const token = localStorage.getItem('token');
  if (token) {
    req = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` }
    });
  }
  return next.handle(req);
}
  </code>
</pre>
      <h2> 🔹 4. Protect Routes (Authorization) </h2>
      <p> Using Angular Route Guards like AuthGuard to protect certain pages. </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    // auth.guard.ts
canActivate(): boolean {
  return !!localStorage.getItem('token'); // or check user role
}
  </code>
</pre>
      <p> Add guard to routes: </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    {
  path: 'dashboard',
  component: DashboardComponent,
  canActivate: [AuthGuard]
}
  </code>
</pre>
      <h2> 🔹 5. Optional: Role-Based Authorization
        If token contains role info (e.g. admin, user), you can check that too: </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    [Login Form]
     |
     v
[AuthService] --POST--> [Backend API] --Valid--> [JWT Token]
     |
     v
[Store Token in LocalStorage]
     |
     v
[Include Token in Headers via Interceptor]
     |
     v
[Access Protected Route] -- [AuthGuard Checks Token]

  </code>
</pre>


      <p> <strong> LOGIN PROCESS </strong></p>
      <p> Login -> Username and Password -> API CALL -> In Backend match with database -> Verified -> the Provide the
        token - token stores in localStorage by fronted - then each request we have to provide token - backend match
        token that token is correct or not - than login </p>
    </div>


    <div class="box shadow p-2 mb-3" id="jwt">
      <h2> <strong> JWT </strong></h2>
      <p> JWT (JSON Web Token) in Angular is commonly used for authentication and authorization when interacting with a
        backend API. </p>
      <h2> Structural </h2>
      <ul>
        <li> Header – Contains the signing algorithm and token type. </li>
        <li> Payload – Contains the claims (user data, roles, etc.). </li>
        <li> Signature – Used to verify the token’s integrity. </li>
      </ul>

      <h2> <strong> Why JWT in Angular? </strong></h2>
      <ul>
        <li> Authenticate users after login. </li>
        <li> Store the token (typically in localStorage or sessionStorage). </li>
        <li> Attach token in Authorization headers for secure API calls. </li>
        <li> Control access to different parts of the application using guards. </li>
      </ul>

    </div>

    <div class="box shadow p-2 mb-3" id="filter">
      <h2> Filter </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
  ng generate pipe filter
  name: 'filter'
  transform(items: any[], searchText: string): any[] {
    if (!items || !searchText) return items;
    searchText = searchText.toLowerCase();
    return items.filter(item => item.toLowerCase().includes(searchText));
  }

  -------------
  input type="text" [(ngModel)]="searchText" placeholder="Search items..." />
div *ngFor="let item of items | filter:searchText | paginate: { itemsPerPage: 10, currentPage: currentPage }">
  {{ item }}

pagination-controls (pageChange)="currentPage = $event"></pagination-controls>

</code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="pagination">
      <h2> Pagination </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    export class AppComponent implements OnInit {

      items: string[] = [];  // Store 100 items
      pagedItems: string[] = []; // Store items for current page
      pageSize = 10; // Number of items per page
      currentPage = 1; // Current active page
      totalPages = 0; // Total number of pages
    
      ngOnInit() {
        this.createItemsList();
      }
    
      createItemsList(){
        for(let i=1; i<=100; i++){
          this.items.push("Item" +' '+ i)
        }
        <!-- console.log('Check', this.items); -->
        this.totalPages = Math.ceil(this.items.length / this.pageSize);
        this.updatePage();
      }
    
      // Function to update items for the current page
      updatePage() {
        const startIndex = (this.currentPage - 1) * this.pageSize;
        const endIndex = startIndex + this.pageSize;
        this.pagedItems = this.items.slice(startIndex, endIndex);
      }
    
      // Function to change page
      goToPage(page: number) {
        if (page >= 1 && page <= this.totalPages) {
          this.currentPage = page;
          this.updatePage();
        }
      }
    }

    --------- 

    div *ngFor="let item of pagedItems">
      {{ item }}
    div
    div class="pagination">
      button (click)="goToPage(currentPage - 1)" [disabled]="currentPage === 1">Previous</button>
      button *ngFor="let page of [].constructor(totalPages); let i = index"
              (click)="goToPage(i + 1)"
              [class.active]="currentPage === i + 1">
        {{ i + 1 }}
      </button>
      button (click)="goToPage(currentPage + 1)" [disabled]="currentPage === totalPages">Next</button>
    div

  </code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="login-setup">

      <h2> <strong> Login with token-based authentication JWT (JSON Web Token) </strong></h2>
      <ul>
        <li> Authenticate the user via API </li>
        <li> Store the token (in localStorage or sessionStorage) </li>
        <li> Send the token with every protected API request </li>
        <li> Protect routes using Angular Guards </li>
      </ul>

      <h2> <strong> Login with api and username and password </strong> </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Component } from '@angular/core';
import { HttpSharedService } from '../http-shared.service';
import { Router } from '@angular/router';
import { ToastrService } from 'ngx-toastr';
import { response } from 'express';
import { LoaderComponent } from "../loader/loader.component";

@Component({
  selector: 'app-login',
  imports: [CommonModule, ReactiveFormsModule, LoaderComponent],
  templateUrl: './login.component.html',
  styleUrl: './login.component.css'
})
export class LoginComponent {

  loginForm!: FormGroup
  loading: boolean = false

constructor(
  private fb: FormBuilder,
  private http: HttpSharedService,
  private router: Router,
  private toastr: ToastrService
){
}

form_field = {
  username: ['', Validators.required],
  password: ['', Validators.minLength(6)]
}

ngOnInit(){
  this.loginForm = this.fb.group(this.form_field)
  this.login()
  this.pathFakerUser()
}

setPayload(form: any){
  return { 
  username: form.username, 
  password: form.password
}
}

pathFakerUser(){
  this.http.get('','').subscribe((response: any) => {
    this.loginForm.patchValue(
      {"username": "emilys", "password": "emilyspass"}
    )
  })
  // this.loginForm.setValue({
  //   email: 'emilys',
  //   password: 'emilyspass'
  // });
}


login() {
  this.http.post('auth/login', this.setPayload(this.loginForm.value)).subscribe((response: any) => {
    if(response.accessToken){
      sessionStorage.setItem("token", response.accessToken)
      this.toastr.success("Login is successfully.");
      this.router.navigateByUrl('dashboard')
    }  else {
      this.toastr.error("Login failed. No access token received.");
    }
    })
}

}



html 


form class="space-y-4 md:space-y-6" [formGroup]="loginForm" (ngSubmit)="login()">
  div>
      label>Your email label>
      input type="email" name="username" id="email" formControlName="username" placeholder="Username">
        div class="error-message" *ngIf="loginForm.get('username')?.touched && loginForm.get('username')?.hasError('required')"> Username is required. div>
  /div>
  div>
      label for="password">Password label>
      input type="password" name="password" id="password" formControlName="password" placeholder="••••••••" required="">
      div class="error-message" *ngIf="loginForm.get('password')?.touched && loginForm.get('password')?.invalid"> Password is required. div>
  /div>

  button type="submit" class="w-full text-white bg-gray-900 p-3 rounded" [disabled]="loginForm.invalid"> Sign in button >
/form>


  </code>
</pre>



      <h2> Login page Setup </h2>
      <div>
        ng generate component pages/login <br>
        ng generate component pages/dashboard <br>
        ng generate service services/auth <br>
        Auth Guard: Prevents unauthorized users from accessing Dashboard <br>
        -----------------
        Create Authentication Service ( auth.service.ts)
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      constructor(private router: Router) {}
  
  login(username: string, password: string): boolean {
    if (username === 'admin' && password === 'password') {
      localStorage.setItem('isLoggedIn', 'true');
      this.router.navigate(['/dashboard']);
      return true;
    }
    return false;
  }
  
  logout() {
    localStorage.removeItem('isLoggedIn');
    this.router.navigate(['/login']);
  }
  
  isAuthenticated(): boolean {
    return localStorage.getItem('isLoggedIn') === 'true';
  }
    </code>
  </pre>

        <h2> login.component.ts </h2>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    username: string = '';
    password: string = '';
    errorMessage: string = '';
    constructor(private authService: AuthService) {}
    login() {
      if (!this.authService.login(this.username, this.password)) {
        this.errorMessage = 'Invalid credentials!';
      }
    }
  </code>
</pre>

        <h2> login.component.html </h2>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    input type="text" placeholder="Username" [(ngModel)]="username" />
    input type="password" placeholder="Password" [(ngModel)]="password" />
    button (click)="login()">Login</button>
    p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>
  </code>
</pre>

        <h2> dashboard.component.ts: </h2>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    constructor(private authService: AuthService) {}
    logout() {
      this.authService.logout();
    }
  </code>
</pre>
        <h2> dashboard.html </h2>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      <div class="dashboard-container">
        <h2>Welcome to Dashboard</h2>
        button (click)="logout()">Logout</button>
      </div>
    </code>
  </pre>

        <h2> Login with DUMMY API </h2>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      loginForm!: FormGroup
      show_password: boolean = false
    
      constructor(
        private fb: FormBuilder,
        private http: HttpSharedService,
        private toastr: ToastrService,
        private _common: CommonService
      ){}
    
      form_field = {
        email: ['', Validators.required],
        password: ['', Validators.required]
      }
    
      ngOnInit(){
        this.loginForm = this.fb.group(this.form_field)
    
        let domain = window.location.hostname; // e.g. "example.com"
        sessionStorage.setItem('domain', domain);
        console.log('Stored domain:', domain);
    
    
      }
      togglePassword(){ this.show_password = !this.show_password}
      setPayload(form: any){return { email: form.email, password: form.password}}
    
      login() {
    
        if(this.loginForm.value.email!="admin@yopmail.com"){
          
          this.toastr.warning("Only Admin Login is allowed here!")
          return
        }
    
        this.http.post('users/login', this.setPayload(this.loginForm.value)).subscribe((loginResponse: any) => {
          console.log(loginResponse)
          if (loginResponse.detail) {
            this.toastr.error(loginResponse.detail)
          } else {
            this._common.setSessionData(loginResponse)
          }
        }, (error: any) => {
          console.log("error", error)
          this.toastr.error("Invalid Details")
        })
      }

      ---------------

      HTML 

      form [formGroup]="loginForm" (ngSubmit)="login()" class="row g-3">
        div class="col-12">
          label for="inputEmailAddress" class="form-label">Email/label>
          input type="email" class="form-control" id="inputEmailAddress" placeholder="jhon@example.com"
            formControlName="email">
          div *ngIf="(!loginForm?.get('email')?.valid && loginForm?.get('email')?.touched )"
            class="text-danger mt-1" style="text-align: left;">
            Please enter email
          /div>
        /div>
        div class="col-12">
          label for="inputChoosePassword" class="form-label">Password /label>
          div class="input-group" id="show_hide_password">
            input [type]="show_password ? 'text' : 'password'" class="form-control border-end-0" formControlName="password"
              id="inputChoosePassword" placeholder="Enter Password">
            a (click)="togglePassword()" class="input-group-text bg-transparent">
              i class='bx bx-hide'></i>
            </a>
          /div>
          div *ngIf="(!loginForm?.get('password')?.valid && loginForm?.get('password')?.touched )"
            class="text-danger mt-1" style="text-align: left;">
            Please enter password
          /div>
        /div>
        div class="col-md-6">
          div class="form-check form-switch">
            input class="form-check-input" type="checkbox" id="flexSwitchCheckChecked">
            label class="form-check-label" for="flexSwitchCheckChecked">Remember
              Me</label>
          /div>
        /div>
        div class="col-md-6 text-end"> a routerLink="/forgot-password" class="linkbtn">Forgot
            Password ? /a>
        /div>
      div class="col-12">
          div class="d-grid">
            button [disabled]="!loginForm.valid" type="submit" class="btn btn-light">Login /button>
          /div>
        /div>
      
    /form>

    </code>
  </pre>

      </div>
    </div>


    <div class="box shadow p-2 mb-3" id="register-setup">
      <h2> Register Setup </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    1. Create a Register Component
    ng generate component register
    -----------
    2. Update register.component.html

      div class="container">
      h2>Register /h2>
      form [formGroup]="registerForm" (ngSubmit)="onSubmit()">
        div>
          input formControlName="name" type="text" />
        /div>
        div>
          input formControlName="email" type="email" />
        /div>
        div>
          input formControlName="password" type="password" />
        /div>
        button type="submit">Register /button>
      /form>
    /div>

    -----------
    3. Update register.component.ts

    import { Component, OnInit } from '@angular/core';
    import { FormBuilder, FormGroup, Validators } from '@angular/forms';

@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
})
export class RegisterComponent implements OnInit {
  registerForm!: FormGroup;

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.registerForm = this.fb.group({
      name: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      password: ['', Validators.required],
    });
  }

  onSubmit(): void {
    if (this.registerForm.valid) {
      console.log('Form Data:', this.registerForm.value);
      alert('Registered successfully!');
    } else {
      alert('Please fill in all fields correctly.');
    }
  }
}

---------- 
4. Add Route to Register page 

const routes: Routes = [
  { path: 'register', component: RegisterComponent },
  { path: '', redirectTo: 'register', pathMatch: 'full' }, // default route
];

---- End ------- 

* To Save the Register Data, You Have Two Options:

1. Temporary Save in localStorage (Browser)

onSubmit(): void {
  if (this.registerForm.valid) {
    const userData = this.registerForm.value;
    localStorage.setItem('user', JSON.stringify(userData));
    alert('Registered successfully!');
  } else {
    alert('Please fill in all fields correctly.');
  }
}

----------- 

2. Permanent Save via Backend API

 (a) user.service.ts 

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}

  registerUser(userData: any) {
    return this.http.post('http://localhost:3000/users', userData);
  }
}

(b) Call in Component:

constructor(private fb: FormBuilder, private userService: UserService) {}

onSubmit(): void {
  if (this.registerForm.valid) {
    this.userService.registerUser(this.registerForm.value).subscribe(() => {
      alert('User registered successfully!');
    });
  }
}

  </code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="material">
      <h2> Angular Material </h2>
      <p>  ng add @angular/material </p>
      <p> Angular Material is a User Interface (UI) component library that we can use in their Angular projects to speed
        up the development of consistent user interfaces.</p>
      <p> Angular Material offers you reusable and beautiful UI components like Cards, Inputs, Data Tables, Datepickers,
      </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      mat-card>
        mat-card-title>SVG Line Reveal Animation /mat-card-title>
        mat-card-content>
        sfdgsdfg
        /mat-card-content>
      /mat-card>
    </code>
  </pre>

      <p class="mt-4"> <strong> Modal angular </strong></p>
      <ul>
        <li> Use MatDialog to create and control modals. </li>
        <li> Dialogs are regular Angular components. </li>
        <li> You can pass data to and receive data from modals. </li>
        <li> Ideal for confirmation dialogs, forms, and popups. </li>
      </ul>

      <p> install Angular Material using the Angular CLI: ng add @angular/material </p>

      <p> <strong> What is a Material Module and why do we use a separate one ? </strong> </p>
      <p> Creating a separate MaterialModule is a common practice where we import and export all required Material
        components in one module and reuse it across the app. This improves modularity and code cleanliness. </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code> @NgModule({
  exports: [
    MatButtonModule,
    MatInputModule,
    MatCardModule
  ]
})
export class MaterialModule {}
</code>
</pre>

      <p class="mt-4"> <strong> How is Angular Material different from Bootstrap ? </strong> </p>

      <table>
        <tr>
          <td> Angular Material </td>
          <td> Bootstrap </td>
        </tr>
        <tr>
          <td> Based on Material Design <br> Deeply integrated <br> Angular-specific </td>
          <td> Based on custom grid system <br> Requires manual integration <br> HTML/CSS/JS </td>
        </tr>
      </table>


      <p class="mt-4"> <strong> What are some commonly used Angular Material components? </strong> </p>
      <table>
        <tr>
          <td> MatInput – For input fields </td>
          <td> MatButton – For buttons </td>
        </tr>
        <tr>
          <td> MatDialog – Modal popups </td>
          <td> MatTable – Data tables </td>
        </tr>
        <tr>
          <td> MatCard – For card layout </td>
          <td> MatToolbar – Top app bar </td>
        </tr>
        <tr>
          <td> MatPaginator & MatSort – Table features </td>
          <td> MatFormField – Form controls wrapper </td>
        </tr>
        <tr>
          <td> MatSelect – Dropdown/select control </td>
          <td> </td>
        </tr>
      </table>

      <p class="mt-4"> <strong> How do you use Angular Material Dialog? </strong> </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
Open Dialog: ts 
constructor(private dialog: MatDialog) {}
openDialog() {
  this.dialog.open(DialogComponent);
}
  </code>
</pre>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    Dialog Component:
    @Component({
  selector: 'app-dialog',
  template: `h2 mat-dialog-title>Hello /h2>`
})
export class DialogComponent {}
  </code>
</pre>

      <p class="mt-4"> <strong> What is MatFormField and how is it used? </strong></p>
      MatFormField is a wrapper for form controls to apply Material styling, floating labels, and error messages.
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>

mat-form-field>
  mat-label>Email  /mat-label>
  input matInput placeholder="Enter email">
/mat-form-field>

  </code>
</pre>

<p> <strong> How do you implement Angular Material Table with pagination and sorting? </strong></p>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
ng add @angular/material

//app.module.ts 

import { MatTableModule } from '@angular/material/table';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatSortModule } from '@angular/material/sort';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';

@NgModule({
  imports: [
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatInputModule,
    MatFormFieldModule,
  ],
})
export class AppModule {}

//table-example.component.html

div class="mat-elevation-z8">
  table mat-table [dataSource]="dataSource" matSort class="full-width-table">

    <!-- ID Column -->
    ng-container matColumnDef="id">
      th mat-header-cell *matHeaderCellDef mat-sort-header>ID /th>
      td mat-cell *matCellDef="let element">{{ element.id }} /td>
    /ng-container>

    <!-- Name Column -->
    ng-container matColumnDef="name">
      th mat-header-cell *matHeaderCellDef mat-sort-header>Name /th>
      td mat-cell *matCellDef="let element">{{ element.name }} /td>
    /ng-container>

    <!-- Email Column -->
    ng-container matColumnDef="email">
      th mat-header-cell *matHeaderCellDef mat-sort-header>Email /th>
      td mat-cell *matCellDef="let element">{{ element.email }} /td>
    /ng-container>

    tr mat-header-row *matHeaderRowDef="displayedColumns"> /tr>
  tr mat-row *matRowDef="let row; columns: displayedColumns;"> /tr>
  /table>

  mat-paginator [pageSizeOptions]="[5, 10, 20]" showFirstLastButtons> /mat-paginator>
/div>


//table-example.component.ts
import { Component, ViewChild, AfterViewInit } from '@angular/core';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';

export interface UserData {
  id: number;
  name: string;
  email: string;
}

const USER_DATA: UserData[] = [
  { id: 1, name: 'John Doe', email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  { id: 3, name: 'Michael Brown', email: 'michael@example.com' },
  // Add more data here
];

@Component({
  selector: 'app-table-example',
  templateUrl: './table-example.component.html',
})
export class TableExampleComponent implements AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'email'];
  dataSource = new MatTableDataSource(USER_DATA);

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }
}




</code>
</pre>


      <p class="mt-4"> <strong> How to change theme or apply custom themes in Angular Material? </strong></p>
      <p> Angular Material supports predefined themes like indigo-pink, deeppurple-amber, etc. You can also define a
        custom theme in SCSS: </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    @use '@angular/material' as mat;

$my-theme: mat.define-light-theme((
  color: (
    primary: mat.define-palette(mat.$orange-palette),
    accent: mat.define-palette(mat.$cyan-palette),
  )
));

@include mat.all-component-themes($my-theme);

  </code>
</pre>

      <p> <strong> Can Angular Material be used with Reactive Forms? </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>

  form [formGroup]="form">
  mat-form-field>
    mat-label>Username /mat-label>
    input matInput formControlName="username">
  /mat-form-field>
/form>

</code></pre>


      <h2> ✅ 1. Material Dialog with Data (Open, Close, Pass Data) </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    ts  Trigger Component

import { MatDialog } from '@angular/material/dialog';
import { MyDialogComponent } from './my-dialog.component';

constructor(private dialog: MatDialog) {}

openDialog() {
  const dialogRef = this.dialog.open(MyDialogComponent, {
    data: { name: 'Santosh', role: 'Developer' }
  });

  dialogRef.afterClosed().subscribe(result => {
    console.log('Dialog closed with:', result);
  });
}

============

ts Dialog  component 

@Component({
  selector: 'app-my-dialog',
  template: `
    h2 mat-dialog-title>Hello {{data.name}} /h2>
    mat-dialog-content>Your role: {{data.role}} /mat-dialog-content>
    mat-dialog-actions>
      button mat-button (click)="close()">Close /button>
    /mat-dialog-actions>
  `
})
export class MyDialogComponent {
  constructor(
    @Inject(MAT_DIALOG_DATA) public data: any,
    private dialogRef: MatDialogRef  MyDialogComponent>
  ) {}

  close() {
    this.dialogRef.close('Confirmed');
  }
}

  </code>
</pre>

    </div>

    <div class="box shadow p-2 mb-3" id="json">
      <h2> Angular Material </h2>
      <p> JSON stands for JavaScript Object Notation. It’s a lightweight data format used to store and exchange data.
        Super common in web development, especially for APIs.</p>
    </div>

    <div class="box shadow p-2 mb-3" id="prime">
      <h2> PrimeNg </h2>
      <p> PrimeNG is a UI component library for Angular. It gives you a bunch of pre-made, beautiful, and customizable
        UI components—so you don’t have to build everything from scratch. </p>
      <p> <strong> What kind of components does PrimeNG have? </strong></p>
      Buttons, checkboxes, sliders, inputs <br>
      Data tables (super powerful) <br>
      Dialogs, tooltips, modals <br>
      Calendars and dropdowns <br>
      Charts and progress bars <br>
      File upload, drag-and-drop, and more <br>
    </div>

    <div class="box shadow p-2 mb-3" id="customuiliberary">
      <h2> Custom UI Component Library (Angular) </h2>
      <ul>
        <li> <strong> What it Means: </strong></li>
        <li> Reusable UI components (like buttons, modals, tables, cards, form controls, etc.) tailored to the company's
          design guidelines. </li>
        <li> These components are packaged into a UI Library Module and used across multiple Angular applications. </li>
        <li> It ensures design consistency, reusability, and customization flexibility. </li>
      </ul>

      <ul>
        <li> <strong> Common Components in a Custom UI Library: </strong></li>
        <li> Buttons, Inputs, Selects </li>
        <li> Modal/Dialogs </li>
        <li> Data Tables </li>
        <li> Cards & Panels </li>
        <li> Form Validation Components </li>
        <li> Notification/Toaster Service </li>
        <li> Custom Layout Grids & Containers </li>
      </ul>


    </div>


    <div class="box shadow p-2 mb-3" id="dom">
      <h2> DOM Manipulation </h2>
      Document Object Model
      <p> <strong> What is DOM Manipulation? </strong></p>
      <p> DOM Manipulation means changing elements, structure, or content of a webpage using JavaScript (or frameworks
        like Angular, React, etc.).
      </p>
      <p> <strong> For example, changing text, styles, adding/removing elements, etc. </strong></p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;"><code>
    // Select an element
let heading = document.getElementById("title");

// Change text
heading.innerText = "New Title";

// Change style
heading.style.color = "blue";

// Create new element
let newPara = document.createElement("p");
newPara.textContent = "This is new!";
document.body.appendChild(newPara);

// Remove element
heading.remove();

  </code></pre>

      <h2> DOM Manipulation in Angular: </h2>
      <ul>
        <li> Data binding to update DOM automatically </li>
        <li> Structural directives like *ngIf, *ngFor to add/remove content </li>
        <li> Renderer2 for safe DOM access (used in services or advanced use cases) </li>
      </ul>

    </div>

    <div class="box shadow p-2 mb-3" id="test">
      <h2> Angular Test Casing What is Jasmine? </h2>
      <p> Jasmine is a behavior-driven testing framework for JavaScript.
        and Karma Test Runner and watch
      </p>

      <ul>
        <li> <strong> describe() – </strong> defines a test suite (group of tests) </li>
        <li> <strong> it() – </strong>defines a single test/spec </li>
        <li> <strong> expect() – </strong> assertion to test result </li>
      </ul>

      <h2> Common Function </h2>
      <strong> describe() </strong> Groups related test specs <br>
      <strong> it() </strong> Defines a single test case <br>
      <strong> beforeEach() </strong> Runs before each test <br>
      <strong> expect() </strong> Makes an assertion <br>
      <strong> toBe() </strong> Checks strict equality (===) <br>
      <strong> toEqual() </strong> Checks deep equality (objects) <br>
      <strong> toContain() </strong> Checks if a string/array contains <br>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
      <code>
        num1 = 0;
        num2 = 0;

        result = 0;

        onAdd(){
          this.result = Number(this.num1) + Number(this.num2);
        }

        in - spec.ts 
        it("should get result onAdd", () => {
          component.num1 = 4;
          component.num2 = 5;
          component.onAdd();
          except(component.result).toBe(9)
        })

      </code>
    </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="interceptor">
      <h2> Interceptor </h2>
      <p> An interceptor in Angular is a special service. It is allows to intercept and manipulate HTTP requests and
        responses globally before they are sent or received. </p>
      <p> Authorization headers, Loading indicators, Logging, Error handling, Modifying requests/responses </p>
      <h2> How It works </h2>
      <p> Angular provides an interface called HttpInterceptor, which you can implement in a service. Then, you register
        that service as an HTTP interceptor in the provider’s array. </p>

      <h2> Add a Token to Every Request </h2>
      1. Create the interceptor service
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    // auth.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = localStorage.getItem('authToken');

    if (token) {
      const cloned = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
      return next.handle(cloned);
    } else {
      return next.handle(req);
    }
  }
}
  </code>
</pre>
      2. Provide it in you app.module.ts
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { AuthInterceptor } from './auth.interceptor';

@NgModule({
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true
    }
  ]
})
export class AppModule {}
  </code>
</pre>

      <p> You Can Chain Multiple Interceptors
        Just add more entries to the providers array with multi: true. </p>

      <h2> 1. Global Error Handling Interceptor </h2>
      <p> This interceptor catches HTTP errors and lets you handle them in one place (like showing a toast, redirecting
        on 401, etc.) </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
      // error.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = 'An unknown error occurred!';

        if (error.status === 401) {
          errorMessage = 'Unauthorized. Redirecting to login...';
          // Optionally redirect:
          // this.router.navigate(['/login']);
        } else if (error.status === 500) {
          errorMessage = 'Internal server error!';
        } else if (error.error?.message) {
          errorMessage = error.error.message;
        }

        // Show a toast/snackbar here (example with alert)
        alert(errorMessage);

        return throwError(() => new Error(errorMessage));
      })
    );
  }
}

    </code>
  </pre>

    </div>



    <div class="box shadow p-2 mb-3" id="reusable">
      <h2> Reusable Component </h2>
      <h2> show more </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
// show-more.component.ts
import { Component, Input, booleanAttribute, signal } from '@angular/core';

@Component({
  selector: 'app-show-more',
  standalone: true,
  template: `
    div>
      p>{{ isExpanded() ? text : (text | slice:0:maxLength) + '...' }} /p>
      button (click)="toggle()" class="text-blue-500 hover:underline">
        {{ isExpanded() ? 'Show less' : 'Show more' }}
      /button>
    /div>
  `,
})
export class ShowMoreComponent {
  @Input({ required: true }) text = '';
  @Input({ transform: booleanAttribute }) expanded = false;
  @Input({ transform: (value: string | number) => +value }) maxLength = 100;
  
  isExpanded = signal(this.expanded);

  toggle() {
    this.isExpanded.update(v => !v);
  }
}


  <!-- ShowMore Example -->
    app-show-more 
      [text]="longText" 
      [maxLength]="50" 
      [expanded]="false"
    />

  </code>
</pre>
    </div>


    <div class="box shadow p-2 mb-3" id="datapush">
      <h2> Simple Data Push </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
TS--- 
import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-console-crud',
  imports: [HeaderComponent, ReactiveFormsModule, CommonModule],
  templateUrl: './console-crud.component.html',
  styleUrl: './console-crud.component.css'
})
export class ConsoleCrudComponent {

  emp_form!: FormGroup
  emp_details: any = []

  constructor( private fb: FormBuilder){}

  emp_fields = {
    name : [''],
    email: [''],
    phone: ['']
  }

  ngOnInit(){
    this.initializeForm()
  }

  initializeForm(){
    this.emp_form = this.fb.group(this.emp_fields)
  }

  onSubmit(){
    this.emp_details.push({
      "name" : this.emp_form.value.name,
      "email": this.emp_form.value.email,
      "phone": this.emp_form.value.phone
    })
    console.log(this.emp_form.value)
  }
}

HTML --- 

div class="container mt-5">
form action="" [formGroup]="emp_form" 
(ngSubmit)="onSubmit()">
div class="row">
div class="col-lg-3"> 
input type="text" class="form-control" placeholder="Name" formControlName="name"> /div>
div class="col-lg-3"> 
input type="text" class="form-control" placeholder="Email" formControlName="email"> /div>
div class="col-lg-3"> 
input type="text" class="form-control" placeholder="Phone Number" formControlName="phone"> /div>
div class="col-lg-3"> 
button type="submit" class="btn btn-success"> Submit /button> /div>
/div>
/form>

  table class="table table-bordered mt-5">
  thead>
    tr>
      th> Name /th>
      th> Email /th>
      th> Phone Number /th>
    /tr>
  /thead>
  tbody>
    tr *ngFor="let emp of emp_details">
      td>{{emp.name}}/td>
      td>{{emp.email}}/td>
      td>{{emp.phone}}/td>
    /tr>
  /tbody>
  /table>
/div>
  </code>
</pre>

    </div>


    <div class="box shadow p-2 mb-3" id="empw-api">
      <h2> Employee crud without API </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { Component } from '@angular/core';
import { HeaderComponent } from "../header/header.component";
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
            
@Component({
selector: 'app-dynamic-crud',
imports: [HeaderComponent, CommonModule, FormsModule, ReactiveFormsModule],
templateUrl: './dynamic-crud.component.html',
styleUrl: './dynamic-crud.component.css'
})


export class DynamicCrudComponent {
            
employee_form!: FormGroup
employee_Toggle = false
            
employee_details: any = []
updateRecordId: any
operation: any = "Add"
            
employeeFormToggle(){
this.employee_Toggle = !this.employee_Toggle
}
            
constructor( private fb: FormBuilder){}
            
empform_fields = {
emp_id  : [''],
emp_name: ['', Validators.required],
emp_email:['', Validators.required],
emp_role :['', Validators.required]
}
            
ngOnInit(){ 
this.initializeForm()
let emp_data = localStorage.getItem('employeeData')
if(emp_data){
this.employee_details = JSON.parse(emp_data)
}
}
            
initializeForm(){
this.employee_form = this.fb.group(this.empform_fields)
}
            
saveEmployee() {
if (this.updateRecordId) {
this.updateEmployee();
} else {
this.addEmployee();
}
}
            
addEmployee() {      
const emp_id = (this.employee_details.at(-1)?.id ?? 0) + 1;
this.employee_details.push({
"id"       : emp_id,
"emp_name" : this.employee_form.value.emp_name,
"emp_email": this.employee_form.value.emp_email,
"emp_role" : this.employee_form.value.emp_role
})      
this.resetForm()
this.saveToLocalStorage()
}
            
updateEmployee() {
const found = this.employee_details.filter((empData: 
any) => empData.id == this.updateRecordId);

if (found) {
found[0].emp_name = this.employee_form.value.emp_name;
found[0].emp_email = this.employee_form.value.emp_email;
found[0].emp_role = this.employee_form.value.emp_role;
}
this.saveToLocalStorage();
this.resetForm();
}
              
getDataForEdit(emp_id: any){
this.updateRecordId = emp_id
let data = this.employee_details
.filter((empData: any) => empData.id == emp_id)

this.employee_form.patchValue(data[0])
this.operation = "Update"
this.employee_Toggle = true
}
            
deleteEmployee(emp_id: any){
this.employee_details = this.employee_details
.filter((empData: any) => empData.id != emp_id);

this.saveToLocalStorage();
}
            
resetForm() {
this.employee_form.reset();
this.updateRecordId = null;
this.operation = 'Add';
this.employee_Toggle = false;
}
            
saveToLocalStorage(){
localStorage.setItem('employeeData', 
JSON.stringify(this.employee_details))
}
            
}


=====

HTML 

button (click)="employeeFormToggle()"> {{ !employee_Toggle ? 'Add Employee':'Close Form' }} button

form [formGroup]="employee_form" (ngSubmit)="saveEmployee()" *ngIf="employee_Toggle">
input type="text" class="form-control" formControlName="emp_name" placeholder="Employee Name">
*ngIf="employee_form.get('emp_name')?.touched && employee_form.get('emp_name')?.hasError('required')"> Employee Name is Invalid

button class="btn btn-primary" type="submit" [disabled]="!employee_form.valid"> {{ operation }} Submit /button>

*ngIf="!employee_details.length"  No Data 

table class="table table-bordered mt-3" *ngIf="employee_details.length">
thead>
tr>
th> Employee ID /th>
th> Employee Name /th>
th> Employee Email /th>
th> Employee Role /th>
th> Actions /th>
/tr>
/thead>
tbody>
tr *ngFor="let employee of employee_details">
td> {{employee.id}} /td>
td> {{employee.emp_name}} /td>
td> {{employee.emp_email}} /td>
td> {{employee.emp_role}} /td>
td>
button class="btn btn-sm btn-warning me-2" (click)="getDataForEdit(employee.id)">Edit/button>
button class="btn btn-sm btn-danger" (click)="deleteEmployee(employee.id)">Delete/button>
/td>
/tr>
/tbody>
/table>
</code>
</pre>
      <hr>

      <h2> Only Add and Delete </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code>
            import { CommonModule } from '@angular/common';
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { HeaderComponent } from "../header/header.component";

@Component({
  selector: 'app-emp-data',
  imports: [CommonModule, ReactiveFormsModule, HeaderComponent],
  templateUrl: './emp-data.component.html',
  styleUrl: './emp-data.component.css'
})
export class EmpDataComponent {

  employee_form!: FormGroup

  employee_details: any = []

  employee_fields = {
    emp_id: [''],
    emp_name: ['', Validators.required],
    emp_email: ['', Validators.required],
    emp_phone: ['', Validators.required]
  }

  constructor(private fb: FormBuilder){}

  ngOnInit(){ 
    this.initializeForm() 
    let emp_data = localStorage.getItem('employeeData')
    if(emp_data){
      this.employee_details = JSON.parse(emp_data)
    } 
  }

  initializeForm(){
    this.employee_form = this.fb.group(this.employee_fields)
  }

  saveForm(){ this.addEmployee() }

  addEmployee(){
   
    const emp_id = (this.employee_details.at(-1)?.id ?? 0) + 1;

    this.employee_details.push({
      "id": emp_id,
      "emp_name" : this.employee_form.value.emp_name,
      "emp_email" : this.employee_form.value.emp_email,
      "emp_phone" : this.employee_form.value.emp_phone
    })

    this.saveLocalStorage()

  }

  deleteEmployee(emp_id: any){
    this.employee_details = this.employee_details.filter((empData: any) => empData.id != emp_id)
    this.saveLocalStorage()
  }

  saveLocalStorage(){
    localStorage.setItem('employeeData', JSON.stringify(this.employee_details))
  }

}

HTML

form class="row" [formGroup]="employee_form" (ngSubmit)="addEmployee()">
form>
table class="table table-bordered mt-5">
  thead>
      tr> 
          th scope="col"> Employee Id </th>
          th scope="col"> Employee Name </th>
          th scope="col"> Employee Email </th>
          th scope="col"> Employee Phone </th>
      /tr>
  /thead>
  tbody>
      tr *ngFor="let employee of employee_details">
          td> {{employee.id}} </td>
          td> {{employee.emp_name}} </td>
          td> {{employee.emp_email}} </td>
          td> {{employee.emp_phone}} </td>
          td> button (click)="deleteEmployee(employee.id)" class="btn btn-danger"> Delete </button></td>
      /tr>
  /tbody>
/table>
          </code>
        </pre>

      <h2> Crud Operation with Static Data </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code>
            import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-crud-lg-practise',
  imports: [HeaderComponent, ReactiveFormsModule, FormsModule, CommonModule],
  templateUrl: './crud-lg-practise.component.html',
  styleUrl: './crud-lg-practise.component.css'
})
export class CrudLgPractiseComponent {

  emp_form!: FormGroup;
  emp_details = [
    {
      emp_id: 1,
      emp_name: "Achyut Kadam Singh",
      emp_email: "achyut@gmail.com",
      emp_role: "WebDeveloper"
    },
    {
      emp_id: 2,
      emp_name: "Gorakh Sans",
      emp_email: "gorakh@gmail.com",
      emp_role: "Fullstack Developer"
    },
    {
      emp_id: 3,
      emp_name: "Achyut Kadam",
      emp_email: "achyut@gmail.com",
      emp_role: "Senior webDeveloper"
    }
  ];
  empUpdateid: number | null = null;

  constructor(private fb: FormBuilder) {}

  emp_fields = {
    emp_id: [''],
    emp_name: ['', Validators.required],
    emp_email: ['', Validators.required],
    emp_role: ['', Validators.required]
  };

  ngOnInit() {
    this.intializeForm();
  }

  intializeForm() {
    this.emp_form = this.fb.group(this.emp_fields);
  }

  resetForm() {
    this.intializeForm();
    this.empUpdateid = null;
  }

  saveEmployeeData() {
    if (this.empUpdateid !== null) {
      this.empUpdate();
    } else {
      this.createEmp();
    }
  }

  createEmp() {
    const newId = this.emp_details.length > 0
      ? Math.max(...this.emp_details.map(emp => emp.emp_id)) + 1
      : 1;

    this.emp_details.push({
      emp_id: newId,
      emp_name: this.emp_form.value.emp_name,
      emp_email: this.emp_form.value.emp_email,
      emp_role: this.emp_form.value.emp_role
    });

    this.resetForm();
  }

  empUpdate() {
    const index = this.emp_details.findIndex(emp => emp.emp_id === this.empUpdateid);
    if (index > -1) {
      this.emp_details[index].emp_name = this.emp_form.value.emp_name;
      this.emp_details[index].emp_email = this.emp_form.value.emp_email;
      this.emp_details[index].emp_role = this.emp_form.value.emp_role;
    }

    this.resetForm();
  }

  empUpdateEdit(emp_id: number) {
    this.empUpdateid = emp_id;
    const emp = this.emp_details.find(emp => emp.emp_id === emp_id);
    if (emp) {
      this.emp_form.patchValue(emp);
    }
  }

  deleteEmp(emp_id: number) {
    this.emp_details = this.emp_details.filter(emp => emp.emp_id !== emp_id);
    this.resetForm();
  }
}

-------------- 
HTML 
--------------- 

<div class="container">

        form [formGroup]="emp_form" (ngSubmit)="saveEmployeeData()">
          div class="row m-auto"> 
          div class="col-lg-3"> 
          input type="text" class="form-control" formControlName="emp_name" placeholder="Employee Name">
          div class="error" *ngIf="emp_form.get('emp_name')?.touched && emp_form.get('emp_name')?.hasError('required')"> Employee Name is Invalid /div>
          /div>
  
          div class="col-lg-3">  
          input type="text" class="form-control" formControlName="emp_email" placeholder="Employee Email">
          div class="error" *ngIf="emp_form.get('emp_email')?.touched && emp_form.get('emp_email')?.hasError('required')"> Employee Email is Invalid /div>
          /div>
  
          div class="col-lg-3"> 
          input type="text" class="form-control" formControlName="emp_role" placeholder="Employee Role">
          div class="error" *ngIf="emp_form.get('emp_role')?.touched && emp_form.get('emp_role')?.hasError('required')"> Employee Role is Invalid /div>
          /div>
          div class="col-lg-3">  button class="btn btn-primary" type="submit"> Employee /button>/div>
      /div>    
      /form>


    table class="table table-bordered mt-3">
        thead>
          tr>
            th>Employee ID /th>
            th>Employee Name /th>
            th>Employee Email /th>
            th>Employee Role /th>
            th>Actions /th>
          /tr>
        /thead>
      tbody>
          tr *ngFor="let emp of emp_details">
            td> {{emp.emp_id}} /td>
            td> {{emp.emp_name}} /td>
            td> {{emp.emp_email}} /td>
            td> {{emp.emp_role}} /td>
            td>
              button class="btn btn-sm btn-warning me-2" (click)="empUpdateEdit(emp.emp_id)">Edit/button>
              button class="btn btn-sm btn-danger" (click)="deleteEmp(emp.emp_id)">Delete/button>
            /td>
          /tr>
        /tbody>
      /table>
/div>


          </code>
        </pre>

    </div>


    <div class="box shadow p-2 mb-3" id="emp-api">
      <h2> Employee crud with API </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
             
import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { HttpSharedService } from '../../http-shared.service';
import { ToastrService } from 'ngx-toastr';


@Component({
  selector: 'app-crud-api',
  imports: [HeaderComponent, CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './crud-api.component.html',
  styleUrl: './crud-api.component.css'
})
export class CrudApiComponent {

  users: any
  user_detail: any
  user_form!: FormGroup

  constructor(private fb: FormBuilder, private http: HttpSharedService, private toastr: ToastrService){}
    user_field = {
    username  : ['', Validators.required],
    firstName : ['', Validators.required],
    lastName  : ['', Validators.required],
    email     : ['', Validators.required],
    phone     : ['', Validators.required],
    address   : ['', Validators.required]
  }

 ngOnInit(){ 
  this.getUser()
  this.intializeForm()
 }

 resetForm(){
  this.intializeForm()
}

 intializeForm(){ this.user_form = this.fb.group(this.user_field)}

 getUser(){
  this.http.get('users').subscribe((response: any) => {
    this.users = response.users;
  })
 }

 setUser(user: any){
  this.user_detail = user;
  this.patchForm()
 }

 saveForm(){ 
  this.createUser(),
  this.updateUser()
 }

 patchForm(){
  this.user_form.patchValue({
    username  : this.user_detail.username,
    firstName : this.user_detail.firstName ,
    lastName  : this.user_detail.lastName ,
    email     : this.user_detail.email,
    phone     : this.user_detail.phone,
    address   : this.user_detail.address
  })
 }

 setPayLoad(form: any){
  return {
    username  : form.username,
    firstName : form.firstName ,
    lastName  : form.lastName ,
    email     : form.email,
    phone     : form.phone,
    address   : form.address
  }
 }

 createUser(){
  this.http.post('users/add', this.setPayLoad(this.user_form.value)).subscribe((response: any) => {
    this.getUser()
    this.resetForm()
    console.log('Add User --->', response);
    this.toastr.success("User Added Successfully")
  })
 }

 updateUser(){
  this.http.put('users/'+this.user_detail.id, this.setPayLoad(this.user_form.value)).subscribe((response: any) => {
    this.getUser()
    this.resetForm()
    console.log('Add User --->', response);
    this.toastr.success("User Updated Successfully")
  })
 }

 deActivatedUser(user: any){
  this.http.delete('users/'+user.id).subscribe((response: any) => {
    this.getUser()
    this.resetForm()
    console.log('Delete', response);
    this.toastr.success("User Deleted Successfully")
  })
 }

}

            </code>
          </pre>

      <hr>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
            <code>

           div class="container mt-5">
    h2 class="mb-5"> Crud Operation with API /h2>

    div class="container">
        div class="dynamic-form shadow p-3 col-lg-12 m-auto mb-5 card">
    
            div class="d-flex justify-content-between mb-4"> 
                h5> span class="mb-4"> User Form  /span>/h5>
                button class="btn btn-success"> Add User /button>
            /div>
    
            form [formGroup]="user_form" (ngSubmit)="saveForm()">
            div class="row m-auto"> 
            div class="col-lg-3 mb-4"> 
            input type="text" class="form-control" formControlName="username" placeholder="Username">
            div class="error" *ngIf="this.user_form.get('username')?.touched && this.user_form.get('username')?.hasError('required')"> Username is Invalid /div>
            /div>
    
            div class="col-lg-3 mb-4">  
            input type="text" class="form-control" formControlName="firstName" placeholder="First Name">
            div class="error" *ngIf="this.user_form.get('firstName')?.touched && this.user_form.get('firstName')?.hasError('required')"> First Name is Invalid /div>
            /div>
    
            div class="col-lg-3 mb-4"> 
            input type="text" class="form-control" formControlName="lastName" placeholder="Last Name">
            div class="error" *ngIf="this.user_form.get('lastName')?.touched && this.user_form.get('lastName')?.hasError('required')"> Last Name is Invalid /div>
            /div>

            div class="col-lg-3 mb-4"> 
                input type="text" class="form-control" formControlName="email" placeholder="Email">
                div class="error" *ngIf="this.user_form.get('email')?.touched && this.user_form.get('email')?.hasError('required')"> Email is Invalid /div>
                /div>

            div class="col-lg-3 mb-4"> 
                input type="text" class="form-control" formControlName="phone" placeholder="Phone">
                div class="error" *ngIf="this.user_form.get('phone')?.touched && this.user_form.get('phone')?.hasError('required')"> Phone is Invalid /div>
            /div>

            div class="col-lg-3 mb-4"> 
                input type="text" class="form-control" formControlName="address" placeholder="Address">
                div class="error" *ngIf="this.user_form.get('address')?.touched && this.user_form.get('address')?.hasError('required')"> Address is Invalid /div>
            /div>

            div class="col-lg-3 mb-4">  
                button class="btn btn-primary" type="submit"> Submit /button>/div>
        /div>    
        /form>
    
        /div>
    
        <!-- <div *ngIf="!User_details.length">  <h5> No Data </h5></div> -->
    
        table class="table table-bordered mt-3">
            thead>
              tr>
                th> Username /th>
                th> Name /th>
                th> Gender /th>
                th> Email /th>
                th> Phone /th>
                th> Address /th>
                th> Action /th>
              /tr>
            /thead>
            tbody>
              tr *ngFor="let user of users">
                td> {{user.username}} /td>
                td> {{user.firstName}} {{user.lastName}} /td>
                td> {{user.gender}} /td>
                td> {{user.email}} /td>
                td> {{user.phone}} /td>
                td> {{user.address?.address}} /td>
              td>
                  button class="btn btn-sm btn-warning me-2" (click)="setUser(user)">Edit /button>
                  button class="btn btn-sm btn-danger" (click)="deActivatedUser(user)">Delete /button>
                /td>
              /tr>
            /tbody>
          /table>
    /div>
/div>


            </code>
          </pre>

      <h2> Dabase check validation </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
            <code>
  isDuplicateProduct(title: string): boolean {
    return this.products?.some((product: any) => product.title.trim().toLowerCase() === title.trim().toLowerCase());
  }
  

   saveProduct(){
      const title = this.product_form.value.title;
  
        // Check: If editing, and title hasn't changed, skip duplicate check
      if (this.product_details?.id && title === this.product_details.title.trim().toLowerCase()) {
      this.productUpdate();
      return;
     }
  
      if (this.isDuplicateProduct(title)) {
        this.toaster.error('Product title already exists!');
        return;
      }
  
        // Create or Update
    if (this.product_details?.id) {
      this.productUpdate();
    } else {
      this.createProduct();
    }
  
    }


    //

            </code>
          </pre>

    </div>

    <div class="box shadow p-2 mb-3" id="emp-dynamic">
      <h2> Employee crud with API Dynamic Form </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { HttpSharedService } from '../../http-shared.service';
import { ToastrService } from 'ngx-toastr';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-crud-form-dynamic',
  imports: [CommonModule, ReactiveFormsModule, HeaderComponent],
  templateUrl: './crud-form-dynamic.component.html',
  styleUrl: './crud-form-dynamic.component.css'
})
export class CrudFormDynamicComponent {

  products: any
  product_form!: FormGroup
  product_details: any

  constructor(
    private fb: FormBuilder,
    private http: HttpSharedService,
    private toaster: ToastrService
  ) { }

  productform_fields = [
    { name: 'title', label: 'Product Title', required: true },
    { name: 'category', label: 'Product Category', required: true },
    { name: 'brand', label: 'Brand', required: true },
    { name: 'description', label: 'Description', required: true },
    { name: 'price', label: 'Price', required: true }
  ];

  ngOnInit() {
    this.initializeForm()
    this.getProduct()
  }

  initializeForm() {
    const group: any = {};
    this.productform_fields.forEach(field => {
      group[field.name] = field.required ? ['', Validators.required] : [''];
    });
    this.product_form = this.fb.group(group);
  }

  resetForm() {
    this.initializeForm()
    this.product_details = null;
  }

  saveProduct() {
    if (this.product_details?.id) {
      this.productUpdate();
    } else {
      this.createProduct();
    }
  }

  getProduct() {
    this.http.get('products').subscribe((response: any) => {
      this.products = response.products;
    })
  }

  setPayLoad(form: any) {
    const payload: any = {};
    this.productform_fields.forEach(field => {
      payload[field.name] = form[field.name];
    });
    return payload;
  }


  createProduct() {
    this.http.post('products/add', this.setPayLoad(this.product_form.value)).subscribe((response: any) => {
      this.resetForm()
      this.toaster.success('Product has been created')
    })
  }

  patchForm() {
    const patch: any = {};
    this.productform_fields.forEach(field => {
      patch[field.name] = this.product_details[field.name];
    });
    this.product_form.patchValue(patch);
  }


  productUpdate() {
    this.http.put('products/' + this.product_details.id, this.setPayLoad(this.product_form.value)).subscribe((response: any) => {
      this.resetForm()
      this.toaster.success('Product has been updated')
    })
  }

  setProduct(product: any) {
    this.product_details = product
    this.patchForm()
  }

  deleteProduct(product: any) {
    this.http.delete('products/' + product.id).subscribe((response: any) => {
      this.toaster.success('Product has been deleted')
    })
  }
}



======================

HTML 

form class="shadow-lg rounded mb-5 p-3" [formGroup]="product_form" (ngSubmit)="saveProduct()">
div class="row">
  div class="col-lg-2" *ngFor="let field of productform_fields">
    input [placeholder]="field.label" class="form-control" [formControlName]="field.name" />
    span class="text-danger" *ngIf="product_form.get(field.name)?.touched && product_form.get(field.name)?.hasError('required')"> 
    {{ field.label }} is invalid  /span>
  /div>
  div class="col-lg-2 d-flex align-items-end">
    button type="submit" class="btn btn-success w-100">Add Product /button>
  /div>
/div>
/form>


tr *ngFor="let product of products">
                td> {{product.title}} /td>
                td> {{product.category}} /td>
                td> {{product.brand}} /td>
                td> {{product.description}} /td>
                td> {{product.price}} /td>
                td> 
                    div class="d-flex"> 
                    button class="btn btn-info me-2" (click)="setProduct(product)"> Edit /button>
                    button class="btn btn-danger" (click)="deleteProduct(product)"> Delete /button>
                    /div>
                /td>
            /tr>


            </code>
          </pre>

    </div>


    <div class="box shadow p-2 mb-3" id="emp-withoutdynamic">
      <h2> Employee crud without API Dynamic Form </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-crud-form-dynamic-localhost',
  imports: [ReactiveFormsModule, FormsModule, CommonModule, HeaderComponent],
  templateUrl: './crud-form-dynamic-localhost.component.html',
  styleUrl: './crud-form-dynamic-localhost.component.css'
})
export class CrudFormDynamicLocalhostComponent {

  
  emp_form!: FormGroup
  emp_details: any = []
  empUpdateRecored: any

  constructor(
    private fb: FormBuilder,
    private toaster: ToastrService
  ){}

    // Dynamic form fields
  dynamic_fields = [
  { label: 'Employee Name', key: 'emp_name', type: 'text', required: true },
  { label: 'Email', key: 'emp_email', type: 'email', required: true },
  { label: 'Role', key: 'emp_role', type: 'text', required: true },
  { label: 'Phone No', key: 'emp_phone', type: 'text', required: true }
];

  ngOnInit(){
    this.initializeForm()
    let empdata = localStorage.getItem('employee_data')
    if(empdata){
      this.emp_details = JSON.parse(empdata)
    }
  }

  initializeForm() {
   const formControls: any = {};
  this.dynamic_fields.forEach(field => {
    formControls[field.key] = field.required ? ['', Validators.required] : [''];
  });
  this.emp_form = this.fb.group(formControls);
  }

  resetForm(){
    this.initializeForm()
    this.empUpdateRecored = null;
  }

  empSaveData(){
    if(this.empUpdateRecored){
      this.updateEmp()
    } else {
      this.getEmp()
    }
  }

  getEmp(){
    const emp_id = (this.emp_details.at(-1)?.id ?? 0) + 1
    const formValue = this.emp_form.value;

    this.emp_details.push({
      id: emp_id,
      ...formValue
    });

    this.resetForm();
    this.toLocalSaveData();
    this.toaster.success("Employee data has been added");

  }

  updateEmp(){
    const formValue = this.emp_form.value;
    const found = this.emp_details.find((emp: any) => emp.id == this.empUpdateRecored);

    if (found) {
      Object.assign(found, formValue);
    }

    this.resetForm()
    this.toLocalSaveData()
    this.toaster.success("Employee data has been updated")
  }

empEditUpdate(emp_id: any) {
  this.empUpdateRecored = emp_id;
  const data = this.emp_details.find((emp: any) => emp.id === emp_id);
  if (data) {
    // Only pick the fields that exist in the form
    const patchValues: any = {};
    this.dynamic_fields.forEach(field => {
      patchValues[field.key] = data[field.key];
    });

    this.emp_form.patchValue(patchValues);
  }
}

  deleteEmp(emp_id: any){
    this.emp_details = this.emp_details.filter((emp_data: any) => emp_data.id != emp_id)
    this.toLocalSaveData()
    this.toaster.success("Employee data has been deleted")
  }

  toLocalSaveData(){
    localStorage.setItem('employee_data', JSON.stringify(this.emp_details))
  }

}



====================

HTML 

form [formGroup]="emp_form" (ngSubmit)="empSaveData()" class="mb-4 p-3 shadow-sm rounded bg-light">
  div class="row">
    div class="col-md-4 mb-3" *ngFor="let field of dynamic_fields">
      input
        class="form-control"
        [placeholder]="field.label"
        [formControlName]="field.key"
      />
      div class="text-danger" *ngIf="emp_form.get(field.key)?.touched && emp_form.get(field.key)?.invalid">
        {{ field.label }} is required
      /div>
    /div>
    div class="col-md-2 d-flex align-items-end">
      button type="submit" class="btn btn-primary w-100"> {{ empUpdateRecored ? 'Update' : 'Add' }} Employee /button>
    /div>
  /div>
/form>

table class="table table-bordered">
  thead>
    tr>
      th>#ID /th>
      th *ngFor="let field of dynamic_fields">{{ field.label }} /th>
      th>Actions /th>
    /tr>
  /thead>
  tbody>
    tr *ngFor="let emp of emp_details">
      td>{{ emp.id }}  /td>
      td *ngFor="let field of dynamic_fields">{{ emp[field.key] }} /td>
      td>
        button class="btn btn-sm btn-info me-2" (click)="empEditUpdate(emp.id)">Edit  /button>
        button class="btn btn-sm btn-danger" (click)="deleteEmp(emp.id)">Delete  /button>
      /td>
    /tr>
  /tbody>
/table>

            </code>
          </pre>

    </div>


    <div class="box shadow p-2 mb-3" id="crudstaticdata">
      <h2> Employee crud static data </h2>
      <p> Math.max(...)
        Returns the highest number in the list.

        Example: Math.max(1, 3, 2) → 3</p>

      <p> this.emp_details.length > 0 ? ... : 1
        If emp_details array is empty, it will return 1 as the first ID </p>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
            <code>
              1. CRUD STATIC DATA ( crud-static.ts )

              import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-crud-lg-practise',
  imports: [HeaderComponent, ReactiveFormsModule, FormsModule, CommonModule],
  templateUrl: './crud-lg-practise.component.html',
  styleUrl: './crud-lg-practise.component.css'
})
export class CrudLgPractiseComponent {

  emp_form!: FormGroup;
  emp_details = [
    {
      emp_id: 1,
      emp_name: "Achyut Kadam Singh",
      emp_email: "achyut@gmail.com",
      emp_role: "WebDeveloper"
    },
    {
      emp_id: 2,
      emp_name: "Gorakh Sans",
      emp_email: "gorakh@gmail.com",
      emp_role: "Fullstack Developer"
    },
    {
      emp_id: 3,
      emp_name: "Achyut Kadam",
      emp_email: "achyut@gmail.com",
      emp_role: "Senior webDeveloper"
    }
  ];
  empUpdateid: number | null = null;

  constructor(private fb: FormBuilder) {}

  emp_fields = {
    emp_id: [''],
    emp_name: ['', Validators.required],
    emp_email: ['', Validators.required],
    emp_role: ['', Validators.required]
  };

  ngOnInit() {
    this.intializeForm();
  }

  intializeForm() {
    this.emp_form = this.fb.group(this.emp_fields);
  }

  resetForm() {
    this.intializeForm();
    this.empUpdateid = null;
  }

  saveEmployeeData() {
    if (this.empUpdateid !== null) {
      this.empUpdate();
    } else {
      this.createEmp();
    }
  }

  createEmp() {
    const newId = this.emp_details.length > 0
      ? Math.max(...this.emp_details.map(emp => emp.emp_id)) + 1
      : 1;

    this.emp_details.push({
      emp_id: newId,
      emp_name: this.emp_form.value.emp_name,
      emp_email: this.emp_form.value.emp_email,
      emp_role: this.emp_form.value.emp_role
    });

    this.resetForm();
  }

  empUpdate() {
    const index = this.emp_details.findIndex(emp => emp.emp_id === this.empUpdateid);
    if (index > -1) {
      this.emp_details[index].emp_name = this.emp_form.value.emp_name;
      this.emp_details[index].emp_email = this.emp_form.value.emp_email;
      this.emp_details[index].emp_role = this.emp_form.value.emp_role;
    }

    this.resetForm();
  }

  empUpdateEdit(emp_id: number) {
    this.empUpdateid = emp_id;
    const emp = this.emp_details.find(emp => emp.emp_id === emp_id);
    if (emp) {
      this.emp_form.patchValue(emp);
    }
  }

  deleteEmp(emp_id: number) {
    this.emp_details = this.emp_details.filter(emp => emp.emp_id !== emp_id);
    this.resetForm();
  }
}



=======================


div class="container">
    div class="dynamic-form shadow p-3 col-lg-12 m-auto mb-5 card">
        form [formGroup]="emp_form" (ngSubmit)="saveEmployeeData()">
          div class="row m-auto"> 
          div class="col-lg-3"> 
          input type="text" class="form-control" formControlName="emp_name" placeholder="Employee Name">
          div class="error" *ngIf="emp_form.get('emp_name')?.touched && emp_form.get('emp_name')?.hasError('required')"> Employee Name is Invalid /div>
          /div>
  
          div class="col-lg-3">  
          input type="text" class="form-control" formControlName="emp_email" placeholder="Employee Email">
          div class="error" *ngIf="emp_form.get('emp_email')?.touched && emp_form.get('emp_email')?.hasError('required')"> Employee Email is Invalid /div>
          /div>
  
        div class="col-lg-3"> 
          input type="text" class="form-control" formControlName="emp_role" placeholder="Employee Role">
          div class="error" *ngIf="emp_form.get('emp_role')?.touched && emp_form.get('emp_role')?.hasError('required')"> Employee Role is Invalid /div>
          /div>
          div class="col-lg-3">  button class="btn btn-primary" type="submit"> Employee /button>/div>
      /div>    
      /form>
    /div>

    <!-- <div>  <h5> No Data </h5></div> -->

    table class="table table-bordered mt-3">
        thead>
          tr>
            th>Employee ID /th>
            th>Employee Name /th>
            th>Employee Email /th>
            th>Employee Role /th>
            th>Actions /th>
          /tr>
        /thead>
        tbody>
          tr *ngFor="let emp of emp_details">
            td> {{emp.emp_id}}  /td>
            td> {{emp.emp_name}} /td>
            td> {{emp.emp_email}} /td>
            td> {{emp.emp_role}} /td>
            td>
              button class="btn btn-sm btn-warning me-2" (click)="empUpdateEdit(emp.emp_id)">Edit  /button>
              button class="btn btn-sm btn-danger" (click)="deleteEmp(emp.emp_id)">Delete  /button>
            td>
          /tr>
        /tbody>
      /table>
/div>



            </code>
          </pre>

    </div>

    <div class="box shadow p-2 mb-3" id="class">
      <h2> classs </h2>
      <p> A class is a TypeScript feature (and JavaScript ES6) that allows you to create reusable objects with
        properties and methods.
        <br>
        In Angular, classes are used everywhere — especially with decorators like @Component, @Injectable, and
        @NgModule.
      </p>

      <h2> class in Angular </h2>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
                <code>
                  export class User {
                    constructor(
                      public name: string,
                      public age: number
                    ) {}
                  
                    greet() {
                      return `Hello, my name is ${this.name}`;
                    }
                  }
                  
                  // usaseg 

                  let user = new User("John", 30);
console.log(user.greet());  // "Hello, my name is John"

                </code>
              </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="git">
      <h2> GIT And GITHUB </h2>

      <h2> What is Git? </h2>
      <p> Git is a version control system that helps developers track changes in their code, collaborate with others,
        and manage different versions of a project. </p>

      <h2> What is GitHub? </h2>
      <p> GitHub is a cloud platform built on top of Git. It allows you to: </p>
      <p> Store your Git repositories online </p>
      <p> Collaborate with teams </p>
      <p> Create pull requests, issues, etc. </p>

      <h2> What is Branching in Git? </h2>
      <p> A branch is like a separate copy of your code where you can make changes without affecting the main project.
      </p>

      <h2> What is Merging in Git? </h2>
      <p> Merging is the process of combining changes from one branch into another. </p>
      git checkout main <br>
      git merge feature/login-page


<pre>
  <code>
git init        # Initialize a new repository
git clone       # Copy a remote repo to your system
git status                 # Check current status of repo
git add <file>             # Stage a file
git add .                  # Stage all changes
git commit -m "Message"    # Commit staged changes
git push origin <branch>   # Push commits to remote
git pull origin <branch>   # Pull latest changes from remote
git fetch                  # Fetch updates without merging

git branch                 # List branches
git branch <name>          # Create new branch
git checkout <branch>      # Switch branch
git checkout -b <name>     # Create + switch branch
git merge <branch>         # Merge branch into current branch
git branch -d <name>       # Delete branch locally

git log                    # View commit history
git log --oneline          # Short commit history
git diff                   # Show unstaged changes
git show <commit_id>       # Show details of a commit
git stash                  # Temporarily save changes
git stash pop              # Restore stashed changes
git remote -v              # List remotes
git tag <tag_name>         # Create a tag
  </code>
</pre>


      <h2> GIT Workflow </h2>
      <ul>
        <li>git clone – Copy repo from GitHub </li>
        <li> git checkout -b new-feature – Create a branch </li>
        <li> Make your changes and git add, git commit </li>
        <li> git push origin new-feature – Push to GitHub </li>
        <li> Open a Pull Request (PR) on GitHub </li>
        <li> Review & merge into main </li>
      </ul>
    </div>



    <div class="box shadow p-2 mb-3" id="web">
      <h2> What is Web Optimization? </h2>
      <p> Web Optimization is the process of improving a website’s performance, speed, user experience, and
        searchability (SEO). </p>

      <ol>
        <li> Performance Optimization <br> Minify HTML, CSS, JS, Use GZIP compression, Load critical CSS first, Avoid
          large JS bundles </li>
        <li> Image Optimization, Compress images (TinyPNG, ImageMagick, etc.), Use Lazy Loading </li>
        <li> Caching </li>
        <li> Responsive Design , use medi query </li>
        <li> Reduce HTTP Requests , CSS sprites </li>
        <li> use cdn </li>
        <li> <strong> TOOLS </strong></li>
        <li><strong> GTmetrix , Google PageSpeed Insights</strong></li>
      </ol>
    </div>


    <div class="box shadow p-2 mb-3" id="google">
      <h2> Google Cloud </h2>
      <p> Google Cloud = A powerful platform to run apps, store data, analyze information </p>

      <h2> Common Use Cases </h2>
      <ul>
        <li> Hosting websites & web apps </li>
        <li> Running backend APIs </li>
        <li> Storing and analyzing big data </li>
        <li> Deploying machine learning models </li>
        <li> Running containers with Kubernetes (GKE) </li>
      </ul>

      <h2> Why Use Google Cloud? </h2>
      <p> Fast & Scalable , Secure , Integrates well with Angular, Firebase, and other Google tools </p>

      <h2> Services Does Google Cloud Offer? </h2>
      <p> Storage, Security, Networking, Developer Tools, </p>
    </div>



    <div class="box shadow p-2 mb-3" id="async">
      <h2> Async | Pipe </h2>
      <p> Async/Await works on top of Promise and allows you to write async code in a synchronous </p>
      <p> async pipe is used in Angular templates to automatically subscribe to:

        Observable<T> (from RxJS)

          Promise<T>
      </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
            <code>
              data = new Promise(resolve => {
                setTimeout(() => resolve('Loaded from Promise!'), 1500);
              });

            p> Data: {{ data | async }} /p
          </code>
          <h2> async/await </h2>
          IN TS 
          result = '';

  async loadData() {
    const data = await this.fetchData();
    this.result = data;
  }

  fetchData(): Promise string> {
    return new Promise(resolve => {
      setTimeout(() => resolve('Data loaded with async/await!'), 1000);
    });
  }


          in html 
          p> {{ result }} /p
          button (click)="loadData()"> Load /button
        </pre>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
          <code>
            Example with Observable (RxJS)
            import { of, delay } from 'rxjs';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [],
  template: `p>Message: {{ message$ | async }} p>`
})
export class AppComponent {
  message$ = of('Hello from Observable!').pipe(delay(1000));
}
          </code>
        </pre>


    </div>


    <div class="box shadow p-2 mb-3" id="azile">
      <h2> Azile Methodology </h2>
      <p> Agile = Delivering software in small, usable pieces — fast, flexible, and with constant feedback. </p>
      <h2> Agile Workflow </h2>
      <ul>
        <li> Step-by-step Agile Process: </li>
        <li> Product Backlog – List of all features/tasks (To-Do list) </li>
        <li> Sprint Planning – Pick tasks for the next sprint (usually 1–2 weeks) </li>
        <li> Sprint – The team builds and tests features </li>
        <li> Daily Stand-up – Quick daily meeting to track progress </li>
        <li> Sprint Review – Demo the completed work </li>
        <li> Sprint Retrospective – Discuss what went well & what to improve </li>
      </ul>
      <h2> Just like todo app: </h2>
      <ul>
        <li> Build the "Add Task" feature</li>
        <li> Add "Edit & Delete" </li>
        <li> Add filtering and UI improvements </li>
      </ul>
    </div>

    <div class="box shadow p-2 mb-3" id="server">
      <h2> Upload Angular Project to Server </h2>
      <p> <strong> Build the Angular Project </strong></p>
      <p>Run this command - ng build --configuration=production </p>
      <p> <strong> Choose Your Hosting Type </strong></p>
      Shared hosting, Cloud hosting <br>
      Zip the contents of dist/your-project-name/.
    </div>

    <div class="box shadow p-2 mb-3" id="packages">
      <h2> package.json, package-lock.json and angular.json </h2>
      <h2> package.json </h2>
      <p> Lists of libraries in app needs (dependencies, devDependencies) Declares project name, version, </p>
      <p> script - "start": "ng serve",
        "build": "ng build" </p>
      <h2> package-lock.json </h2>
      <p> Automatically created/updated by npm when installing packages</p>
      <h2> angular.json </h2>
      <p> Project structure, Build options </p>
      <p> File paths (e.g. index.html, styles, assets) </p>
      <pre style="white-space: pre-wrap; word-wrap: break-word;">
                  <code>
                    "projects": {
                      "my-angular-app": {
                        "architect": {
                          "build": {
                            "options": {
                              "outputPath": "dist/",
                              "index": "src/index.html",
                              "styles": ["src/styles.css"]
                            }
                          }
                        }
                      }
                    }
                  </code>
                </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="datatransferinput">
      <h2> Data Transfer by @Input and @Output </h2>

      <h2> Data Transfer by Parent to Child </h2>

      <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
1. Parent.component.ts 

import { Component } from '@angular/core';
import { ChildsComponent } from "../childs/childs.component";

@Component({
  selector: 'app-parents',
  imports: [ChildsComponent],
  templateUrl: './parents.component.html',
  styleUrl: './parents.component.css'
})
export class ParentsComponent {
parentMessage: string = 'Hello from Parent Component!';
}

==============

2. parent.component.html 

h1> Parent Component /h1>
app-childs [message]="parentMessage"> /app-childs>

=========================

1. Child.component.ts 

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-childs',
  imports: [],
  templateUrl: './childs.component.html',
  styleUrl: './childs.component.css'
})
export class ChildsComponent {

  @Input() message: string = ''; // receives data from parent

}

==========

2. child.component.html 

h1> Child Component  /h1>
h3>Message from Parent: {{ message }}  /h3>

</code>
</pre>

<p>
@Output() creates a custom event. <br>
.emit(value) triggers that event and sends the value to the parent.<br>
EventEmitter A special class to emit events<br>
$event The data received in parent component<br>
</p>
<h2> @Output Child to Parent </h2>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>
1. Child.Compoent.ts

import { Component } from '@angular/core';
import { EventEmitter, Output } from '@angular/core';

@Component({
selector: 'app-childs',
imports: [],
templateUrl: './childs.component.html',
styleUrl: './childs.component.css'
})

export class ChildsComponent {
@Output() sendMessage = new EventEmitter<string>();
sendToParent(){
this.sendMessage.emit('Hello from Child component!');
}
}

========

2. child.component.html 

h1> Child Component /h1>
button class="btn btn-success" (click)="sendToParent()"> Send Message to Parent  /button>

=================

1. Parent.component.ts 

import { Component } from '@angular/core';
import { ChildsComponent } from "../childs/childs.component";

@Component({
  selector: 'app-parents',
  imports: [ChildsComponent],
  templateUrl: './parents.component.html',
  styleUrl: './parents.component.css'
})
export class ParentsComponent {

messageFromChild: string ='';

receiveMessage(msg: string) {
this.messageFromChild = msg;
}
  
}

===========

2. parent.component.html

h1> Parent Component /h1>
app-childs (sendMessage)="receiveMessage($event)">   /app-childs>
p>Message from Child: {{ messageFromChild }} /p>

</code>
</pre>

<hr>


<div class="mt-5">
<h2> @Input Parent to child with real API data </h2>
<pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>

1. ParentComponent.ts
  
import { Component } from '@angular/core';
import { ChildsComponent } from "../childs/childs.component";
import { HttpSharedService } from '../../http-shared.service';

@Component({
  selector: 'app-parents',
  imports: [ChildsComponent],
  templateUrl: './parents.component.html',
  styleUrl: './parents.component.css'
})
export class ParentsComponent {

apiData: any [] = [];

constructor( private http: HttpSharedService){}

ngOnInit(){
  this.getUser()
}

getUser(){
  this.http.get('users').subscribe((response: any) => {
    this.apiData = response.users
  })
}

}

=================

2. ParentComponent.html 

h1> Parent Components /h1>
app-childs [users]="apiData">  /app-childs>

=================

3. Child Compoent ts 

import { CommonModule } from '@angular/common';
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-childs',
  imports: [CommonModule],
  templateUrl: './childs.component.html',
  styleUrl: './childs.component.css'
})
export class ChildsComponent {

  @Input() users: any[] = [];

}

=============

4. child Component html 

h1> Child Component /h1>
p>Received Data live data : /p>
ul>
  li *ngFor="let user of users">
    {{ user.firstName }}
  /li>
/ul>

  </code>
</pre>
      </div>

<div class="mt-5">
<h2> @Output child to parent with real API data </h2>

<pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>

1. Parent.ts 

import { Component } from '@angular/core';
import { ChildsComponent } from "../childs/childs.component";
import { HttpSharedService } from '../../http-shared.service';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';

@Component({
  selector: 'app-parents',
  imports: [ChildsComponent, CommonModule, ReactiveFormsModule],
  templateUrl: './parents.component.html',
  styleUrl: './parents.component.css'
})
export class ParentsComponent {

receivedData: any[] = [];
onApiDataReceived(data: any[]) {
    this.receivedData = data;
    console.log("Received from child:", data);
  }

}


===========

2. parent.html 

app-childs (dataFetched)="onApiDataReceived($event)"> /app-childs>

div *ngIf="receivedData.length > 0">
  h3>Data received from Child: /h3>
  ul>
    li *ngFor="let user of receivedData">{{ user.firstName }} /li>
  /ul>
/div>

div *ngIf="receivedData.length === 0">
  p>Loading or no data found... /p>
/div>

===========

3. child.ts 

import { CommonModule } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { HttpSharedService } from '../../http-shared.service';

@Component({
  selector: 'app-childs',
  imports: [CommonModule],
  templateUrl: './childs.component.html',
  styleUrl: './childs.component.css'
})
export class ChildsComponent {

   @Output() dataFetched = new EventEmitter<any[]>();

   constructor( private http: HttpSharedService){}

  ngOnInit(){
    this.getDataFetch()
  }

  getDataFetch(){
    this.http.get('users').subscribe((data: any) => {
      this.dataFetched.emit(data.users);
    })
  }

}

==========

4. Child.html 

h1> Child Component /h1>
p> Child is fetching data from API and sending to Parent... /p>


  </code>
</pre>

      </div>

      <hr>

      <div class="mt-5">
        <h2> Pass [1, 2, 3] from Parent to Child </h2>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
<code>

  1. Parent.ts 

import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html'
})
export class ParentComponent {
  numbers: number[] = [1, 2, 3];
}

=========

2. Parent.html 

h2>Parent Component /h2>
app-child [inp]="numbers"> /app-child>

======

3. child.component.ts

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html'
})
export class ChildComponent {
  @Input() inp: number[] = [];
}


============

4. child.component.html

h3>Child Component/h3>
ul>
  li *ngFor="let num of inp"> {{ num }} /li>
/ul>


output 
http://localhost:4200/parents
Child Component
- 1
- 2
- 3


</code>
</pre>

      </div>

      <hr>

      <div class="mt-5">
        <h2> Pass [1, 2, 3] from child to Parent </h2>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    1. child component.ts 

import { Component, OnInit, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html'
})
export class ChildComponent implements OnInit {
  @Output() sendData = new EventEmitter<number[]>();

  ngOnInit() {
    const numbers = [1, 2, 3];
    this.sendData.emit(numbers);
  }
}

==========

2. child.component.html

h3>Child Component /h3>
p>Sending data to Parent.../p>

==========

3. parent.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html'
})
export class ParentComponent {
  receivedData: number[] = [];

  onChildData(data: number[]) {
    this.receivedData = data;
  }
}

========

4. parent.component.html
h2>Parent Component /h2>
app-child (sendData)="onChildData($event)"> /app-child>

ul>
  li *ngFor="let num of receivedData">{{ num }} /li>
/ul>

//// output
Parent Component
- 1
- 2
- 3

  </code>
</pre>

      </div>



      <hr>

      <div class="mt-5">

        <h2> <strong> Create a Service that Provides a Message </strong> </h2>

        @Injectable({ providedIn: 'root' }) — What It Does
        <p class="p-0 m-0"> Angular how and where to provide (register) the service so it can be used across your app.
        </p>
        <p class="p-0 m-0"> @Injectable() is a decorator that marks a class as available for dependency injection. </p>
        <p class="p-0 m-0"> providedIn: 'root' means: Make this service available application-wide, as a singleton. </p>
        <p class="p-0 m-0"> Without providedIn: 'root' You would have to register it manually in a module: @NgModule({
          providers: [MessageService]
          })
          export class AppModule { } </p>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
1. run command - ng generate service message

2. message.service.ts 

import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root'
})
export class MessageService {
  constructor() { }
  getMessage(): string {
    return 'Hello from the Message Service!';
  }
}


3. Use the Service in a Component
app.component.ts

import { Component, OnInit } from '@angular/core';
import { MessageService } from './message.service';  // import service

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {
  message: string = '';

  constructor(private messageService: MessageService) {}

  ngOnInit() {
    this.message = this.messageService.getMessage();
  }
}


4. app.component.html
h1> {{ message }} /h1>

    </code>
  </pre>

      </div>


      <hr>

      <div class="mt-5">

        <h2> <strong> Create a Directive that Highlights Text with Background Color </strong></h2>
        <ul>
          <li> selector: '[appHighlight]' Use it like an attribute </li>
          <li> ElementRef Access the element it’s attached to </li>
          <li> Renderer2 Safely modify DOM styles </li>
          <li> @HostListener React to DOM events like mouseenter/mouseleave </li>
        </ul>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
    <code>
    1. run command : ng generate directive highlight

    2. highlight.directive.ts

import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]' // This is the directive selector
})
export class HighlightDirective {

  constructor(private el: ElementRef, private renderer: Renderer2) {}

  // When mouse enters
  @HostListener('mouseenter') onMouseEnter() {
    this.highlight('#fc7510'); // orange highlight
  }

  // When mouse leaves
  @HostListener('mouseleave') onMouseLeave() {
    this.highlight('transparent');
  }

  private highlight(color: string) {
    this.renderer.setStyle(this.el.nativeElement, 'backgroundColor', color);
  }
}

==================

3. Use the Directive in Any Component
app.component.ts

import { HighlightDirective } from '../highlight.directive';

@Component({
  selector: 'app-interview',
  imports: [ HighlightDirective],
  templateUrl: './interview.component.html',
  styleUrl: './interview.component.css'
})

h2 appHighlight>Hover me to see the highlight effect /h2>
p> Normal paragraph (no directive) /p>

app.component.html
// When you hover over the h2>, the background color will change to orange.
When you move the mouse away, it will go back to normal.
    </code>
  </pre>

      </div>


      <hr>

      <div class="mt-4" id="custompipe-examples">
        <h2> Create custom Pipe </h2>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
pipeTransform use - PipeTransform is an interface from the @angular/core package that allows you to create custom pipes. 
transform(value: string): string

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'genderTitle'
})

export class GenderTitlePipe implements PipeTransform {

  transform(value: string, gender: string): string {
    if (gender.toLowerCase() === 'male') {
      return 'Mr. ' + value;
    } else {
      return 'Miss. ' + value;
    }
  }

}

  </code>
</pre>

        <h2> Secone example in custom pipe </h2>

        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    ng generate pipe prefix

TS.
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({
  name: 'prefix'
})
export class PrefixPipe implements PipeTransform {
  transform(value: string, prefixText: string): string {
    return `${prefixText} ${value.toUpperCase()}`;
  }
}
====

html 

{{ 'angular developer' | prefix:'Hello' }}

// Hello ANGULAR DEVELOPER


  </code>
</pre>

      </div>


      <div id="npm" class="mt-5">
        <H2> <STRONG> NPM </STRONG></H2>
        <p> NPM (Node Package Manager) is the default package manager for Node.js. It helps you: <br>
          Install, update, or remove packages (libraries/modules) <br>
          Manage project dependencies using package.json <br>
          NPM is the default package manager for Node.js. It is used to manage JavaScript packages, automate build
          tasks, and handle dependencies.
        </p>
      </div>



      <div class="box shadow p-2 mb-3" id="cicd">
        <h2> CI/CD Environment? </h2>
        <p> A CI/CD environment is a setup where software changes (like code, design, or config) are automatically
          built, tested, and deployed to staging or production systems. </p>
        <p class="p-0 m-0"><strong> CI (Continuous Integration) </strong></p>
        <p> Automatically builds and tests your code whenever you make changes (push/commit). </p>
        <p class="p-0 m-0"><strong> CD: Continuous Deployment </strong></p>
        <p> Automatically deploying the tested build to a staging or production environment. </p>

        <h2> <strong> Tools have you used for CI/CD? </strong></h2>
        <ul>
          <li> <strong> GitHub </strong> Actions for automated build and deployment. </li>
          <li> <strong> Jenkins </strong> to run custom build pipelines. </li>
          <li> <strong> GitLab </strong> CI/CD for integrated pipelines. </li>
          <li> <strong> Netlify / Vercel / Firebase Hosting </strong> for frontend deployments. </li>
          <li> <strong> Docker </strong> for containerizing Angular apps in some projects. </li>
        </ul>

        <h2> Build pipeline in CI/CD? </h2>
        <p> A build pipeline is a sequence of steps that runs automatically when code is pushed. In frontend (Angular)
          development, it usually includes: </p>
        <ol>
          <li> Install dependencies (npm install) </li>
          <li> Run tests (ng test) </li>
          <li> Lint the code (ng lint) </li>
          <li> Build the app (ng build) </li>
          <li> Deploy to staging/production </li>
        </ol>

        <h2> How do you set up CI/CD for an Angular project? </h2>
        <ol>
          <li> Push code to GitHub </li>
          <li> Add a .yml file (like .github/workflows/deploy.yml) </li>
          <li> In the workflow:
            <ul>
              <li> Install Angular CLI </li>
              <li> Run tests and build </li>
              <li> Deploy to Firebase/Netlify/S3/etc. </li>
            </ul>
          </li>
        </ol>

        <h2> How do you deploy Angular app using GitHub Actions? </h2>
        <ul>
          <li> Create a workflow file in .github/workflows/deploy.yml </li>
          <li> Set up build steps </li>
          <li> Add a deploy step using Firebase CLI / SCP / Netlify CLI / S3 upload </li>
          <li> Use GitHub secrets to store API keys or tokens </li>
        </ul>

      </div>


      <div class="box shadow p-2 mb-3" id="azure">
        <h2> Azure DevOps </h2>
        <p> Azure DevOps is a Microsoft cloud-based DevOps platform that provides : </p>
        <ul>
          <li> Azure Repos: Git repositories for source control </li>
          <li> Azure Pipelines: Build and release automation (CI/CD) </li>
          <li> Azure Artifacts: Package management </li>
          <li> Azure Boards: Work tracking </li>
          <li> Azure Test Plans: Test management </li>
        </ul>

        <h2 class="mt-4"> CI/CD Works in Azure DevOps for Frontend (Angular) Projects </h2>
        <ul>
          <li> <strong> CI Process: </strong></li>
          <li> Code pushed to Azure Repos or GitHub </li>
          <li> CI pipeline triggers automatically </li>
          <li> Steps performed:
            <ul>
              <li> Install dependencies (npm install) </li>
              <li> Run unit tests (ng test) </li>
              <li> Lint checks (ng lint) </li>
              <li> Build Angular app (ng build) </li>
            </ul>
          </li>
          <li> <strong> CD Process: </strong></li>
          <ol>
            <li> After successful build, Release pipeline is triggered </li>
            <li> Deploys code to: </li>
            <ul>
              <li> Azure Static Web Apps </li>
              <li> Azure App Service </li>
              <li> Firebase, Netlify, or any hosting </li>
            </ul>
          </ol>
        </ul>

        <h2> Benefits of Azure DevOps CI/CD for Angular Projects: </h2>
        <ul>
          <li> No need to configure your own server </li>
          <li> Easy to manage for different stages </li>
          <li> Store API keys securely </li>
          <li> Can add manual review before deployment </li>
          <li> Visual pipeline logs and job status </li>
        </ul>

      </div>

      <div class="box shadow p-2 mb-3" id="jenkins">
        <h2> <strong> Jenkins? </strong> </h2>
        <p> Jenkins is an open-source automation server used to build, test, and deploy code automatically. <br> It’s
          one of the most popular tools for Continuous Integration (CI) and Continuous Delivery/Deployment (CD) in
          modern software development. </p>

        <p> CI/CD Tool - Automates the full frontend build lifecycle <br>
          <strong> Plugin Support - </strong> Easily integrate with any tools you use <br>
          <strong> Scalable </strong> - Supports big teams and parallel builds <br>
          <strong> Free/Open Source - </strong> No cost, community-supported
        </p>

        <h2 class="mt-4"> Key Features of Jenkins: </h2>
        <ul>
          <li> Automates the build–test–deploy process. </li>
          <li> Integrates with Git, GitHub, Bitbucket, Docker, AWS, and more. </li>
          <li> Supports plugins (1500+ available) to extend functionality. </li>
          <li> Can run Angular/React/Node or any frontend/backend project builds. </li>
          <li> Schedules jobs (e.g., build daily or on every code push). </li>
        </ul>

        <h2 class="mt-4"> How Jenkins Works (Simplified): </h2>
        <ol>
          <li> Developer pushes code to a repository (like GitHub) </li>
          <li> Jenkins is triggered via webhook or schedule </li>
          <li> Jenkins performs:
            <ul>
              <li> npm install </li>
              <li> ng build (for Angular) </li>
              <li> ng test or unit tests </li>
              <li> Lint check (ng lint) </li>
              <li> Deploys build to staging or production </li>
            </ul>
          </li>
        </ol>

        <h2 class="mt-4"> Jenkins Pipeline – Example for Angular: </h2>
        <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    pipeline {
  agent any

  stages {
    stage('Install') {
      steps {
        sh 'npm install'
      }
    }

    stage('Build') {
      steps {
        sh 'ng build --configuration=production'
      }
    }

    stage('Test') {
      steps {
        sh 'ng test --watch=false'
      }
    }

    stage('Deploy') {
      steps {
        // Deploy to server, Firebase, S3, etc.
        sh './deploy.sh'
      }
    }
  }
}

  </code>
</pre>

        <h2 class="mt-3"> Jenkins Architecture: </h2>
        <ul>
          <li> Master: Controls the jobs and manages schedules. </li>
          <li> Agents/Slaves: Execute build jobs (can be on other machines). </li>
          <li> Jobs: Defined tasks or pipelines. </li>
          <li> Plugins: Add support for Git, Docker, Slack, etc. </li>
        </ul>

        <h2 class="mt-3"> Useful Jenkins Plugins for Frontend Developers: </h2>
        <ul>
          <li> <strong> Git plugin </strong> Pull code from GitHub/GitLab </li>
          <li> <strong> NodeJS plugin </strong> Run Node/Angular/React commands </li>
          <li> <strong> Slack Notifications </strong> Send build status to Slack </li>
          <li> <strong> Docker Pipeline </strong> Build apps inside containers </li>
          <li> <strong> HTML Publisher </strong> Publish frontend reports </li>
        </ul>

        <h2> Where to Host Jenkins? </h2>
        <ul>
          <li> On your local machine </li>
          <li> On a dedicated server </li>
          <li> Using cloud (e.g., AWS EC2, DigitalOcean, Azure VM) </li>
        </ul>

      </div>

      <div class="box shadow p-2 mb-3" id="testtools">
        <h2> <strong> Frontend Testing Tools </strong> </h2>

        <ol class="mt-4">
          <li> <strong> Jasmine </strong> </li>
          <li> Type: Unit testing framework for JavaScript </li>
          <li> Use with: Angular (default test runner) </li>
          <li> Key Feature: Behavior-driven testing syntax </li>
          <li> Examples
            <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
    describe('MyComponent', () => {
      it('should return true', () => {
        expect(true).toBe(true);
      });
    });
    </code>
    </pre>
          </li>
        </ol>


        <ol class="mt-4">
          <li> <strong> Cypress </strong> </li>
          <li> Type: End-to-end testing (E2E) tool for modern web apps </li>
          <li> Use with: Angular, React, Vue, etc. </li>
          <li> Key Feature: Runs in real browser; fast and easy to debug </li>
          <li> Great For: UI automation, user journey tests </li>
          <li> Examples
            <pre style="white-space: pre-wrap; word-wrap: break-word;">
  <code>
   cy.visit('/login');
cy.get('input[name=username]').type('admin');
cy.get('button[type=submit]').click();
cy.url().should('include', '/dashboard');

    </code>
    </pre>
          </li>
        </ol>

        <ol class="mt-4">
          <li> <strong> Selenium </strong> </li>
          <li> Type: Web automation framework </li>
          <li> Use with: All browsers/languages (Java, Python, C#, JS) </li>
          <li> Key Feature: Cross-browser testing </li>
          <li> Note: More complex setup than Cypress </li>
          <li> Good For: Browser compatibility, enterprise testing </li>
        </ol>


        <ol class="mt-4">
          <li> <strong> Appium </strong> </li>
          <li> Type: Mobile app automation testing </li>
          <li> Use with: Android & iOS apps </li>
          <li> Key Feature: Uses Selenium WebDriver internally </li>
          <li> Good For: Testing hybrid, native, or mobile web apps </li>
        </ol>
      </div>


      <div class="box shadow p-2 mb-3" id="sitecore">
        <h2> Sitecore MVC </h2>
        <p> Sitecore is an enterprise-level .NET-based Content Management System (CMS) and Digital Experience Platform
          (DXP) used for building and managing dynamic websites. <br> Sitecore MVC (Model-View-Controller) </p>
      </div>

      <div class="box shadow p-2 mb-3" id="sitecorejss">
        <h2> Sitecore JSS (JavaScript Services) </h2>
        <p> Sitecore JSS enables developers to build headless apps using modern JavaScript frameworks like React,
          Angular, Vue. </p>
        <p> Allows frontend-first or disconnected development, independent of the Sitecore backend. </p>
        <h2> When to Use: </h2>
        <ul>
          <li> For modern SPA (Single Page Applications). </li>
          <li> When you want to separate frontend/backend or use Jamstack architecture. </li>
          <li> Teams with React/Angular skills. </li>
        </ul>
      </div>


      <div class="box shadow p-2 mb-3" id="angreact">
        <h2> Use Micro Frontends Architecture </h2>

        <h2 class="mt-4"> What is it? </h2>
        <ul>
          <li> A design pattern where the application is divided into independent frontend modules. </li>
          <li> Each module (or "micro frontend") can be built with a different framework (like Angular or React). </li>
        </ul>

        <h2 class="mt-4"> How it works: </h2>
        <ul>
          <li> You split your app into multiple independently deployable apps. </li>
          <li> Example: Angular for dashboard, React for reports. </li>
          <li> Use tools like:
            <ul>
              <li> Module Federation (Webpack 5) </li>
              <li> Single-SPA (Framework to combine multiple apps) </li>
            </ul>
          </li>
        </ul>


        <h2 class="mt-4"> Tools </h2>
        <ul>
          <li> single-spa – Great for managing multiple frameworks. </li>
          <li> Webpack Module Federation – Integrates micro frontends with dynamic loading. </li>
        </ul>

        <h2 class="mt-5"> Embed React Inside Angular </h2>
        <p> You can embed React components into Angular like a widget. </p>
        <ul>
          <li> <strong> Step </strong></li>
          <li> Build your React component. </li>
          <li> Use ReactDOM.render inside an Angular component (using ngOnInit). </li>
          <li> Pass data via props. </li>
          <li> Destroy React component on Angular component ngOnDestroy. </li>
        </ul>

        <h2 class="mt-5"> Tools Required: </h2>
        <ul>
          <li> react, react-dom as dependencies in Angular. </li>
          <li> Custom Angular wrapper component. </li>
        </ul>


        <h2 class="mt-4"> <strong> 3. Embed Angular Inside React </strong></h2>
        <ul>
          <li> Less common and more complex. </li>
          <li> Use Angular Elements (Web Components) to wrap Angular components. </li>
          <li> Import those custom elements inside React. </li>
          <li> <strong> Use Case </strong> When most of the app is React and you want to re-use some Angular components.
          </li>
        </ul>

        <h2 class="mt-4"> Migration Use Case </h2>
        <p> If you're migrating from Angular to React (or vice versa): </p>
        <ul>
          <li> Use micro frontends for step-by-step migration. </li>
          <li> Gradually replace Angular modules with React. </li>
        </ul>

        <h2 class="mt-4"> How to Manage Codebase </h2>
        <ul>
          <li> Use monorepo tools like Nx (supports both Angular & React). </li>
          <li> Shared components/utilities can be maintained in a shared library. </li>
          <li> CI/CD can build and deploy each frontend module independently. </li>
        </ul>

      </div>


      <div class="box shadow p-2 mb-3" id="coreweb">
        <h2> Core Web Vitals </h2>
        <p> Core Web Vitals are a set of performance metrics defined by Google that measure real-world user experience
          related to loading performance, interactivity, and visual stability. If you're working with Angular,
          optimizing for Core Web Vitals is important to improve SEO and user satisfaction. </p>
        <h2> How to Monitor Core Web Vitals in Angular </h2>
        <ul>
          <li> Use Google Tools , Devtool </li>
          <li> PageSpeed Insights </li>
          <li> Chrome DevTools → "Performance" & "Lighthouse" </li>
          <li> Web Vitals Chrome Extension </li>
        </ul>
      </div>


      <div class="box shadow p-2 mb-3" id="changetheme">
        <h2> Change dark and light theme </h2>
        <ul>
          <li> Create your styles.css with both themes defined using CSS variables: </li>
          <li> Create a theme toggle method in a service or component: </li>
          <li> Call Theme Toggle from Component </li>
          <li> Add Toggle Button in Template </li>
          <li> Angular Material provides built-in theming support for dark and light themes.  </li>
        </ul>

        <pre>
          <code>
/* styles.scss */
:root {
  --bg-color: #ffffff;
  --text-color: #000000;
}

.dark-theme {
  --bg-color: #1e1e1e;
  --text-color: #ffffff;
}

body {
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: all 0.3s ease;
}

/// Toggle method in services 

// theme.service.ts (optional for global use)
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class ThemeService {
  isDarkMode = false;

  toggleTheme() {
    this.isDarkMode = !this.isDarkMode;
    if (this.isDarkMode) {
      document.body.classList.add('dark-theme');
    } else {
      document.body.classList.remove('dark-theme');
    }
  }
}


// app.component.ts
import { Component } from '@angular/core';
import { ThemeService } from './theme.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  constructor(public themeService: ThemeService) {}

  toggleTheme() {
    this.themeService.toggleTheme();
  }
}

<!-- app.component.html -->
button (click)="toggleTheme()">Toggle Dark/Light Mode /button>
p> This text will change color with theme /p>

          </code>
        </pre>
        </div>

<div class="box shadow p-2 mb-3" id="language">
<h2> i18n → Internationalization in Angular </h2>
<p> It is the built-in Angular feature for translating your app into multiple languages (like English, Hindi, French, etc.). </p>
h1 i18n> Welcome to My App  /h1 <br>

<h2>  How It Works (Basic Steps): </h2>
<ol>
  <li> Mark translatable text using i18n attribute. </li>
  <li> Extract translation file: - ng extract-i18n </li>
  <li> Translate content for each language. </li>
  <li> Build for specific locale: - ng build --localize </li>
</ol>
</div>


<div class="box shadow p-2 mb-3" id="cross">
<h2> cross-browser compatibility </h2>
<p> Angular already handles many browser inconsistencies, </p>
<ul>
  <li> Use polyfills (Angular CLI adds them automatically). </li>
  <li> Stick to standards-based HTML, CSS, and JS. </li>
  <li> Avoid deprecated APIs and browser-specific hacks. </li>
  <li> <strong> Angular uses the polyfills.ts file to load polyfills for older browsers (like IE11, if needed). </strong> <span> // polyfills.ts
import 'zone.js';  // Required by Angular </span></li>
<li> Use Browser Compatibility Tools - Autoprefixer for CSS = Included with Angular via PostCSS. It adds vendor prefixes automatically. </li>
<li> Use Online Cross-Browser Testing Tools - BrowserStack, Sauce Labs, CrossBrowserTesting,  LambdaTest</li>
</ul>

<h2> Responsive Angular web application </h2>
<ol>
  <li> Use a Responsive CSS Framework </li>
  <li> Angular Material </li>
  <li> Angular Material components are responsive and mobile-friendly by design. You can use:, mat-grid-list, mat-toolbar, mat-sidenav</li>
  <li> Use CSS Flexbox and Grid Layout - Modern CSS (Flexbox and Grid) makes responsive layouts easy. </li>
  <li> Use Media Queries for Custom CSS Write custom breakpoints to handle different screen sizes: @media (min-width: 768px), @media (min-width: 1024px)</li>
</ol>
</div>

<div class="box shadow p-2 mb-3" id="deployment">
<h2> How to angular application fronted integrate with backend ? </h2>
<p> Fronted to Backend integration so create making HTTP requests from Angular to your backend API </p>
<p> Like Backend Node.js - Backend should be Rest API </p>
Example API :- 
<P> GET  /api/users, POST /api/users, PUT  /api/users/:id, DELETE /api/users/:id </P>
<p> Angular Setup - Angular has build in services HttpClient for API calls </p>

<p> <strong> If Angular and backend are on different domains enable CORS on backend </strong></p>
<p> We integrated Angular frontend with backend REST APIs using HttpClient. 
  We can handled environment-based API URLs, and managed CORS for local development, and in production, we served Angular static files from the backend server. </p>
<p>1. <strong> Environment-based API URL in Angular </strong> To use different backend URLs for development, testing, and production without changing code manually. </p>

<p><strong> CORS </strong></p>
<p> When the frontend and backend run on different domains or ports, browsers block requests for security reasons. <br>
  CORS is a protocol that lets the backend specify which origins are allowed to access it. During development, I configure backend CORS to allow my Angular development server, and in production, it usually allows the production domain only. </p>

  <h2 class="mt-5"> <strong> Deployment Process </strong></h2>

<p> <strong> 1. Firebase Hosting (Google Cloud ecosystem) </strong></p>
<p> Why: No server setup, free SSL, works well with Angular, backed by Google Cloud. </p>

Steps:
<ol>
  <li> npm install -g firebase-tools </li>
  <li> firebase login </li>
  <li> firebase init hosting </li>
  <li> ng build --configuration production </li>
  <li> firebase deploy </li>
  <li> Interview angle: Say you’ve used Firebase Hosting (Google Cloud) for static app deployment. </li>
</ol>
<br> 
<ol>
  <li> <strong> 2. AWS S3 + CloudFront (Easy first step into AWS) </strong> </li>
  <li> Why: S3 for storage + CloudFront for CDN → common in real projects. </li>
  <li> Create S3 bucket → Enable static hosting. </li>
  <li> Upload Angular dist/ files. </li>
  <li> Set bucket policy for public read. </li>
  <li> (Optional) Add CloudFront for caching + custom domain. </li>
</ol>
</div>


<div class="box shadow p-2 mb-3" id="sort">
<h2> Flatten, Sort </h2>

<pre>
  <code>
JSON = JSON;

  arr1 = [[[1, 2], [[3, 4]], [5, [6, 7]], [[8, 9]]], 10];
  arr2 = [[['3', '2'], [['1', '4']], ['8', ['7', '6']], [['5', '9']]], '10'];
  arr3 = [[[3, 2], [[1, 4]], [8, [7, 6]], [[5, 9]]], 10];

  // Flatten nested arrays using recursion
  flatArray(array: any[]): any[] {
    const result: any[] = [];
    const flatten = (arr: any[]) => {
      for (let item of arr) {
        if (Array.isArray(item)) {
          // If the item is an array, call flatten again
          flatten(item);
        } else {
          // If the item is not an array, push to final result
          result.push(item);
        }
      }
    };
    flatten(array);
    return result;
  }

  // Sort array in ascending order (handles strings & numbers)
  sortArray(array: any[]): any[] {
    return [...array].sort((a, b) => Number(a) - Number(b));
  }

  // Prepare array for printing (flatten + sort)
  arrayToPrint(array: any[]): any[] {
    return this.sortArray(this.flatArray(array));
  }

  HTML 

h3>Array 1 Output:/h3>
p>{{ JSON.stringify(arrayToPrint(arr1)) }}/p>

h3>Array 2 Output/h3>
p>{{ JSON.stringify(arrayToPrint(arr2)) }}/p>

h3>Array 3 Output:/h3>
p>{{ JSON.stringify(arrayToPrint(arr3)) }}/p>
  
  </code>
</pre>

</div>


</div>
<button id="toTopBtn" title="Go to top">↑</button>
<script src="script.js"></script>
</body>

</html>