<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <title> Angular </title>
    <style>
      #toTopBtn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: #333;
  color: white;
  cursor: pointer;
  padding: 0;
  border-radius: 50%;
  font-size: 18px;
  display: none; /* Hidden by default */
  transition: background-color 0.3s;
  width: 30px;
  height: 30px;
}

#toTopBtn:hover {
  background-color: #555;
}
h2 { font-size: 18px; font-weight: 600;}
pre {
    display: block;
    margin-top: 0;
    margin-bottom: 0;
    overflow: auto;
    font-size: .875em;
    background: #eeeeee;
}
.index { padding: 0; margin: 0;}
.index li {     
    list-style: none;
    display: inline-block;
    border: #ccc solid 1px;
    padding: 0px 5px;
    margin: 3px 0; 
  }
.index li a {     text-decoration: none;
    color: #000;
    font-weight: 600; 
    text-transform: capitalize;
  }
  .borderline { display: block; width: 100%; border: none !important;} 
  .borderline li { border: none;}
    </style>
  </head>
  <body>
   <div class="container-fluid">

    <ul class="index">
      <li> <a href="#angularrun"> angular Run </a> </li>
	  <li> <a href="#why"> why angular </a> </li>
    <li> <a href="#angularjs"> Angular and Angular JS </a> </li>
      <li> <a href="#architecture"> architecture </a> </li>
	  <li> <a href="#modules"> Modules, bootstrap </a> </li>
      <li> <a href="#shared"> shared, Challenging </a> </li>
      <li> <a href="#angularspa"> SPA </a> </li>
      <li> <a href="#mvc"> MVC </a> </li>
      <li> <a href="#root"> root </a> </li>
	  <li> <a href="#jse"> AngularJS Expression - JS Expressions </a> </li>
      <li> <a href="#component"> components </a> </li>
      <li> <a href="#template"> template </a> </li>
      <li> <a href="#metadata"> metadata </a> </li>
      <li> <a href="#angularcli"> angular CLI </a> </li>
      <li> <a href="#angularcontroller"> controllers </a> </li>
      <li> <a href="#ssr"> SSR </a> </li>
      <li> <a href="#optimize"> optimization </a> </li>
      <li> <a href="#lazy"> lazy loading </a> </li>
      <li> <a href="#change"> Change Detection </a> </li>
      <li> <a href="#accessibility"> accessibility </a> </li>
      <li> <a href="#newfeatures" style="background:green; color:#fff;"> New featurs </a> </li>
      <li> <a href="#routeguards"> routeguards, Dynamic Menu </a> </li>
      <li> <a href="#spa"> SPA </a> </li>
      <li> <a href="#state"> state management </a> </li>
      <li> <a href="#scope"> Scope </a> </li>
	   <li> <a href="#angular-react"> Angular and React </a> </li>
     <li> <a href="#server"> Upload Angular Project </a> </li>
     <li> <a href="#storage"> Local Storage </a> </li>
     <li> <a href="#packages"> packages.json, angular.json </a> </li>
     <li> <a href="#async"> Async, Async pipe, promise </a> </li>
     <li> <a href="#authentication"> Authentication, Authorization </a> </li>
      <li> <a href="#encapsulation">  View Encapsulation </a> </li>
    
     
      <li class="borderline"><a href="#">  </a></li>
      <li> <a href="#databinding"> Data Binding </a> </li>
	   <li> <a href="#datatransfer"> Data Transfer wrelation </a> </li>
      <li> <a href="#decorator"> decorator </a> </li>
      <li> <a href="#directive"> directive </a> </li>
      <li> <a href="#input"> @input() </a> </li>
      <li> <a href="#ngfor"> *ngFor, *ngIf, else, Toggle, @HostListener  </a> </li>
      <li> <a href="#pipe"> pipe, pure, impure </a> </li>
      <li> <a href="#viewchild"> viewchild </a> </li>
	  <li> <a href="#global-variable"> global-variable </a> </li>
    <li> <a href="#form"> Form, reactiveform </a> </li>
    <li> <a href="#crud"> crud </a> </li>
    <li> <a href="#form-crud"> form validation, crud </a> </li>
    <li> <a href="#empw-api"> Employee crud without api </a> </li>
    <li> <a href="#emp-api"> Employee crud with api </a> </li>
    <li> <a href="#reusable"> Component Reusable </a> </li>
    
      <li class="borderline"><a href="#">  </a></li>
	  <li> <a href="#rxjs"> Rxjs </a> </li>
    <li> <a href="#rxjsoperator"> Rxjs Operators (Map, Switch map, Concate Map, Mergemap, DebounceTime, pluck, Filter) </a> </li>
		<li><a href="#error"> Error Handling </a></li>
	  <li> <a href="#rxjssubject"> Rxjs subject </a> </li>
      <li> <a href="#ngrx"> Ngrx, Transition between two states </a> </li>
	  <li> <a href="#life-cycle"> life-cycle </a> </li>
      <li> <a href="#services"> Services </a> </li>
      <li> <a href="#interceptor"> Interceptor  </a> </li>
      <li> <a href="#di"> Dependancy injection </a> </li>
      <li> <a href="#class"> Class </a> </li>
       
      <li> <a href="#apiservices"> API </a> </li>
      <li> <a href="#aot"> AOT </a> </li>
      <li> <a href="#signals"> signals </a> </li>   
		<li> <a href="#graphql"> graphql </a> </li>	  
      <li> <a href="#vresion-upgrade"> how to upgrade </a> </li>
	   <li class="borderline"><a href="#">  </a></li>

        <li> <a href="#chart"> chart </a> </li>
	  <li> <a href="#microfronted"> Microfronted </a> </li>
	  <li> <a href="#material"> Angular Material </a> </li> 
	  <li> <a href="#prime"> PrimeNg </a> </li>
      <li> <a href="#filter"> Filter </a> </li>
      <li> <a href="#pagination"> pagination </a> </li>
      <li> <a href="#login-setup"> login-setup </a> </li>
      <li> <a href="#json"> json </a> </li>
      <li> <a href="dom"> DOM Manipulation </a></li>
	   <li> <a href="#scrolltop"> scrolltop </a> </li>
      <li> <a href="#add-remove"> add remove </a> </li>
		<li> <a href="#test"> Angular Test casing  </a> </li>
		<li> <a href="#spying"> spying </a> </li>
		<li> <a href="#git"> GIT AND GITHUB </a> </li>
		<li> <a href="#google"> Google Cloud </a></li>
		<li> <a href="#azile"> Azile Methodology </a></li>
		<li> <a href="#web"> Web Optimization? </a></li>
		<li> <a href="#asetup"> Angular Setup </a></li>
		
    </ul>

 <h2 class="mt-4">INTRO</h2>   
<div class="box shadow p-2 mb-3">
As a UI and Frontend Developer, my primary role was to design, develop, and optimize complex user interfaces for web applications. I worked with Angular to build reusable components, implement routing, handle state management, and integrate APIs. <br>
In addition to frontend development, I have strong design skills and experience working with Figma and Photoshop. I have designed UI layouts, website templates, and even complete dashboards for admin panels, ensuring intuitive and user-friendly interfaces. <br>
I was responsible for creating and maintaining UI architectures, optimizing application performance, and ensuring cross-browser compatibility. I also implemented custom Angular directives, pipes, and services to enhance code reusability and maintainability.
Moreover, I followed best practices in CSS frameworks like Tailwind and Bootstrap to ensure responsiveness and accessibility.
</div>

<div class="box shadow p-2 mb-3" id="angularjs">
  <h2> ANGULAR and ANGULAR JS different between </h2>
<p> 
  AngularJS = v1.x <br>
  Angular = v2 and above (latest is v17 as of 2025)
</p>
<p> 
  AngularJS = JavaScript <br>
  Angular = TypeScript (superset of JavaScript)
</p>
<p> 
  AngularJS = MVC (Model-View-Controller)	 <br>
  Angular = Component-based architecture
</p>
<p> 
  AngularJS = Not mobile-friendly	 <br>
  Angular = Built with mobile-first in mind
</p>
<p> 
  AngularJS = Slower (due to two-way binding and digest cycle) <br>
  Angular = Faster (thanks to one-way data binding and Ivy compiler)
</p>
<p> 
  AngularJS = Two-way binding (default) <br>
  Angular = One-way binding (by default, can do two-way)
</p>
<p> 
  AngularJS = Done directly in controllers <br>
  Angular = Handled via directives and templates
</p>
  </div>

<div class="box shadow p-2 mb-3" id="asetup">
  <h2> ANGULAR Setup </h2>
  
  npm install -g @angular/cli <br>
ng new project-name> <br>
cd my-first-angular-app <br>
npm start<br>
<br>

After got error follows below step<br>
Error: Could not find the '@angular-devkit/build-angular:dev-server' builder's node package.<br>
<br>
<br>
rm -rf node_modules package-lock.json<br>
npm cache clean --force<br>
npm install<br>

<br>
------------------
<br>
routing Setup<br>
<br>
import { Routes } from '@angular/router';<br>
import { LoginComponent } from './login/login.component';<br>
import { DashboardComponent } from './dashboard/dashboard.component';<br>
<br>
export const routes: Routes = [<br>
    {path: '', component: LoginComponent},<br>
    {path: 'dashboard', component: DashboardComponent}<br>
];
<br>
---------------------------
<br>
app.component.html<br>
router-outlet>/router-outlet><br>



 </div>


<div class="box shadow p-2 mb-3" id="mvc">
  <h2> ANGULAR BASIC </h2>
<p><strong>  MVC and MVVM (Model-View-ViewModel)  </strong></p>
<p> ** MVC (Model-View-Controller) is a design pattern that separates an application into three main components:
  <ol>
    <li> <strong> Model: </strong> Represents data and business logic (e.g., database, API). </li>
    <li> <strong> View: </strong> The UI layer that displays data to the user. </li>
    <li> <strong> Controller: </strong> Manages user inputs and updates the Model or View. </li>
  </ol>
</p>
<p> ** <strong> HOW WORK MVC  </strong>
  1. The Controller receives user input (e.g., a button click).
  2. The Controller updates the Model (business logic).
  3. The Model notifies the View, and the View updates accordingly. 
</p>
<p>
      <strong> MVVM </strong> 
     <p> <strong> MVVM (Model-View-ViewModel) </strong> is a software architectural pattern that is commonly used in Angular applications, providing a clean separation of concerns between different components of an application. </p> 
     <p> <strong> Model -  </strong>Represents the application’s data and logic, It is the part of the application that manages the state, and it can be composed of services, APIs, </p>
     <p> <strong>View :- </strong> Represents the UI (user interface) elements that the user interacts with, such as buttons, inputs, forms, etc. | View is typically defined using HTML and CSS, and it’s tied to the template of a component. </p> 
     <p> <strong> ViewModel :- </strong> ViewModel holds the data and logic needed to present the Model’s data in a way that the View can easily display.  It is represented by the component in Angular, which binds the data and defines the behavior that will be reflected in the view. two-way data binding (via ngModel) allows the ViewModel. </p> 
</p>
</div> 

<div class="box shadow p-2 mb-3" id="why">
<h2 id="component"> What are some of the advantages of Angular over other frameworks? </h2>
<ul>
  <li> <strong> Features that are provided out of the box - </strong> Angular provides a number of built-in features like routing, state management, rxjs library and http servicesstraight out of the box. This means that one does not need to look for the above-stated features separately. They are all provided with angular. </li>
  <li><strong>  Declarative UI -</strong> Angular uses HTML to render the UI of an application. HTML is a declarative language and is much easier to use than JavaScript. </li>
  <li> <strong> Long-term Google support - </strong> Google announced Long-term support for Angular. This means that Google plans to stick with Angular and further scale up its ecosystem. </li>
</ul>
</div>
  
<div class="box shadow p-2 mb-3" id="angular-react">
<h2 id="component"> Angular and React difference </h2>
Angular
<p> Full-fledged framework	 </p>
<p> Uses TypeScript by default	 </p>
<p> Architectural - MVC-style, services, DI, etc	 </p>
<p> Built-in services & RxJS </p> 
React 
<p> Just a library for UI </p>
<p>  Uses JavaScript (TS optional) </p>
<p> Easier to start – more flexible </p>
<p> Flexible – you choose tools & structure
 </p> 
</div>

<h2 id="component"> COMPONENTS </h2>
<div class="box shadow p-2 mb-3" id="component">
<p> Angular Component is the building block of every Angular application. Every angular application is made up of one more Angular Component. </p>
<pre><code> 
  import { Component } from '@angular/core';

  @Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet],
  templateUrl: './app.component.html',
  styleUrl: './app.component.css'
}) 

export class NgforComponent {}

</code> </pre>
<p> @Component: A decorator used to convert a normal Typescript class to Angular Component.
</p>
</div>



<div class="box shadow p-2 mb-3" id="root">
<p> <strong> app-root: </strong> It is the selector/name of the component and it is specified using selector meta data of the component's decorator. </p>  
 <p> <strong> app.component.html: </strong> It is the HTML template document associated with the component. </p> 
 <p> <strong> AppComponent: </strong> Its property (title) is used in the HTML template to set the title of the application. </p> 
</div>

<div class="box shadow p-2 mb-3" id="encapsulation">
  <h2> View Encapsulation </h2>
<p> View Encapsulation in Angular controls how styles (CSS) are applied to components </p>
<p> Normally in HTML/CSS, styles are global — meaning CSS from one part of your app could affect other parts.
Angular provides View Encapsulation to help isolate component styles. </p>
</div>



<div class="box shadow p-2 mb-3" id="scope">
  <h2> SCOPE </h2>
<p> In Angular, a scope is an object that refers to the application model. It is a context in which expressions can be executed. These scopes are grouped hierarchically, comparable to the DOM structure of the application. A scope aids in the propagation of various events and the monitoring of expressions. </p>

</div> 

<div class="box shadow p-2 mb-3" id="template">
<h2> TEMPLATE </h2>
<p>   Template is basically a super set of HTML. Template includes all the features of HTML and provides additional functionality to bind the component data into the HTML and to dynamically generate HTML DOM elements. <br> 
<strong> Template can be categorised into two items :- </strong> <br> 
  Data binding {{ title }}, Directives *ngIf="canShow" </p>
  
<h2> Template Variable </h2>
<p>  template variable is a reference to a DOM element or Angular component/directive defined in your HTML template, and it is used within that template only. </p>
<pre>
<code>
input #myInput type="text">
---------
input #username type="text">
button (click)="log(username.value)">Log Username button>
------
with angular compoent <br>
app-child #childComp> app-child>
button (click)="childComp.doSomething()">Call Method button>

</code>
</pre>
</div>

<div class="box shadow p-2 mb-3" id="jse">
<h2> Difference Between AngularJS and JavaScript Expressions </h2>
<p> <strong> AngularJS Expression </strong> <br>
Executed in the context of AngularJS scope (e.g., component/controller).
<br> 
Used inside {{ }} or directives like ng-bind, ng-if, <br>
Does not support if, for, while, etc. <br>
{{ 2 + 2 }}, {{ user.name }}, ng-if="user.isLoggedIn"
</p>
<p> <strong> JavaScript Expression </strong> <br> 
Executed in the context of the global window object or current function. <br> 
Used directly in JS code (e.g., if (a > b), console.log(x + y)). <br>
Fully supports all control structures. <br>
2 + 2, user.name, if(user.isLoggedIn) { ... }

</p>
</div>



<div class="box shadow p-2 mb-3" id="modules">
<h2>  MODULES, Bootstrap </h2>
<p> Angular Module is basically a collection of related features/functionality. It groups multiple components and services under a single context. </p>
<pre>
  <code>
    import { BrowserModule } from '@angular/platform-browser'; 
    import { NgModule } from '@angular/core'; 
    import { AppComponent } from './app.component'; @NgModule({ 
    declarations: [ 
      AppComponent 
     ], 
     imports: [ 
      BrowserModule 
     ], 
     providers: [], 
     bootstrap: [AppComponent] 
     }) 
     export class AppModule { }
  </code>
</pre>
<ol>
  <li> <strong> NgModule </strong> decorator is used to convert a plain Typescript/JavaScript class into Angular module. </li>
  <li> <strong> declarations: [AppComponent] </strong> - Declarations option is used to include components into the AppModulemodule. </li>
  <li> <strong> bootstrap: </strong> [AppComponent], Bootstrap option is used to set the root component of the AppModulemodule. </li>
  <li> <strong> providers: [], </strong> Providers option is used to include the services for the AppModulemodule. </li>
  <li> <strong> import{} </strong> imports option is used to import other modules into the AppModulemodule. </li>
  </ol>
</div>

<div class="box shadow p-2 mb-3" id="services">
<h2>  SERVICES </h2>
<p>   Services are plain Typescript/JavaScript class providing a very specific functionality. They will do a single task and do it best. The main purpose of the service is to make a certain feature reusable. </p>
</div>

<div class="box shadow p-2 mb-3" id="metadata">
  <h2>  METADATA </h2>
  <p>  Angular, metadata is used to provide additional information about a class, component, or service. </p>
  </div>


  <div class="box shadow p-2 mb-3" id="angularrun">
    <h2>  How to run angular Project ? </h2>
    <p> When we run Angular application on the browser after that first file index.html loaded. Then, <br> 
      <strong> Browser </strong> looks the main <strong> TypeScript file, main.ts </strong> <br> 
      so there is the entry point of Angular application. <br> after than
      bootstraps file <strong> <br>
      than AppComponent (src/app.component.ts), </strong> <br> 
      the root component of every Angular application. <br> 
      The AppComponent renders its template (src/app.component.html) and uses the styles (src/app.component.css). <br> 
      <strong> AppComponent </strong> name, i.e., app-root is used inside the <strong> src/index.html </strong> 
      so that view of the angular application can be rendered. </p>
      <ol>
        <li> <strong> NgModule </strong> decorator is used to convert Typescript class into Angular module. </li>
        <li> <strong> declarations: [AppComponent] </strong> - Declarations option is used to include components into the AppModulemodule. </li>
        <li> <strong> bootstrap: </strong> [AppComponent], Bootstrap option is used to set the root component. </li>
        <li> <strong> providers: [], </strong> Providers option is used to include the services . </li>
        <li> <strong> import{} </strong> imports option is used to import other modules into the AppModulemodule. </li>
        </ol>
  </div>


  <div class="box shadow p-2 mb-3" id="angularcli">
    <h2>  ANGULAR CLI </h2>
    <p>   Angular CLI (Command Line Interface) is a powerful tool that helps automate and streamline the development process for Angular applications. It provides a set of commands for creating, managing, and building Angular projects. </p>
  </div>

  <div class="box shadow p-2 mb-3" id="angularcontroller">
    <h2>  Controllers in Angular </h2>
    <p> In AngularJS (Angular 1.x), controllers were used to manage the application's logic and data binding. However, in modern Angular (2+), controllers are replaced by components. </p>
  </div>

  <div class="box shadow p-2 mb-3" id="angularspa">
    <h2>  SPA and CHALLENGING WORK / SHARED SERVICES </h2>
    <p>  Single Page Application (SPA) is a web application that dynamically updates content without reloading the entire page. 
      Faster Page Loads ,  Smooth User Experience, Efficient Data Fetching <strong> Examples - GMAIL, FACEBOOK, NETFLIX, TWITTER </strong> </p>
    <h2> CHALLENGING WORK </h2>
      <p> I was working on an Angular project where we used a reactive form with a select box for gender (Male and Female) multiple times across different components. Later, we realized that instead of repeating the same logic, we could create a reusable service for gender options, making the implementation more efficient and maintainable. </p>

    <h2> SHARED SERVICES  </h2>
    <pre>
      <code>
        genders = [
            {"id": "male", "name": "Male"},
            {"id": "female", "name": "Female"},
            {"id": "other", "name": "Other"}
          ]

        select 
        option -  *ngFor="let gender of genders" value="{{gender.id}}" ,  {{gender.name}}
          
      </code>
    </pre>
  </div>


  <div class="box shadow p-2 mb-3" id="architecture">
    <h2> Angular Architecture </h2>
    <p>   Angular is a front-end framework developed by Google for building dynamic single-page applications (SPAs). <br> It follows a component-based architecture where the entire application is structured into modular, reusable components. <br> At its core, Angular applications are made up of modules, components, templates, directives, services, and dependency injection.<br> The root module, typically named AppModule, acts as the entry point of the application and can include multiple feature modules to organize different functionalities. These modules help in maintaining scalability by dividing the application into separate logical parts. </p>
    <p>  A component in Angular is the fundamental building block of the UI. <br> Each component consists of three parts: an HTML template that defines the structure, a TypeScript class that contains business logic, and a CSS file that handles styling.  </p>
    <p>  To enhance the functionality of templates, Angular provides directives. Structural directives, such as *ngIf and *ngFor, modify the DOM by adding or removing elements dynamically, while attribute directives, such as [ngClass] and [ngStyle], change the appearance or behavior of elements. Additionally, pipes are used to transform and format data within templates. </p>
    <p>  Services are singleton objects that can be injected into multiple components using Angular’s dependency injection (DI) system. This ensures better code reusability and separation of concerns. For handling HTTP requests. </p>
    <p>  One of Angular’s most powerful features is routing, which enables navigation between different views without requiring a full page reload. The RouterModule manages the application’s routes and allows users to define URL-based navigation paths for different components. </p>
    <p> Under the hood, Angular’s change detection mechanism optimizes performance by updating only the necessary parts of the UI when data changes. It employs a unidirectional data flow with the ability to detect and update changes efficiently.  </p>
    <p> Overall, Angular’s structured approach, modularity, and built-in functionalities make it an ideal choice for developing large-scale enterprise applications.  </p>
  </div>

    <div class="box shadow p-2 mb-3" id="life-cycle">
      <h2> LIFE CYCLE </h2>
      <p> <strong> Lifecycle hooks in Angular are special methods that get called at different stages of a component’s lifecycle. </strong></p>

      <ol>
        <li> <strong> constructor </strong> - for variable initialization </li>
        <li> <strong> ngOnChanges() </strong> -  Called when input properties change </li>
        <li> <strong> ngOnInit(){}  </strong> - Called once after component initialization </li>
        <li> <strong> ngDoCheck() </strong> - Called during every change detection cycle </li>
        <li> <strong> ngAfterContentInit() </strong> - Called after content projection (<ng-content>) is initialized </li>
        <li> <strong> ngAfterContentChecked()</strong> - Called after projected content is checked </li>
        <li> <strong> ngAfterViewInit() </strong> -  This hook is called after Angular has fully initialized the component's view <br> 
          (i.e., after the HTML template is rendered and child components are loaded). </li>
        <li> <strong> ngAfterViewChecked() </strong>	- Called after the component’s and child views are checked </li>
        <li> <strong> ngOnDestroy() </strong> Called just before the component is destroyed </li>
      </ol>
	  <p>
	  You should use ngAfterViewInit() when: <br>
You need to interact with the DOM (e.g., via @ViewChild) <br>
You need to trigger logic that depends on the fully initialized view <br>
Like measuring elements, integrating third-party libraries, animations, etc.
</p>
      <pre>
        <code>
          <h2> ngOnChanges() </h2>
          Examples - 
          => Child component --- 
          @Input() item: any;
          ngOnChanges(){
          alert("Data has been updated by parent component...")
          }
          HTML -- 
          {{item}}
      
       => PARENT COMPONENT
          name = 'coding'
          fun(){
           this.name = "Value has been chaged"
           }
          HTML --- 
          app-child item={{name}}> app-child
          button click="fun()"> click me button
        </code>
      </pre>
      </div>


      <div class="box shadow p-2 mb-3" id="optimize">
        <h2> OPTIMIZE ANGULAR PAGE </h2>
        <p> <strong> Use of Loaders everywhere possible </strong> Whenever API is call in is progress we need to show loader. So that user will know something is process going on. </p>
        <p> <strong> Avoid duplicate API call. </strong> For example, when creating a user or employee record, after filling in all the required fields and clicking the "Save" button, an API call is triggered. However, if the "Save" button is clicked multiple times quickly, multiple API requests are sent. It will be increases the loading time and server load.
          That's why we need api call in codition that onetime call on click.  </p>
        <P><strong> Use Pagination for Large Data Sets </strong> When retrieving large amounts of data from an API, it's important to implement pagination. Instead of loading all records at once, we should load a limited number of items as 10 or 20 per page—and fetch more data as the user navigates through the pages. This approach helps optimize loading time and improves overall performance and user experience. </P>
        <p> <strong> Create Reusable Services for Common Form Data </strong> For example, if I'm using a reactive form with a gender dropdown (e.g., "Male" and "Female"), and this dropdown is required in multiple forms across the application, it's a good practice to create a reusable service to provide the gender options. This way, instead of duplicating the same code in every form, we can fetch the gender list from a single source. This improves code reusability, maintainability, and keeps the codebase clean and optimized. </p>
        <p>
          <strong> Delegate Certain Logic to the Backend for Better Frontend Performance </strong>
          Some logic or conditions should be handled on the backend to reduce the complexity and data load on the frontend. For example, implementing pagination on the backend ensures that only a limited set of data is sent to the frontend at a time. This helps improve performance, reduces loading time, and keeps the frontend code simpler and more efficient.
        </p>
        <ol>
          <li> Optimize Change Detection </li>
          <li> Lazy Loading </li>
          <li> Reduce Bundle Size ( AOT AHEAD OF TIME ) </li>
          <li> Optimize Third-Party Libraries </li>
          <li> Optimize CSS & Styles, Otimize http, Minimize CSS & Use Critical CSS, CSS minification, Web Workers </li>
          <li> USE track by </li>
        </ol>
        <pre>
          <code>
            *ngFor="let item of items; trackBy: trackByFn">{{ item.name }}
              this.http.get('https://api.example.com/data', { cache: 'force-cache' });
          </code>
        </pre>
        </div>


        <div class="box shadow p-2 mb-3" id="accessibility">
          <h2> Accessibility (A11Y) </h2>
          <p> Make your UI inclusive for everyone (including users with disabilities). </p>
          <p> Add alt text for images. </p>
          <p> Use ARIA attributes for better screen reader support. </p>
          <p> Ensure high color contrast for readability </p>
          <p> Minify CSS, JS and enable Gzip compression. </p>
          <pre><code> const routes: Routes = [
            { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) },
            { path: '**', redirectTo: 'feature' } // Wildcard route (optional)
          ]; </code></pre>
         </div>


         <div class="box shadow p-2 mb-3" id="apiservices">
          <h2> API CALL RESTful APIs -- API serives  </h2>
          <p> Angular, RESTful APIs allow the frontend to communicate with a backend server by making HTTP requests. Angular provides the HttpClient module to perform CRUD (Create, Read, Update, Delete) operations with APIs. </p>

<h2> Why Do We Use APIs in Angular Projects? </h2>
API = Application Programming Interface <br>
In Angular (a frontend framework), APIs allow your app to talk to a backend server or external services to:<br>
✅ 1. Get Data<br>
Example: Fetch product details, user info, or blog posts from a database through an API.<br>

✅ 2. Send Data<br>
Example: When a user submits a form (like login, registration), the data is sent via an API to the server.<br>
<br>
✅ 3. Update or Delete Data<br>
API allows your app to update or delete something in the backend (e.g., edit a profile, delete a comment).<br>
<br>
✅ 4. Secure & Scalable<br>
APIs enforce security, validation, and rules.<br>
<br>
The backend handles heavy logic, so Angular only deals with UI/UX.<br>

<h2> How Important is API in Angular? </h2>
<p> <strong> Very Important! </strong></p>
<p> Without APIs: Your Angular app is static – it can't fetch or update live data. </p>
<p> You can’t store user info, login users, or interact with databases. </p>

<h2> Common API Tools in Angular: </h2>
<p> HttpClientModule for making API requests </p>
<p> HttpClient.get(), post(), put(), delete() </p>
<p> Uses Observables to handle async responses </p>

          <pre><code>
            ngOnInit() {
              this._http.get('users/user/details/'+this.user_id).subscribe((resposne: any) => {
                this.user = resposne.user
                console.log(resposne);
              })
            }
          </code></pre>
          </div>


          <div class="box shadow p-2 mb-3" id="validation">
            <pre><code>
              lead_form!: FormGroup
lead_fields = {
  name     : ['', Validators.required],
  email    : ['', Validators.required],
}
constructor( private _fb    : FormBuilder ){
  this._route.queryParams.subscribe(params => { this.tenant_id = params['id']})
}
ngOnInit(){this.initializeForm()}
initializeForm(){
  this.lead_form = this._fb.group(this.lead_fields)
  this.getLeads()
}
getLeads(){
  let params = [{"key": "tenant_id", "value": this.tenant_id},{"key": "limit", "value": 100}]
  this._http.get('leads/leads/', params).subscribe((response:any) => {
    this.leads = response;
    this.action = "Add"
  },(error: any) => {this.errorMessage(error)})
}
            </code></pre>
          </div>


          <div class="box shadow p-2 mb-3" id="crud">
  <h2> CRUD </h2>
  CREATE 
  <pre><code>
    
  createLead(){
    this._http.post('leads/leads/', this.setPayload(this.lead_form.value)).subscribe((response: any) => {
      this.afterAction("Lead Saved")
    },(error: any) => {this.errorMessage(error)})
  }
  
  EDIT
  setPayloadForEdit(form: any){
    return {
      "name"     : form.name,
      "email"    : form.email,
    }
  }
  editLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)

    // delete payload.tenant_id
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)})
  }


  updateLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)
    // delete payload.tenant_id
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)})
  }

  deleteLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    this._http.delete('leads/leads/'+this.lead_id, params).subscribe((response:any) => {
      this.afterAction("Lead Deleted")
    },(error: any) => {this.errorMessage(error)})
  }
  </code></pre>
</div>



<div class="box shadow p-2 mb-3" id="upgrade">
<h2> HOW TO UPGRADE OLD VERSION TO NEW VERSION </h2>  
<div>
=> Always backup your project before upgrading.
=> Use Git commits to track changes at each step.
1. Check the Current Angular Version <br>
ng version
2. Update Angular CLI Globally <br>
npm install -g @angular/cli 
3. ng update @angular/core@16 @angular/cli@16 <br>
4. Update Other Dependencies <br>
ng update
-------------
You should upgrade step by step from Angular 15 → 16 → 17 → 18 → 19 rather than jumping directly from Angular 15 to Angular 19.
If You Try Directly Updating from 15 to 19? <br>
1. dependency conflicts and errors. <br>
2. Some configurations (like angular.json) might break due to missing intermediate updates. <br>
3. Third-party libraries might not support Angular 19 <br>
</div>
</div>


<div class="box shadow p-2 mb-3" id="rxjs">
  <h2> RxJS for Reactive Programming (RxJS) </h2>

  <p> RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables. 
    It's used in Angular to handle asynchronous operations, events, and data streams. </p>

    <p><strong> Rxjs use in HTTP Request, Reactive Forms, Routing(params, guards), Event management, State Management </strong></p>

    <p> Rxjs operator - map, filter, etc </p>
    <p> Benefits - Powerful data transformation using operators</p>

  <pre>
    <code>
      <h2> Simple examples </h2>

      import { Observable } from 'rxjs';

let observable = new Observable((observer) => {
  setTimeout(() => {
    observer.next("Observable is working");
    observer.complete();
  }, 2000);
});

observable.subscribe({
  next: (result) => console.log(result),
  complete: () => console.log("Observable Completed")
});

    </code>
  </pre>

<p><strong> JavaScript Promises make handling asynchronous operations like API calls, file loading, or time delays easier. </strong></p> 
<p> Difference between </p>  

 <strong> Promise -- </strong>  
// Promise excute immediately when create promises. <br>
// Pomise emit single value. Promise don't have operator . <br>
// Promise cann't be cancel  <br>
<strong> Observable -- </strong> 
// Observable does not start untill subscription. <br> 
// Observable emit multiple value.<br>
// Observable operator like map, filter, reduce. <br>
// Observable can be cancel using unscribe method <br>

<h2 class="mt-4"> * Promises - A Promise in JavaScript represents a value that may be available now, in the future, or never. </h2>
<pre>
  <code>
    let myPromise = new Promise((resolve, reject) => {
      let success = true; // Change this to false to see the reject case
      setTimeout(() => {
        if (success) {
          resolve("Operation Successful!");
        } else {
          reject("Something went wrong!");
        }
      }, 2000);
    });
    myPromise
      .then(result => console.log(result)) // Runs when promise is resolved
      .catch(error => console.log(error)); // Runs when promise is rejected  
  </code>
</pre>

<p> <strong> Observable is a stream of data that can emit multiple values over time. You can subscribe to an Observable to receive these values. </strong></p>

<pre><code>
  myObservable: Observable<number>;
    ngOnInit() {
      this.myObservable = new Observable(observer => {
        let count = 1;
        setInterval(() => {
          observer.next(count++); // Emits a value every second
        }, 1000);
  
      });
      this.myObservable.subscribe(value => {
        console.log('Received:', value);
      });
    }
</code></pre>

<h2> RxJS Operators </h2>
<p><strong> Filtered Values: {{ values }} </strong></p>

<pre><code>
  ngOnInit() {
    const numbers$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9);
    numbers$.pipe(
      filter(num => num % 2 === 0), // Filter even numbers
      map(num => num * 10) // Multiply each by 10
    )
    .subscribe(result => {
      this.values.push(result);
    });
  }
</code></pre>

<pre>
  <code>
    let observable = new Observable((observer) => {
      setTimeout(() => {
        observer.next("observable is working");
        observer.complete();
      }, 1000)
      })
      
      observable.subscribe({
        next: (result) => console.log(result),
        complete: () => console.log("Observable completed")
      })
  </code>
</pre>

<h2> Example: Converting Promise to Observable </h2>
<pre><code>
  const promise = new Promise((resolve) => {
    setTimeout(() => resolve('Promise resolved!'), 2000);
  });

  // Convert Promise to Observable

  const observable$ = from(promise);
  observable$.subscribe(value => console.log(value));
</code></pre>

<h2> Handling HTTP Request with Observable vs Promise </h2>
<pre>
  <code>
    getData(): void {
      fetch('https://jsonplaceholder.typicode.com/posts')
        .then(response => response.json())
        .then(data => console.log(data))
        .catch(error => console.error(error));
    } 
  </code>
</pre>

<h2> Observable with Multiple Values </h2>
<pre>
  <code>
    const myObservable = new Observable(observer => {
      observer.next('Value 1');
      observer.next('Value 2');
      setTimeout(() => {
        observer.next('Value 3 (after delay)');
        observer.complete(); // Ends the stream
      }, 2000);
    });
    myObservable.subscribe(value => console.log(value));
  </code>
</pre>

<h2>  Cancelling an Observable </h2>
<pre><code>
  const observable$ = interval(1000); // Emits values every second
  const subscription: Subscription = observable$.subscribe(value => console.log(value));
  setTimeout(() => {
    console.log('Unsubscribing...');
    subscription.unsubscribe(); // Stops emissions
  }, 5000);
</code></pre>

</div>


<div class="box shadow p-2 mb-3" id="rxjsoperator">
<h2> RxJS Operators All Defination</h2>
<p> <strong> Map </strong> Map operator use for our data transform according to need. 
  We get any data we can change by map operator and it return new observable with modify data . </p>
<p> <strong> Filter </strong> - filter operator emits only those values from the source Observable that pass a specified condition (predicate). </p>
<p> <strong> Forkjoin </strong> - forkJoin is used to run multiple HTTP requests in parallel and get all their results once all are completed. </p>
<p><strong> SwitchMap </strong> - switchMap is an RxJS operator used to switch to a new observable every time the source emits a value. If a new value comes in before the previous inner observable completes, switchMap cancels the previous one and switches to the latest. </p>
<p> <strong> ConcatMap </strong> concatMap is an RxJS operator that maps each value to an inner observable, queues them, and subscribes to them one after the other — maintaining the order and waiting for each one to complete before moving to the next. </p>
<p><strong> MergeMap </strong> - mergeMap operator is basically a combination of two operators – merge and map. mergeMap emitted value to inner observable and will subscribe to all observables and merge. </p>
<p><strong>DebounceTime</strong> - DebounceTime is an RxJS operator It waits for the user to stop typing for a certain time before doing anything.</p>
<p><strong> pluck </strong> - Pluck is an RxJS operator that lets you pull out a specific property (or nested property) from each emitted object. </p>

----------------------------- 
  <h2> RxJS Operators </h2>
  <h2> Map </h2>
  <p> <strong> rxjs map() transforms each item emitted by an Observable. </strong> 
 <br>  Map operator use for our data transform according to need. 
  We get any data we can change by map operator and it return new observable with modify data . <br>
  example - map(data => transform)
  </p>
  
  <p> <strong> From </strong>  Basically coverts array data (any data iterable) into an observable. meaning it will emit each item if the array one by one, in sequence </p>
  
<hr>
  <pre>
    <code>

export class MapComponent {

  sub1!: Subscription
  msg1: any

  sub2!: Subscription
  msg2: any

 constructor(){}

 ngOnInit(){

  //Simple Examples 01

  const broadCastingVideo = interval(1000)

  this.sub1 = broadCastingVideo.pipe(
    map(data => 'Video '+ data)
  )
  .subscribe((response: any) => {
    console.log(response);
    this.msg1 = response;
  })

  setTimeout(() => {
    this.sub1.unsubscribe()
  }, 10000)


 //Map Logic Examples 02

 this.sub2 = broadCastingVideo.pipe(
  map(data => 'Video '+ data * 10)
 )
 
 .subscribe((response: any) => {
  this.msg2 = response
 })

 setTimeout(() => {
  this.sub2.unsubscribe()
 }, 10000)


  //Examples 03 For Objects

  const members = from([
    {id: 1, name: 'Anup'},
    {id: 1, name: 'Pankaj'},
    {id: 1, name: 'Tanmay'},
    {id: 1, name: 'Ashish'},
    {id: 1, name: 'Husnain'},
    {id: 1, name: 'Rajesh'},
    ])

    members.pipe(
      map(data => data.name)
    )
    .subscribe((response: any) => {
      console.log('Check--->', response);
    })

 }
    
  
}

HTML ===
{{msg1}}




       -------------
	   --------------

       Nested Object 

       const source = of({ address: { city: 'New York' } }, { address: { city: 'London' } });
    
    const example = source.pipe(
      map(value => value?.address?.city)
    );
    
    example.subscribe(city => console.log(city));

    </code>
  </pre>

<hr>

<h2> Filter by Employee data, Maxmimum salary, name length, search </h2>
<p> <strong> filter operator emits only those values from the source Observable that pass a specified condition (predicate). </strong></p>
<pre>
<code>

  filterEmployee: any = []
  searchText: any;

  constructor(){}

  ngOnInit(){
    this.employeeDetails()
  }

  employees = [
  { name: 'Alice', designation: 'Developer', salary: 70000 },
  { name: 'Bob', designation: 'Manager', salary: 90000 },
  { name: 'Charlie', designation: 'Intern', salary: 30000 },
  { name: 'Diana', designation: 'Developer', salary: 80000 }
];

employeeDetails(){
  this.filterEmployee = this.employees.filter(employee => employee.salary < 90000 )
  //this.filterEmployee = this.employees.filter(employee => employee.name.length > 3 )
}
------------------
  // RXJS FILTER OPERATOR 
  // employeeDetails() {
  //   from(this.employees).pipe(
  //     filter(emp => emp.name.length > 3),
  //     toArray() // Collect filtered results into an array
  //   ).subscribe(filtered => {
  //     this.filterEmployee = filtered;
  //     console.log('Filtered Employees:', this.filterEmployee);
  //   });
  // }
------------------ 
  // RxJS Filter Employees with Salary Greater Than X
  // employeeDetails(){
  //   from(this.employees).pipe(
  //     filter(emp => emp.salary > 75000),
  //     toArray()
  //   ).subscribe(res => this.filterEmployee = res);
  // }
------------------
  // // RxJS Filter by Designation (e.g., Only Developers)
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp => emp.designation === 'Developer');
  // }
------------------
  // RxJS Filter by Name Starting with a Specific Letter
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp => emp.name.startsWith('A'));
  // }
------------------
   // RxJS Filter by Multiple Conditions (e.g., Developer with High Salary)
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp =>
  //     emp.designation === 'Developer' && emp.salary > 75000
  //   );
  // }
------------------
    // RxJS Search Employees by Name (Dynamic)
  // employeeDetails(){
  //   this.filterEmployee = this.employees.filter(emp =>
  //     emp.name.toLowerCase().includes(this.searchText.toLowerCase())
  // );
  // }
------------------
  //RxJs Highest Score
  // employeeDetails(){
  // this.filterEmployee = [...this.employees]
  // .sort((a, b) => b.salary - a.salary)
  // .slice(0, 3);  // top 3
  // }
  
  ------------------
  
  HTML 
  
  //input type="text" class="form-control" [(ngModel)]="searchText" (input)="employeeDetails()" placeholder="Search"
  
  table class="table table-bordered mt-4">
    thead>
        tr>
            td> Name </td>
            td> Designation </td>
            td> Salary </td>
        /tr>
    /thead>
    tbody>
        tr *ngFor="let employee of filterEmployee">
            td> {{employee.name}} </td>
            td> {{employee.designation}}  </td>
            td> {{employee.salary}}  </td>
        /tr>
    /tbody>
/table>

</code>
</pre>

<hr>

<h2> Forkjoin </h2>
<p><strong> forkJoin is used to run multiple HTTP requests in parallel and get all their results once all are completed. </strong></p>
<pre>
<code>
ngOnInit() {
    this.loadData();
  }

  loadData() {
    const userDetails = this.http.get('https://jsonplaceholder.typicode.com/users/1');
    const userPosts = this.http.get('https://jsonplaceholder.typicode.com/posts?userId=1');

    forkJoin([userDetails, userPosts]).subscribe(
      ([user, posts]) => {
        console.log('User Details:', user);
        console.log('User Posts:', posts);
      },
      error => {
        console.error('One of the requests failed:', error);
      }
    );
  }
</code>
</pre>


<hr>

  <h2> SwitchMap </h2>
  <p> switchMap is an RxJS operator used to switch to a new observable every time the source emits a value. If a new value comes in before the previous inner observable completes, switchMap cancels the previous one and switches to the latest. </p>
  <h2> Basic Examples </h2>

  <pre>
    <code>
      
import { Component } from '@angular/core';
import { HeaderComponent } from "../../../../header/header.component";
import { HttpSharedService } from '../../../../http-shared.service';
import { FormControl, FormsModule, NgForm, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { debounceTime, distinctUntilChanged, switchMap } from 'rxjs';

@Component({
  selector: 'app-switchmap',
  imports: [HeaderComponent, ReactiveFormsModule, CommonModule, FormsModule],
  templateUrl: './switchmap.component.html',
  styleUrl: './switchmap.component.css'
})
export class SwitchmapComponent {
  
  searchControl = new FormControl();
  products: any[] = [];

  constructor(private http: HttpSharedService) {}

  ngOnInit(): void {
  this.searchControl.valueChanges.pipe(
    debounceTime(300),
    distinctUntilChanged(),
    switchMap((term) => this.http.get(`products/search?q=${term}`))
  ).subscribe((res: any) => {
    this.products = res.products;
  });
  this.getProduct();
}

  getProduct() {
    this.http.get('products').subscribe((response: any) => {
      this.products = response.products;
    });
  }

}


HTML 

input
    type="text"
    [formControl]="searchControl"
    placeholder="Search..."
    class="form-control"
  />

    table class="table table-bordered mt-5" *ngIf="products.length">
        thead>
            tr>
                td> Product title /td>
                td> Product Brand /td>
                td> Product Category /td>
            /tr>
      /thead>
        tbody>
            tr *ngFor="let product of products">
                td> {{product.title}} /td>
                td> {{product.brand}} /td>
                td> {{product.category}} /td>
            /tr>
        /tbody>
    /table>

    </code>
  </pre>

  <h2>  Another Example switchMap : Chained API Calls </h2>
<pre>
  <code> this.route.params.pipe(
    switchMap(params => this.userService.getUserById(params['id']))
  ).subscribe(user => {
    console.log('User data:', user);
  });
  </code>
</pre>

<hr>

<h2> ConcatMap </h2>
<p> concatMap is an RxJS operator that maps each value to an inner observable, queues them, and subscribes to them one after the other — maintaining the order and waiting for each one to complete before moving to the next.</p>

<p> <strong> mergeMap vs concatMap </strong> </p>
meregeMap = Subscribes to all inner observables immediately	<br>
cancatMap = Waits for the previous inner observable to complete <br>
meregeMap = Faster overall <br>
cancatMap = Slower, but ordered <br>

<pre>
  <code>
    import { from } from 'rxjs';
import { concatMap, delay } from 'rxjs/operators';

from([1, 2, 3]).pipe(
  concatMap(val => {
    console.log('Requesting:', val);
    return of(`Processed ${val}`).pipe(delay(1000));
  })
).subscribe(result => console.log(result));

  </code>
</pre>

<h2> Real World Example </h2>
<pre>
  <code>
    saveUser(userData: any) {
      return this.http.post('/api/saveUser', userData);
    }
    
    notifyUser(userId: string) {
      return this.http.post(`/api/notifyUser/${userId}`, {});
    }
    
    doAll(userData: any) {
      of(userData).pipe(
        concatMap(data => this.saveUser(data)),
        concatMap((savedUser: any) => this.notifyUser(savedUser.id))
      ).subscribe(() => {
        this.router.navigate(['/dashboard']);
      });
    }
    
  </code>
</pre>
<h2> File upload que </h2>
<pre>
  <code>
    uploadFiles(files: File[]) {
      from(files).pipe(
        concatMap(file => this.uploadService.upload(file))
      ).subscribe(response => {
        console.log('Uploaded:', response);
      });
    }    
  </code>
</pre>

<hr>

<h2> MergeMap in Rxjs Angular, MergeAll  </h2>
<p> mergeMap operator is basically a combination of two operators – merge and map. 
mergeMap emitted value to inner observable and will subscribe to all observables and merge. </p>

<h2> Simple Examples </h2>
<pre>
<code>
export class MergemapComponent {

  getData(data: any){
    return of (data + 'Video Uploaded')
  }

  ngOnInit(){

     //Example 01

    const source = from(['Tech', 'Comedy', 'News']);
    source.pipe(
      map( response => this.getData(response))
    )
    .subscribe((response: any) => {
      console.log(response)
    })

    //.subscribe(response => response.subscribe( response2 => {
      //console.log(response2);
    //}))

     //Example 02 MergeAll

     source.pipe(
      map( response => this.getData(response)),
      mergeAll()
    )
    .subscribe((response: any) => {
      console.log(response)
    })

    //Example 02 Mergemap

     source.pipe(
      mergeMap( response => this.getData(response)),
    )
    .subscribe((response: any) => {
      console.log(response)
    })

  }
}
</code>
</pre>

<h2> Real-world Example in Angular: Parallel API Calls </h2>
<pre>
  <code>
    getUserById(id: number) {
      return this.http.get(`/api/users/${id}`);
    }
    
    fetchAllUsers(ids: number[]) {
      from(ids).pipe(
        mergeMap(id => this.getUserById(id))
      ).subscribe(user => {
        console.log('User:', user);
      });
    }
    
  </code>
</pre>

<hr>

<h2> DebounceTime </h2>
<p> debounceTime(ms) waits for a pause in emissions from the source observable.
  It only emits the latest value after the given time (in ms) has passed without another emission. </p>
<p> <strong>  DebounceTime is an RxJS operator It waits for the user to stop typing for a certain time before doing anything. </strong> </p>

<h2> Basic Examples </h2>
<pre>
  <code>
    import { fromEvent } from 'rxjs';
import { debounceTime, map } from 'rxjs/operators';

const input = document.getElementById('myInput');

fromEvent(input, 'input').pipe(
  map((e: any) => e.target.value),
  debounceTime(500)
).subscribe(value => {
  console.log('User stopped typing:', value);
});

  </code>
</pre>

<h2> Real-World Angular DebounceTime Example: Search Box </h2>
<pre>
  <code>
    import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';
import { debounceTime } from 'rxjs/operators';

@Component({
  selector: 'app-search',
  template: `input [formControl]="searchControl" placeholder="Search...">`
})
export class SearchComponent {
  searchControl = new FormControl();

  ngOnInit() {
    this.searchControl.valueChanges.pipe(
      debounceTime(300)
    ).subscribe(value => {
      console.log('Searching for:', value);
      // Call your API or service here
    });
  }
}

  </code>
</pre>

<hr>

<h2> pluck </h2>
<p> pluck is an RxJS operator that lets you pull out a specific property (or nested property) from each emitted object. </p>

<pre>
  <code>
    import { from } from 'rxjs';
import { pluck } from 'rxjs/operators';

const source$ = from([
  { name: 'Alice' },
  { name: 'Bob' },
  { name: 'Charlie' }
]);

source$.pipe(
  pluck('name')
).subscribe(name => console.log(name));


//output
Alice
Bob
Charlie
  </code>
</pre>

<h2> Another Example: From DOM Events </h2>
<pre>
  <code>
    import { fromEvent } from 'rxjs';
import { pluck } from 'rxjs/operators';

const input = document.getElementById('myInput');

fromEvent(input, 'input').pipe(
  pluck('target', 'value')
).subscribe(val => {
  console.log('Typed value:', val);
});

  </code>
</pre>

</div>

<div class="box shadow p-2 mb-3" id="error">
<h2> ERROR HANDLING </h2>

<p> Error handling in Angular means managing what happens when an HTTP request or some code fails — for example, if a server is down, the user enters wrong credentials, or the internet connection is lost. </p>

<p><strong> How Error Handling Works </strong></p>
<div>
<strong> Try to Make a Request </strong> <br>
Angular sends a request to the server (like saving data or logging in). <br>
<strong> Response Comes Back </strong> <br>
If the response is successful, Angular continues normally.<br>
But if something goes wrong (like a 404 or 500 error), it triggers the error block.<br>
<br>
<strong> Catch the Error </strong> <br>
Angular lets you "catch" the error and decide what to do — such as:<br>
Show a friendly error message to the user<br>
Log the error for debugging<br>
Retry the request<br>
Redirect to another page
<br>
<br>
</div>

<pre>
<code>
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';

this.http.get('https://api.example.com/data')
  .pipe(
    catchError(error => {
      console.error('Request failed:', error);
      return throwError(() => error);
    })
  )
  .subscribe();
  
...............

1. Create a Global Error Interceptor
intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        // Global error logic here
        console.error('HTTP Error:', error);

        if (error.status === 0) {
          this.toastr.error('Network error. Please check your connection.');
        } else if (error.status === 401) {
          this.toastr.error('Unauthorized. Please login.');
        } else if (error.error?.message) {
          this.toastr.error(error.error.message); // From server
        } else {
          this.toastr.error('Something went wrong.');
        }

        return throwError(() => error); // Rethrow the error
      })
    );
	
...............


createUser() {
  this.http.post('users/add', this.setPayLoad(this.user_form.value)).subscribe({
    next: (response: any) => {
      this.getUser();
      this.resetForm();
    },
    error: (err) => {
      console.error('Create user error:', err);
      // Handle error message - show to user
      this.errorMsg = err?.error?.message || 'Something went wrong while creating user.';
    }
  });
}


</code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="rxjssubject">
 <h2> SUBJECT </h2>
  <p> Subjects are a special type of Observable it allows values multicasted to many observers. 
  <br> it is Observable and observer also on same time. I can subscribe and emmit both in subject </p> 
  <p> <strong> Multicasted </strong> - Which we will start subscribe after then we get data. we can not get subscribe before data. just like Live stream.   </p>
  
  <h2> Behavior SUBJECT </h2>
  <p> BehaviorSubject is a special type of Subject. A Behavior Subject holds one value. When it is subscribed it emits the value immediately. </p>

  <pre>
    <code>
      import { BehaviorSubject } from 'rxjs';
      behaviorSubject = new BehaviorSubject<number>(0); // initial value is 0
      ngOnInit() {
      behaviorSubject.subscribe(value => console.log('Subscriber 1:', value)); // Subscriber 1: 0
      behaviorSubject.next(1); // Subscriber 1: 1
      behaviorSubject.subscribe(value => console.log('Subscriber 2:', value)); // Subscriber 2: 1
      behaviorSubject.next(2); 
      // Subscriber 1: 2
      // Subscriber 2: 2
      }
    </code>
  </pre>

  <h2> Replay Subject </h2>
  <p> Replay subject is a variant of subject. It emits old value adn emit those value to new subscribe. </p>
<pre>
  <code>
    import { ReplaySubject } from 'rxjs';
    replaySubject = new ReplaySubject(2); // buffer size = 2
    ngOnInit() {
      this.replaySubject.next(1);
      this.replaySubject.next(2);
      this.replaySubject.next(3);
      this.replaySubject.subscribe(value => console.log('Subscriber:', value));
    }
  </code>
</pre>


  <h2> Async Subject </h2>
  <p> Emits last value after completion </p>
  
  <pre>
    <code>
      asyncSubject = new AsyncSubject()

      ngOnInit() {
     
        this.asyncSubject.next(1);
        this.asyncSubject.next(2);
        this.asyncSubject.next(3);

        this.asyncSubject.subscribe(value => console.log('Subscriber 1:', value));

        this.asyncSubject.subscribe(value => console.log('Subscriber 2:', value));

        this.asyncSubject.next(4);
        this.asyncSubject.complete(); // Now it emits 4 to both
      }

    </code>
  </pre>

<p> <strong>BehaviorSubject is a type of RxJS Subject </strong> </p>
<ul>
<li> Always stores the latest value it has emitted. </li>
<li> When a new subscriber subscribes to it, it immediately receives the current value (even if it subscribed after the value was emitted). </li>
<li> BehaviorSubject is commonly used in services to manage state or shared data - Keeping track of the current user.Sharing filter criteria between components. </li>

</ul>

<pre>
<strong>
import { BehaviorSubject } from 'rxjs';

export class DataService {
  private countSubject = new BehaviorSubject<number>(0); // initial value is 0
  count$ = this.countSubject.asObservable(); // expose as observable to subscribers

  updateCount(newCount: number) {
    this.countSubject.next(newCount); // emit new value
  }
}

</strong>
</pre>


  <h2> RxJS SUBJECT //Create a Shared Service </h2>
  <p>  Subject in RxJS is a special type of Observable that allows values to be multicasted to multiple subscribers. </p>
<p> <strong>  Create a Shared Service </strong></p>
<pre>
  <code>
    private dataSubject = new Subject<string>(); // Create Subject
      data$ = this.dataSubject.asObservable(); // Expose as Observable
      sendData(message: string) {
        this.dataSubject.next(message); // Send data
      }
  
     <strong> Send Data from Component 1 (Sender)  </strong> 
      
      button (click)="sendMessage()">Send Message button
  
      constructor(private dataService: DataService) {}
  
      sendMessage() {
      this.dataService.sendData("Hello from Sender!");
      }
  
      <strong> Receive Data in Component 2 (Receiver) </strong> 
  
      <p>Received: {{ receivedMessage }}</p>
  
    receivedMessage: string = "";
  
    constructor(private dataService: DataService) {}
  
    ngOnInit() {
      this.dataService.data$.subscribe(message => {
        this.receivedMessage = message; // Receive data
      });
    }
  
  </code>
</pre>
</div>



<div class="box shadow p-2 mb-3" id="ngrx">
  <h2> NgRx (Redux for Angular) </h2>
  <p><strong>  NgRx is a state management library for Angular applications that implements the Redux pattern using RxJS.
    Uses Actions, Reducers, Store, Effects, and Selectors. </strong></p>
    <strong> TS Actions examples -  </strong>
    <pre>
      <code>
        export const addItem = createAction('[Cart] Add Item', props<{ item: string }>());
        export const removeItem = createAction('[Cart] Remove Item', props<{ item: string }>());
      </code>
    </pre>
    <h2> STATE OF STRUCTURE </h2>
    <pre>
      <code>
          export const initialState = { count: 0 };
          export const counterReducer = createReducer(
          initialState,
          on(increment, (state) => ({ count: state.count + 1 })),
          on(decrement, (state) => ({ count: state.count - 1 }))
        );
      </code>
    </pre>
    <h2> NGXS (Simpler alternative to NgRx) </h2>
    <pre>
      <code>
        @State<number>({ name: 'counter', defaults: 0 })
          export class CounterState {
            @Action(Increment)
            increment(ctx: StateContext<number>) {
              const state = ctx.getState();
              ctx.setState(state + 1);
            }
          }
      </code>
    </pre>
    <h2> SignalStore </h2>
    <p> Introduced in Angular 17 as a lightweight, reactive state management solution. Uses signals instead of Observables. </p>
    <pre>
      <code>
        count = signal(0);
        increment() {
          this.count.set(this.count() + 1);
        }
      </code>
    </pre>
    <h2 class="mt-2"> ngRx Store? </h2>
    <p> ngRx Store is a state management library for Angular applications. It is based on Redux and helps manage application state in a predictable way using actions, reducers, and selectors. </p>
    <p><strong>
      ngRx Store helps manage global state in Angular apps.
      It follows Redux principles with actions, reducers, and selectors.
      Effects handle async operations like API calls.
      Improves scalability, performance, and debugging.
    </strong></p>
    <ol>
      <li> <strong> Actions –  </strong>Define what happens in the app (e.g., "Add Product", "Delete User"). </li>
      <li> <strong> Reducers – </strong> Handle state changes based on actions. </li>
      <li> <strong> State – </strong> The single source of truth for the app. </li>
      <li> <strong> Selectors – </strong> Retrieve specific data from the store. </li>
      <li> <strong> Effects – </strong> Handle asynchronous operations like API calls. </li>
    </ol>
    <pre>
      <code>
        <strong>
          Installation <br>
          ng add @ngrx/store <br>
          ng add @ngrx/effects <br>
        </strong>

 <strong> * Actions </strong>       
import { createAction } from '@ngrx/store';
export const increment = createAction('[Counter] Increment');
export const decrement = createAction('[Counter] Decrement');
export const reset = createAction('[Counter] Reset');

<strong> * Create Reducer </strong>
import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';
export const initialState = 0;
export const counterReducer = createReducer(
  initialState,
  on(increment, (state) => state + 1),
  on(decrement, (state) => state - 1),
  on(reset, () => 0)
);

<strong> * Register Store </strong>

  import { StoreModule } from '@ngrx/store';
  import { counterReducer } from './counter.reducer';
  imports: [
  StoreModule.forRoot({ count: counterReducer }) // Register reducer
  ],

  <strong> * Store in Components </strong>
import { Component } from '@angular/core';
import { Store } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

@Component({
  selector: 'app-counter',
  template: `
    <p><strong> Counter: {{ count$ | async }} </strong> </p>
    button (click)="increment()">Increment</button>
    button (click)="decrement()">Decrement</button>
    button (click)="reset()">Reset</button>
  `
})
export class CounterComponent {
  count$ = this.store.select('count'); // Select state
  constructor(private store: Store<{ count: number }>) {}
  increment() { this.store.dispatch(increment()); }
  decrement() { this.store.dispatch(decrement()); }
  reset() { this.store.dispatch(reset()); }
}

      </code>
    </pre>
	
<h2>Transition Between Two States in Angular</h2>
<pre>
<code>
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

@NgModule({
  imports: [
    BrowserAnimationsModule
  ]
})
export class AppModule {}
</code>
</pre>
<h2> Create Animation in the Component </h2>

<pre>
<code>
import { Component } from '@angular/core';
import { trigger, state, style, animate, transition } from '@angular/animations';

@Component({
  selector: 'app-demo',
  template: `
    div [@openClose]="isOpen ? 'open' : 'closed'" class="box">
      Toggle Me!
    div>
    button (click)="toggle()">Toggle button>
  `,
  animations: [
    trigger('openClose', [
      state('open', style({
        height: '200px',
        backgroundColor: 'lightgreen'
      })),
      state('closed', style({
        height: '100px',
        backgroundColor: 'lightcoral'
      })),
      transition('open <=> closed', [
        animate('0.5s ease-in-out')
      ])
    ])
  ],
  styles: [`.box { width: 200px; margin: 20px auto; text-align: center; }`]
})
export class DemoComponent {
  isOpen = true;

  toggle() {
    this.isOpen = !this.isOpen;
  }
}

</code>
</pre>


</div>


<div class="box shadow p-2 mb-3" id="spa">
  <h2> SPA </h2>
  <p> Single Page Application (SPA) is a web application that dynamically updates content without reloading the entire page. 
    Faster Page Loads ,  Smooth User Experience, Efficient Data Fetching 
    Examples - GMAIL, FACEBOOK, NETFLIX, TWITTER </p>
</div>

<div class="box shadow p-2 mb-3" id="shared">
  <h2> CHALLENGING WORK / SHARED SERVICES </h2>
  <p> I was working on an Angular project where we used a reactive form with a select box for gender (Male and Female) multiple times across different components. Later, we realized that instead of repeating the same logic, we could create a reusable service for gender options, making the implementation more efficient and maintainable. </p>
  <h2> Shared Servcies </h2>
<pre>
  <code>
    genders = [
    {"id": "male", "name": "Male"},
    {"id": "female", "name": "Female"},
    {"id": "other", "name": "Other"}
  ]
  select>
    option *ngFor="let gender of genders" value="{{gender.id}}"> {{gender.name}} </option>
  select>
  </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="newfeatures">
<p><strong> Standalone components in Angular are components that can operate independently without requiring a module. <br> This feature, introduced in Angular 14 and becoming the default in Angular 17. <br>
This feature simplifies component development and reuse, making it easier to build and maintain large-scale applications. </strong></p>

  <h2> NEW FEATURES IN ANGULAR  </h2>
  <p> <strong>  => New Features and Updates in Angular 15 </strong></p>
  <ol>
    <li> Standalone API – No Need for NgModules </li>
    <li> Directive Composition API – Reuse Logic Easily
      * Allows directives to be combined into a single component easily. </li>
    <li> Improved Performance with Better Tree Shaking </li>
    <li> Enhanced Router Features
      * Lazy loading components directly (without NgModule).
      <pre>
        <code>
          const routes: Routes = [
          { path: 'dashboard', loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent) }];
        </code>
      </pre>
      </li>
      <li> Stable Image Directive (NgOptimizedImage) - NgOptimizedImage improves image performance. </li>
      <li> Better Material UI Components </li>
  </ol>

  <p> <strong>  => Angular 17, released in November 2023, brought a major set of improvements to performance </strong></p>
  <ol>
    <li> New Declarative Control Flow Syntax - @-if, @-for, @-switch  </li>
    <li> Deferrable Views with @-defer </li>
    <li> Built-in Control Flow Enabled by Default </li>
    <li> Standalone component the Default, removing the need for NgModules </li>
    <li> Performance Improvements </li>
  </ol>

  <p> <strong>  => New Features and Updates in Angular 19 <br>  ​Angular 19, released in November 2024 </strong></p>
  <ol>
    <li> Standalone Components by Default </li>
    <li> Incremental Hydration (Developer Preview) <br> 
      * This feature enhances server-side rendering by allowing developers to incrementally hydrate parts of their application. Using the @ defer syntax </li>
      <li>  Route-Level Render Mode (Developer Preview) <br> 
        * Angular 19 introduces the ability to control the rendering strategy of individual routes </li>
      <li> Enhanced Reactivity with linkedSignal and resource() </li>
      <li> Angular Material: New Time Picker Component </li>
      <li> Two-Dimensional Drag & Drop in CDK </li>
  </ol>
</div>

<div class="box shadow p-2 mb-3" id="state">
  <h2> State Management in Angular </h2>
  <p> State management in Angular is the process of handling application data efficiently across components, services, and routes. Local State, Component State, Service State (App-Level State) </p>

<h2> How to handle state management </h2>
<p> <strong> 1. @Input() / @Output() — Parent-child communication </strong>,  </p>
<p> <strong> 2. Service with BehaviorSubject </strong> <br> Multiple components need to read and update shared data <br>
You want a simple reactive way to subscribe to changes </p>
<p> Intermediate: Services + Local Storage </p>
<p> Advanced: NgRx (Redux for Angular) </p>

NgRx Key Concepts:
<p> Store = global state container </p>
<p> Actions = events that describe state changes </p>
<p> Reducers = functions that update state based on actions </p>
<p> Effects = handle async operations (e.g., API calls) </p>
  </div>


  <div class="box shadow p-2 mb-3" id="signals">
    <h2> SIGNALS </h2>
    <p> Signals in Angular provide a reactive way to manage and track state changes in a component. They are similar to RxJS observables. </p>
    <pre>
      <code>
        <h2>Counter: {{ count() }}</h2>

button (click)="increment()">Increment</button>
button (click)="decrement()">Decrement</button>

TS - 
count: Signal<number> = signal(0);
increment() { this.count.set(this.count() + 1); }
decrement() { this.count.set(this.count() - 1); }
      </code>
    </pre>
    </div>

    <div class="box shadow p-2 mb-3" id="lazy">
      <h2> Lazy Loading </h2>
     <p> Lazy loading in Angular is a design pattern that improves the performance of an application by loading feature modules only when they are needed. Instead of loading all modules during the initial load of the application, Angular delays the loading of certain modules until the user navigates to a route associated with that module. This reduces the initial bundle size, resulting in faster application load times and a more responsive user experience. </p>
     <p>  To implement lazy loading, you define your feature modules with their own routing configuration and set them up in the main routing file using the loadChildren property. This property tells Angular to load the module dynamically. For example, in your app-routing.module.ts, you might add a route like this: </p>
     <p> For example, suppose you have an Angular application with multiple feature modules, like a dashboard, user profile, settings, and reports. Instead of loading all these modules when the application starts, you can "configure lazy loading" to load these modules only when the user navigates to them. </p>
     <pre>
      <code>
        {
          path: 'admin',
          loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
        }
      </code>
     </pre>
    
      </div>

      <div class="box shadow p-2 mb-3" id="change">
        <h2> CHANGE DETECTION  </h2>
        <p>  Change Detection in Angular is the process of updating the DOM when the application state changes. Angular automatically detects changes and updates the UI accordingly. </p>
        <ol>
          <li> Default Change Detection </li>
          <li> OnPush Change Detection </li>
        </ol>
        <p> <strong> Default Change Detection Examples :-  </strong></p>
        <pre>
          <code> 
            count = 0;
            increment() {
              this.count++;
            }
          </code>
          Count: {{ count }}
          button (click)="increment()">Increment</button>
        </pre>
       
        <h2>  OnPush Change Detection Examples </h2>
        <pre>
          <code>
            import ChangeDetectionStrategy, Input 
            {{ data }}
            @component({ changeDetection: ChangeDetectionStrategy.OnPush})
            @Input() data: string;
          </code>
        </pre>

        <h2> Onpush </h2>
        <pre>
          <code>
            app-onpush [data]="message"></app-onpush>
            button (click)="updateMessage()">Update Message</button>
            Ts 
            message = 'Hello';
            updateMessage() {
              this.message = 'Hello, Angular!';
            }
        </code>
      </pre>
        </div>

        <div class="box shadow p-2 mb-3" id="microfronted">
          <h2> Micro Frontend </h2>
          <p> Micro Frontend (MFE) is an architectural approach where a frontend application is divided into smaller, independently deployable micro applications. </p>
          <p> <strong> Why Use Micro Frontend in Angular? </strong></p>
          <p> Scalability: Large applications can be split into smaller manageable parts. </p>
          <p> Independent Deployment: Each micro frontend can be developed, tested, and deployed independently. </p>
          <p> Technology Agnostic: Different teams can use different frameworks (Angular, React, Vue) if needed. </p>
          <p> Better Maintainability: Smaller codebases are easier to maintain. </p>
          <h2> Steps to Implement Micro Frontend in Angular </h2>
          <p> Let's assume we have: </p>
          Shell App (Host Application) → Main container that loads micro frontends. <br>
          Remote App 1 (Micro App 1) <br>
          Remote App 2 (Micro App 2) <br>
          </div>

          <div class="box shadow p-2 mb-3" id="ssr">
            <h2> SSR </h2>
            <p> SSR - server-side rendering (SSR) is a process that involves rendering pages on the server, resulting in initial HTML content which contains initial page state.  </p>
          </div>


<div class="box shadow p-2 mb-3" id="aot">
            <h2> How to use multiple API in angular ? + AOT JIT </h2>
            <p> Angular, We can use multiple APIs in different ways.
              Using forkJoin (Parallel API Calls - Best for Independent APIs) </p>
              <pre>
                <code>
                  forkJoin([
                  this.http.get('https://api.example.com/users'),
                  this.http.get('https://api.example.com/posts')
                ]).subscribe(([users, posts]) => {
                  console.log('Users:', users);
                  console.log('Posts:', posts);
                });
                </code>
              </pre>
<p> AOT - Ahead of time compilation at build time application runs.  <br>
  JIT - Just in time </p>

<h2>  Different AOT AND JIT </h2>
<ol>
  <li> JIT (Just-in-Time) Compilation: </li>
  <li> Happens at runtime in the browser. </li>
  <li> Compiles the Angular application in the browser as it loads. </li>
  <li> Faster development builds but slower performance in production. </li>
</ol>

<ol>
  <li> AOT (Ahead-of-Time) Compilation: </li>
  <li> Happens during the build phase before the application is run. </li>
  <li> Compiles the application into efficient JavaScript code ahead of time, which leads to faster loading and better performance. </li>
  <li> Recommended for production builds. </li>
</ol>
</div>


<div class="box shadow p-2 mb-3" id="viewchild">
<h2> @VIEW Child </h2>
<p> @ViewChild is a decorator in Angular that allows us to access and interact with child components, directives, </p>
<h2> @view child examples </h2>
<pre>
  <code>
    @ViewChild('heading') headingElement!: ElementRef;
    ngAfterViewInit() {
      console.log('Text content:', this.headingElement.nativeElement.textContent);
    }
    changeText() {
      this.headingElement.nativeElement.textContent = 'Text Changed!';
      this.headingElement.nativeElement.style.color = 'red';
    }

    ------- HTML ------ 

    h2 #heading>Welcome to Angular!</h2>
    button (click)="changeText()">Change Text</button>

  </code>
</pre>

<H2>@ViewChildren (Multiple Element or Component References) </H2>
<p><strong> child.component.ts  </strong></p>
<pre>
  <code>
    greet() {
      return 'Hello from Child Component!';
    }
  </code>
</pre>

<p><strong> parent.component  </strong></p>
app-child></app-child> <br>
app-child></app-child> <br>
app-child></app-child> <br>
button (click)="callChildrenMethods()">Call All Child Methods</button>

<p><strong> parent.component ts  </strong></p>
<pre>
  <code>
    @ViewChildren(ChildComponent) children!: QueryList<ChildComponent>;
      ngAfterViewInit() {
        this.children.forEach((child, index) => {
          console.log(`Child ${index + 1}: ` + child.greet());
        });
      }
      callChildrenMethods() {
        this.children.forEach((child) => alert(child.greet()));
      }
  </code>
</pre>

</div>


<div class="box shadow p-2 mb-3" id="databinding">
  <h2> DATA BINDING </h2>

<h2> Event Binding </h2>
<p><strong> Event binding is the process of targeting an event in a HTML element. </strong></p>
<pre><code>
  TS
  clickEvent(){
    console.log("event binding")
  }
  clickEvent2(val:string){
    console.log(val)
  }
-------
  HTML 
  button type="button" (click)="clickEvent()"> Event Binding </button>
  input type="text" #box (keyup)="clickEvent2(box.value)" placeholder="Event Keyup">
</code>
</pre>
<h2> Property Binding </h2>
<pre>
  <code>
    TS 
    isDisabled = true
    defaultName = "santosh"
    imgUrl = "assets/imags/icon.png"

    HTML
    input type="text" [disabled]="isDisabled">
    input type="text" [value]="defaultName">
    img [src]="imgUrl" alt="">
  </code>
</pre>
<h2> Attribute Binding </h2>
<pre>
  <code>
    TS 
    columnSpan = 3
    placeholder1 = "First Name"

    HTML
    td [attr.colspan]="columnSpan">Content</td>
    input type="text" [attr.placeholder]="placeholder1" name="username" required>
  </code>
</pre>
<h2> Class Binding </h2>
<pre>
  <code>
    TS
    isActive = true
    isSuccess = true;
    isError = false;

    HTML
    div [class.active]="isActive"> Hello /div>
    div [ngClass]="['class-one', true ? 'class-two' : false]"> Box /div>
    div [ngClass]="{'success': isSuccess, 'error': isError}"> Status /div>
  </code>
</pre>

<h2> Style Binding </h2>
<pre>
  <code>
    TS
    bgColor = 'yellow'

    HTML 
    div [style.backgroundColor]="bgColor"> Santosh div>
  </code>
</pre>

  <P> Data binding is one of the most elements for creating communication between the DOM and the component. </P>
  <h2> Two-way Binding Example </h2>
  <p>  when the data in the model changes, the changes are reflected in the view and when the data in the view changes it is reflected in the model - [(ngModel)]</p>
  <pre>
    <code>
      userInput: string = '';  // Model property
      input type="text" [(ngModel)]="userInput" placeholder="Type something..." />
      p>You typed: {{ userInput }}</p>
    </code>
  </pre>
  </div>
  
  <div class="box shadow p-2 mb-3" id="datatransfer">
    <h2> Using a Shared Service with a Subject/BehaviorSubject  </h2>
	<pre>
	<code>
	Create a shared service:
	// data.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private dataSource = new BehaviorSubject<any>(null);
  currentData = this.dataSource.asObservable();

  changeData(data: any) {
    this.dataSource.next(data);
  }
}
	</code>
	</pre>
	<h2>  In Component A (sending component): </h2>
	<pre>
	<code>
	
	 
	 constructor(private dataService: DataService) {}

		sendData() {
		  this.dataService.changeData('Hello from Component A');
		}

	</code>
	</pre>
	<h2> In Component B (receiving component): </h2>
	<pre>
	<code>
	dataFromA: any;

constructor(private dataService: DataService) {}

ngOnInit() {
  this.dataService.currentData.subscribe(data => {
    this.dataFromA = data;
  });
}

	</code>
	</pre>

<h2> Using Angular Router (if navigating with data) </h2>

<pre>
<code>
-sender component
this.router.navigate(['/target'], { state: { message: 'Hello' } });
- Receive componet
constructor(private router: Router) {
  const nav = this.router.getCurrentNavigation();
  const state = nav?.extras.state as { message: string };
  console.log(state.message);
}

</code>
</pre>


	</div>
  

  <div class="box shadow p-2 mb-3" id="decorator">
    <h2> DECORATOR </h2>
    <p> <strong> Decorator is a function that add metadata to a class. @component, @directives, @ngModule, @input, @output, @hostListener </strong>  </p>

    <h2> Decorators Types </h2>
<div class="mb-3"> 
<strong> 1. Class Decorators <br> </strong>
These are used to define classes as Angular like components, modules, directives, etc.<br>
<strong> @Component </strong> - Declares a class as a component and provides metadata like selector, template, styles, etc. <br> 
<strong> @Directive </strong> Declares a class as a directive. Used to extend the behavior of elements. <br>
<strong> @Injectable </strong> Marks a class as available to be injected as a dependency. <br>
<strong> @NgModule </strong> Declares a class as an Angular module and provides metadata about the module.
</div>

<div class="mb-4"> 
<strong> 2. Property Decorators <br> </strong>
Used to decorate properties inside classes. <br>
<strong> @Input </strong> - Declares an input property to receive data from a parent component. <br> - @Input() title: string;
<br> 
@Output -  Declares an output property that emits events to the parent component. <br>
@Output() clicked = new EventEmitter<void>(); <br>
</void>
<strong> @ViewChild / @ViewChildren </strong> , Accesses child component(s) or element(s) in the component's view. <br>
<strong> @ContentChild / @ContentChildren </strong> Accesses projected content inside <ng-content>.
</div>

<div class="mb-4"> 
<strong> 3. Method Parameter Decorators </strong> <br>
@Inject - Specifies a custom provider token when injecting a dependency. <br>
@Optional - Marks a dependency as optional. If it’s not found, Angular will pass null.
</div>


    <pre>
      <code>
        import { Component } from '@angular/core';
        @Component({
          META DATA
          selector: 'app-ngfor',
          standalone: true,
          imports: [CommonModule, HeaderComponent],
          templateUrl: './ngfor.component.html',
          styleUrl: './ngfor.component.css'
        })
        export class NgforComponent { }
      </code>
    </pre>
  </div>

  <div class="box shadow p-2 mb-3" id="directive">
    <h2> Directive </h2>
    <p>  <strong> Directives are classes that enhance the feature of a HTML element. </strong> </p>
    <ol>
      <li> Component Directives (Most Common) <br> Technically, components are a type of directive with a template. </li>
      <li> <strong> Structural Directives (Modify the DOM Structure) </strong> <br> 
        <p> Structural directives change the DOM by adding, removing, or manipulating elements. </p>
        *ngIf → Condition-based rendering. <br> 
        *ngFor → Loops over collections. <br>
        *ngSwitch → Switch-case logic. <br>
      </li>
      <li> <strong> Attribute Directives </strong> (Modify the appearance or behavior of elements) 
      
     <p> Attribute directives change the styling or behavior of elements without altering the structure. </p>
     <pre>
      <code>
        constructor(private el: ElementRef) {
          el.nativeElement.style.backgroundColor = 'yellow';
        }
        p appHighlight>This text will have a yellow background.</p>
      </code>
     </pre>
      </li>
    </ol>

    <ol>
      <li> ElementRef → Direct access to the DOM element. </li>
      <li> Renderer2 → Safe way to modify the DOM. </li>
      <li> @HostListener → Handles events inside directives. </li>
      <li> @HostBinding → Binds properties to the host element. </li>
      <li> @Input() → Passes values into the directive. </li>
    </ol>

    <h2> Custom Directive </h2>

    <pre>
      <code>
        custom Directive Command - ng g d directive-name (cdirective)
        @Input() color!:string;
    
        constructor(private el: ElementRef) {} //Refrence DOM elements, //void is a type that represents the absence of a value
    
        ngOnInit(): void { 
        // this.el.nativeElement.style.backgroundColor = 'red';
            this.el.nativeElement.style.backgroundColor = this.color;
        }
        &lt;p cdirective color="red"&gt; Form &lt;/p&gt;
    -------------------------
    
    import { Directive, ElementRef, HostListener, Input, OnInit } from '@angular/core';

    @Directive({
      selector: '[toggleColor]'
    })
    export class ToggleColorDirective implements OnInit {
      @Input() defaultColor: string = 'yellow'; // Default background color
      @Input() highlightColor: string = 'red';  // Color to toggle on click
    
      private isHighlighted = false;
    
      constructor(private el: ElementRef) {}
    
      ngOnInit(): void {
        this.el.nativeElement.style.backgroundColor = this.defaultColor;
      }
    
      @HostListener('click') onClick() {
        this.isHighlighted = !this.isHighlighted;
        this.el.nativeElement.style.backgroundColor = this.isHighlighted
          ? this.highlightColor
          : this.defaultColor;
      }
    }
    
     HTML 

    button 
  toggleColor 
  [defaultColor]="'yellow'" 
  [highlightColor]="'red'" 
  class="px-4 py-2 rounded-md border">
  Click Me
/button>
     
     
        ---------------- 
      @Directive({
        selector: '[websanto]', // Custom attribute selector
      })
    
      @Input() color: string = ''; // Input property for color
    
      constructor(private el: ElementRef) {}
    
      ngOnInit() {
        this.el.nativeElement.style.backgroundColor = this.color; // Apply color
      }
    in HTML 
    &lt;button websanto color="red">Submit&lt;/buttonp&gt;
      </code>
    </pre>

  </div>

  <div class="box shadow p-2 mb-3" id="input">
    <h2> @Input, @output </h2>
    <p> @Input and @Output are used for communication between parent and child components </p>
    <p> <strong> example child ts </strong></p>
    <pre>
      <code class="whitespace-pre! language-html">
        @Input() message!: string; 
        template: `&lt;p&gt; Message from Parent: {{ message }} &lt;/p&gt; `,  
      </code>
    </pre>
    <p> <strong> parent ts </strong></p>
    <pre><code> parentMessage = 'Hello, Child!'; </code></pre>

  <p> <strong>   @output examples - child ts - </strong></p> 
     @Output() messageEvent = new EventEmitter<string>();
    sendMessage() {
          this.messageEvent.emit('Hello, Parent!'); // Sending data to parent
    }
<p> <strong> Parent ts -  </strong></p>
template : `
    app-child (messageEvent)="receiveMessage($event)"> - app-child
    <p>Received Message: {{ receivedMessage }}</p>
    <pre>
      <code>
        receivedMessage = ''; <br>
    receiveMessage(message: string) {
      this.receivedMessage = message; // Updating receivedMessage from child
    }  
      </code>
    </pre>
	
	<h2> @input Examples </h2>
	<pre>
	<code>
	child.component.ts
	import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `p>Hello {{ name }}!p>`
})
export class ChildComponent {
  @Input() name!: string;
}

-- parent.component.html
app-child [name]="'Angular Learner'"> app-child>

	</code>
	</pre>
	
	
	<h2> @output Examples </h2>
	<p> It allows a child component to send data to the parent component using an event. </p>
	<pre>
	<code>
	child.component.ts
	import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `button (click)="sendData()">Send button>`
})
export class ChildComponent {
  @Output() messageEvent = new EventEmitter<string>();

  sendData() {
    this.messageEvent.emit('Hello from Child!');
  }
}

---------

Prent component html 

app-child (messageEvent)="receiveMessage($event)"> app-child>
p>{{ message }} /p>

---------

parent.component.ts

export class ParentComponent {
  message = '';

  receiveMessage(data: string) {
    this.message = data;
  }
}


	</code>
	</pre>
	
  </div>


  <div class="box shadow p-2 mb-3" id="ngfor">
    <h2> Ngfor, forloop </h2>
    <pre>
      <code>
        employees = [
    {
    id: 1,
    name: "Santosh Kumar",
    age: 30,
    department: "Human Resources",
    salary: 5000000
    },
    &lt;tr *ngFor="let employee of employees"&gt;  &lt;tr&gt;
    ----------------------
    isVisiable:boolean = false 
    &lt;h2 *ngIf="isVisiable"&gt; Welcome to NgIf &lt; h2 &gt;
    ----------------------
      </code>
    </pre>

    <h2> Ngfor and NgIf </h2>
    <pre>
      <code>
        TS 
        public staffs = [
        { staff_name: "Rakesh", age:35, salary:50000, },
        { staff_name: "Mohan", age:35, salary:100000, },
        { staff_name: "Sohan", age:35, salary:30000, },
        { staff_name: "Jhannu", age:35, salary:100000, },
        { staff_name: "Pradeep", age:35, salary:50000, },
        { staff_name: "Kailash", age:35, salary:100000, },
        { staff_name: "Jhunjhunwala", age:35, salary:100000, }
      ]

      HTML 

      li *ngFor="let staff of staffs"> 
        ng-container *ngIf="staff.salary < 50000; else highsalary">
            {{staff.staff_name}} {{staff.salary}}
        /ng-container>
        ng-template #highsalary>
          div style="background-color: #ececec;">   {{staff.staff_name}} {{staff.salary}} div>
        /ng-template>
    /li>

    NODATA

    div *ngIf="employees && employees.length > 0; else nodata"> 
      div *ngFor="let emp of employees">
          ng-container *ngIf="emp.salary > 400000; else highsalary">
             span style="color: red;">  {{emp.name}} /span>
          /ng-container>
          ng-template #highsalary>
              {{emp.name}}
          /ng-template>
      /div>
  /div>
  ng-template #nodata> p> No Data /p>/ng-template>

    -------------- 

    <h2> Toggle </h2>
    TS
    isVisiable = true
    toggleButton(){
      this.isVisiable = !this.isVisiable
        } 

    HTML 
    div *ngIf="isVisiable" class="mt-10"> This message for isVisiable /div>
    button type="button" (click)="toggleButton()"> Show and Hide /button>

      </code>
    </pre>
	
<h2> @HostListener </h2>	
@HostListener is a decorator in Angular that lets you listen to DOM events on the host element of a directive or component.
You use it when you want to react to events like clicks, mouse movements, key presses, etc., directly on the element where your directive or component is applied.



  </div>


  <div class="box shadow p-2 mb-3" id="scrolltop">
    <h2> SCROLLTOP</h2>
    <pre>
      <code>
        private showClass = 'show-scroll-button';
  constructor(private el: ElementRef, private renderer: Renderer2) {}
  ngOnInit() {
    this.renderer.addClass(this.el.nativeElement, 'scroll-to-top');
  }
  @HostListener('window:scroll', [])
  onWindowScroll(){
    if(window.scrollY > 200){
      this.renderer.addClass(this.el.nativeElement, this.showClass);
    } else {
      this.renderer.removeClass(this.el.nativeElement, this.showClass);
    }
  }
  @HostListener('click') onclick(){
    window.scrollTo({ top:0, behavior: 'smooth'});
  }
      </code>
    </pre>
  </div>

  <div class="box shadow p-2 mb-3" id="add-remove">
    <h2> ADD AND REMOVE CLASS  </h2>
<pre>
  <code>
    @HostListener('click') onClick() {
      this.isHighlighted = !this.isHighlighted;
  
      if (this.isHighlighted) {
        // Add class to clicked element
        this.renderer.addClass(this.el.nativeElement, 'active');
  
        // Remove class from other elements
        this.removeClassFromOtherElements();
      } else {
        // Remove class from this element
        this.renderer.removeClass(this.el.nativeElement, 'active');
      }
    }
  </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="pipe">
  <h2> PIPE, CUSTOM PIPE, PURE, IMPURE </h2>

  <p> <strong> Pipes are a special operator in Angular template expressions that allows you to transform data declaratively in your template. </strong></p>
  <h2> What is the difference between a Pipe and a Directive? </h2>
  <p> <strong> Pipes </strong> transform data in templates (date, uppercase). <br>
   <strong> Directives </strong>  modify the behavior of DOM elements (ngIf, ngFor). 
  </p>
  <h2> What are pure Pipes? </h2>
  <p> Pure pipes are executed only when a "pure change" is detected in the input value. <br> By default, all pipelines are pure </p>
  
  <h2> What are Impure Pipes? </h2>
  <p> Angular calls an impure pipe for each change detection cycle, independent of the change in the input fields. For each of these pipes, several pipe instances are produced.  </p>

  <h2> Disadvantages of Impure Pipes </h2>
 <p class="p-0, m-0"> 1. Performance Issues -- Impure pipes run every time Angular checks for changes, which could be many times per second. </p>
  <p class="p-0, m-0"> 2. Unnecessary Computations - Even if the input data hasn’t changed, the pipe still executes. </p>
 <p class="p-0, m-0"> 3. Hard to Debug - Since impure pipes run so frequently, it can be difficult to track down performance bottlenecks or unintended behaviors. </p>

<br> 
  <p> <strong> pure - Only when input data changes	, Faster , Static data transformations	 </strong></p>
<p> <strong> impure - On every change detection cycle, Slower  </strong></p>

<h2> What is Pipe transform Interface in Angular? </h2>
<p> An interface used by pipes to accomplish a transformation. Angular calls the transform function with the value of a binding as the first argument and any arguments as the second parameter in list form. This interface is used to implement custom pipes. </p>

  <pre>
    <code>
      Uppercase: {{ 'hello world' | uppercase }}

today: Date = new Date();
&lt;p&gt;Full Date: {{ today | date:'fullDate' }}&lt;/p&gt;

<pre>
  <code>
    import { Pipe, PipeTransform } from '@angular/core';
 @Pipe({
  name: 'tranformpipe'
})
export class TranformpipePipe implements PipeTransform {
  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }
}

  </code>
</pre>

 <strong> custom Pipe, PipeTransform </strong>

  transform(value: string, gender: string): string {
    if(gender.toLowerCase()=="male")
      return "Mr. "+value;
      else
      return "Miss. "+value
    } 
    {{employee.name | mypipe:employee.gender }}

    </code>
  </pre>


  <p> <strong> FILTER IMPURE PIPE EXAMPLES </strong></p>
  <pre>
    <code>
      pure: false
      transform(items: any[], searchText: string): any[] {
        if (!items || !searchText) {
          return items;
        }
        return items.filter(item =>
          item.toLowerCase().includes(searchText.toLowerCase())
        );

        <strong>   use in component </strong>
        searchText: string = '';
        i     tems: string[] = ['Angular', 'React', 'Vue', 'Svelte'];
        <strong> use in template </strong>
        input type="text" [(ngModel)]="searchText" placeholder="Search..." />
        ul>
          li *ngFor="let item of items | filterItems:searchText">
            {{ item }}
          /li>
        /ul>
    </code>
  </pre>

  </div>


  <div class="box shadow p-2 mb-3" id="global-variable">
    <h2> Using a Global Variable for data transfer </h2>
    <pre>
      <code>
        ts - let sharedData: any;
        Sender - sendData() {
          sharedData = "Data from Sender";
        }
        Receive - receivedData = sharedData;
      </code>
    </pre>
    </div>


<div class="box shadow p-2 mb-3" id="spying">
<h2> Spying on a Method in Angular (Jasmine & SpyOn) </h2>
<p>
  <p> <strong> jASMINE -  </strong></p>
  Jasmine is a behavior-driven development (BDD) framework for testing JavaScript applications. <br> 
  It does not depend on any external libraries and is commonly used for unit testing in Angular. <br>
  In Angular unit testing, spying on methods is a common practice to track method calls, prevent actual execution, and return mock values. This is done using Jasmine’s spyOn function.
</p>
  <pre>
    <code>
      export class MyComponent {
        myMethod() {
          console.log('Original method executed');
        }
      
        anotherMethod() {
          this.myMethod(); // Calls myMethod internally
        }
      }  
    
     -- Spy on an Observable	
     spyOn(service, 'methodName').and.returnValue(of(fakeData))
    
     --Spy on a service method
     spyOn(service, 'methodName')

    </code>
  </pre>
</div>


<div class="box shadow p-2 mb-3" id="chart">
  <h2> CHART IMPLEMENTS  </h2>
  <div>
      <p> <strong> Bar chart and Pie chart Installation </strong></p>
      <p> <strong> ng2-charts - v4 support with angular 15 </strong> </p>
      <p> <strong> npm install according to doc </strong></p>
        <p> <strong> Global configuration </strong></p>
          <p> <strong> providers </strong></p>
            <p> <strong> ngcharconfiguration in module </strong></p>
              <p> <strong> code copy markup and ts code </strong> </p>
                <p> <strong> using dependancy --legacy-peer-deps </strong></p>
  </div>
</div>


<div class="box shadow p-2 mb-3" id="routeguards">
  <h2> Route Guards in Angular  </h2>
  <p> Angular Guards are services that control access to routes in an Angular application. They are used to protect routes from unauthorized access or to prevent unwanted navigation. Common types of guards include: </p>
  <ul>
    <li> CanActivate:  if a route can be activated.</li>
    <li> CanDeactivate: Checks if a route can be deactivated.</li>
    <li> CanLoad: Determines if a module can be loaded lazily. </li>
  </ul>
  <pre>
    <code>
      constructor(private router: Router) {}
      canActivate(): boolean {
        const isLoggedIn = !!localStorage.getItem('user');
        if (!isLoggedIn) {
          this.router.navigate(['/login']); // Redirect to login if not authenticated
          return false;
        }
        return true;
      }
    </code>
  </pre>
  <p> <strong> Applying Route Guard to Routes </strong></p>
  <pre>
    <code>
      const routes: Routes = [
    { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] }
  ];
    </code>
  </pre>

  <h2> Dynamic Menu </h2>

  <pre>
    <code>
      TS
      role = 'admin'; // or 'client'

menus_list = [
  {
    title: 'Admin Dashboard',
    icon: 'bx bx-user',
    link: '/admin-dashboard',
    role: 'admin'
  },
  {
    title: 'User details',
    icon: 'bx bx-user',
    link: '/user-details',
    role: 'admin'
  },
  {
    title: 'Services Manage',
    icon: 'bx bx-user',
    link: '/services-manage',
    role: 'admin'
  },
  {
    title: 'Client Dashboard',
    icon: 'bx bx-user',
    link: '/client-dashboard',
    role: 'client'
  },
  {
    title: 'Profile',
    icon: 'bx bx-user',
    link: '/profile',
    role: 'client'
  },
  {
    title: 'Client Leads',
    icon: 'bx bx-user',
    link: '/client-leads',
    role: 'client'
  }
];

// Filtered menu based on role
get filteredMenus() {
  return this.menus_list.filter(item => item.role === this.role);
}


HTML 

ul>
  li *ngFor="let menu of filteredMenus">
    a [routerLink]="menu.link">
      <i [class]="menu.icon"></i> {{ menu.title }}
    /a>
  /li>
/ul>

    </code>
  </pre>


  </div>


  <div class="box shadow p-2 mb-3" id="di">
    <h2> Dependency Injection (DI) in Angular  </h2>
    <p>  DI is a design pattern in Angular used for managing dependencies (services, components, etc.). <br>
      * Instead of creating objects manually, Angular injects them automatically. <br>
      * Uses @Injectable() decorator for services. <br>
      <strong> => Create Serives  </strong>
      <pre><code>
      getData() {
        return ['Angular', 'React', 'Vue'];
      }
      <strong> => Inject the Service into a Component </strong>
      frameworks: string[];
      constructor(private dataService: DataService) {  // 🔹 Inject Service Here
        this.frameworks = this.dataService.getData();
      }
      {{ frameworks }}
    </code></pre>
    </div>

<div class="box shadow p-2 mb-3" id="form">
<h2> FORMS </h2>
<p><strong> Difference between Template-driven and Reactive Forms? </strong></p>
<ul>
  <li><strong> Template-driven </strong></li>
  <li> HTML-centric (form logic in template) </li>
  <li> Structure Based on directives </li>
  <li> Validation Asynchronous </li>
  <li> Simple forms </li>
  <li> Two-way data binding  ([(ngModel)]) </li>
</ul>
<ul>
  <li><strong>  Reactive Forms </strong></li>
  <li> TypeScript-centric (logic in TS file) </li>
  <li>   Structure Based on explicit creation </li>
  <li> Synchronous </li>
  <li>   Complex forms </li>
  <li> One-way, explicit & predictable </li>
</ul>
<h2> 1. Template-driven Form Example </h2>
<pre>
  <code>
    form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)">
      input name="username" ngModel required />
      input type="email" name="email" ngModel />
      button type="submit">Submit /button>
    /form>
    --------- 
    onSubmit(form: NgForm) {
      console.log(form.value);
    }
    
    </form>
  </code>
  <h2> 2. Reactive Form Example </h2>
  <pre>
    <code>

    </code>
  </pre>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="form-crud">
<h2> FORM validation </h2>
<pre>
  <code>
    lead_form!: FormGroup
lead_fields = {
  name     : ['', Validators.required],
  email    : ['', Validators.required],
}
constructor( private _fb    : FormBuilder ){
  this._route.queryParams.subscribe(params => { this.tenant_id = params['id']})
}
ngOnInit(){this.initializeForm()}
initializeForm(){
  this.lead_form = this._fb.group(this.lead_fields)
  this.getLeads()
}
getLeads(){
  let params = [{"key": "tenant_id", "value": this.tenant_id},{"key": "limit", "value": 100}]
  this._http.get('leads/leads/', params).subscribe((response:any) => {
    this.leads = response;
    this.action = "Add"
  },(error: any) => {this.errorMessage(error)})
} 
  </code>
</pre>

<h2> crud </h2>

<p> Full Crud Operation </p>

<pre>
  <code>
    export class CmsComponent {

      @ViewChild('close') closed!: ElementRef
      @ViewChild('close1') close1!: ElementRef
      
      pages: any
      cms_form!: FormGroup
      page: any
      action: string = "Add"
    
        cms_fields = {
        title   : ['', Validators.required],
        slug    : ['', Validators.required] ,
        content : ['', Validators.required]
        }
    
      constructor(
        private _http: HttpSharedService,
        private _fb: FormBuilder,
      ){ this.initializeForm() }
    
      ngOnInit(){this.getPages()}
    
      resetForm(){
        this.action = "Add"
        this.initializeForm()
      }
    
      initializeForm(){this.cms_form = this._fb.group(this.cms_fields)}
    
      getPages(){
        this._http.get('cms').subscribe((response: any) => {
          this.pages = response; 
        }, (error) => {
           console.log(error.messages)
        })
      }
    
      setPage(page: any, action: string){
        this._http.get('cms/'+page.id).subscribe((response:any) => {
          this.page = response;
          this.checkAction(action)
        }, (error) => {
           console.log(error)
        })
      }
    
      addNew(){
        this.resetForm()
      }
    
      checkAction(action: any){
        if(action == 'edit'){
          this.action = 'Edit'
          this.patchPage()
        }
      }
    
      patchPage(){
        this.cms_form.patchValue({
          title    : this.page.title,
          slug     : this.page.slug,
          content  : this.page.content
        })
      }
    
      deactivatePlan(){
        this._http.delete("cms/"+this.page.id).subscribe((response: any) => {
          this.getPages()
          this.resetForm()
          this.close1.nativeElement.click()
          console.log ("Page Deactivated")
        }, (error: any) => {
          console.error('Check--->', error.messages);
        })
      }
    
      setPalyLoad(form: any){
        return {
          title         : form.title,
          slug          : form.slug,
          content       : form.content,
          is_published  : this.page ? this.page.is_active : true,
        }
      }
    
      saveForm(){this.action === "Add" ? this.createPage() : this.updatePage()}
    
      createPage(){
        this._http.post('cms', this.setPalyLoad(this.cms_form.value)).subscribe((response: any) => {
          this.resetForm()
          this.getPages()
          this.closed.nativeElement.click()
          console.log("Page created successfully!")
        }, (error) => {
          console.error("Error:", error);
        })
      }
    
      //forEdit
      updatePage(){
        this._http.put('cms/'+this.page.id, this.setPalyLoad(this.cms_form.value)).subscribe((response: any) => {
          this.resetForm()
          this.getPages()
          this.closed.nativeElement.click()
          console.log("Page updated successfully!")
        }, (error) => {
           console.error("Error", error)
        })
      }
    }
  </code>
</pre>


<p> <strong> Create </strong></p>
<pre><code>
  createLead(){
    this._http.post('leads/leads/', this.setPayload(this.lead_form.value)).subscribe((response: any) => {
      this.afterAction("Lead Saved")
    },(error: any) => {this.errorMessage(error)})
  }
</code>
</pre>

<p> <strong> setpayLoad </strong></p>
<pre>
  <code>
    setPayloadForEdit(form: any){
      return {
        "name"     : form.name,
        "email"    : form.email,
      }
    }
  </code>
</pre>

<p> <strong> Edit </strong></p>

<pre> 
  <code> 
  editLead(){
    let params = [{"key": "tenant_id", "value": this.tenant_id}]
    const payload = this.setPayloadForEdit(this.lead_form.value)
    this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
      this.afterAction("Lead Update")
    },(error: any) => {this.errorMessage(error)}) 
  }
</code>
</pre>

<p> <strong> Updated Crud </strong></p>
<pre>
  <code>
    updateLead(){
      let params = [{"key": "tenant_id", "value": this.tenant_id}]
      const payload = this.setPayloadForEdit(this.lead_form.value)
      this._http.put('leads/leads/'+this.lead_id, payload, params).subscribe((response: any) => {
        this.afterAction("Lead Update")
      },(error: any) => {this.errorMessage(error)}) 
    }
  </code>
</pre>

<p> <strong> Delete Crud </strong></p>
<pre>
  <code>
    deleteLead(){
      let params = [{"key": "tenant_id", "value": this.tenant_id}]
      this._http.delete('leads/leads/'+this.lead_id, params).subscribe((response:any) => {
        this.afterAction("Lead Deleted")
      },(error: any) => {this.errorMessage(error)})
    }
  </code>
</pre>
</div>


<div class="box shadow p-2 mb-3" id="graphql">
  <h2> GRAPHQL </h2>
<p> GraphQL is a powerful alternative to REST for querying and mutating data in Angular applications. It allows clients to request exactly the data they need, reducing over-fetching and improving performance.
 </p>
 <p>  npm install @apollo/client graphql </p>
<p> Benefits of Using GraphQL in Angular </p>
<ul>
  <li> Fetch only the data you need </li>
  <li> Reduce API calls with a single query </li>
  <li> Strongly typed schema </li>
  <li> Real-time updates with subscriptions </li>
</ul>
  </div>


  <div class="box shadow p-2 mb-3" id="vresion-upgrade">
    <h2> HOW TO UPGRADE OLD VERSION TO NEW VERSION </h2>
    <div>
      => Always backup your project before upgrading. <br>
      => Use Git commits to track changes at each step.<br>
      1. Check the Current Angular Version<br>
      ng version<br>
      2. Update Angular CLI Globally<br>
      npm install -g @angular/cli<br>
      3. ng update @angular/core@16 @angular/cli@16<br>
      4. Update Other Dependencies<br>
      ng update<br>
      -------------
      You should upgrade step by step from Angular 15 → 16 → 17 → 18 → 19 rather than jumping directly from Angular 15 to Angular 19.<br>
      If You Try Directly Updating from 15 to 19?<br>
      1. dependency conflicts and errors.<br>
      2. Some configurations (like angular.json) might break due to missing intermediate updates.<br>
      3. Third-party libraries might not support Angular 19<br>
    </div>
    </div>


<div class="box shadow p-2 mb-3" id="storage">
<h2> Local Storage </h2>
<p> <strong> Local Storage - </strong> Web storage API stores data in our browser, and no any specific time for expiration. </p>
<p> <strong> Session Storage - </strong> In Session Storage also web storage API  stores data in our current browser and tab. When you close the tab so after that all data is cleared. </p>
<p> <strong> Cookies - </strong> Small pieces of data stored in the browser and sent to the server with every HTTP Request. </p>
 <ul>
  <li> Data remains even after closing/reopening the browser </li>
  <li> Available across all tabs/windows of the same origin </li>
  <li> Storage limit Around 5MB per origin	 </li>
  <li> Store user preferences, theme settings, authentication tokens, etc.	 </li>
 </ul>
 <h2> SessionStorage  </h2>
 <ul>
  <li> Data is cleared when the browser/tab is closed </li>
  <li> Available only within the same tab </li>
  <li> Store temporary data like form input, session-based UI state, etc.	 </li>
 </ul>

 <pre>
  <code>
    // Store data
    localStorage.setItem('username', 'Santosh');
    // Retrieve data
    const username = localStorage.getItem('username');
    console.log(username); // Output: Santosh
    // Remove data
    localStorage.removeItem('username');
    // Clear all data
    localStorage.clear();
  </code>
 </pre>

 <h2> USING SESSION STORAGE </h2>
 <pre><code>
  sessionStorage.setItem('sessionUser', 'JohnDoe');
 </code></pre>

Using the Service in a Component
<pre>
  <code> 
  saveData() {
    this.storageService.setLocalStorage('user', { name: 'Santosh', role: 'Admin' });
    this.storageService.setSessionStorage('sessionUser', { name: 'Guest' });
  }
  loadData() {
    const user = this.storageService.getLocalStorage('user');
    const sessionUser = this.storageService.getSessionStorage('sessionUser');
    console.log('Local User:', user);
    console.log('Session User:', sessionUser);
  }
  clearData() {
    this.storageService.clearLocalStorage();
    this.storageService.clearSessionStorage();
  }
</code>
</pre>
button (click)="saveData()">Save Data</button>
</div>


<div class="box shadow p-2 mb-3" id="authentication">
  <p> <strong> Authentication means "Who are you?" </strong></p>
  <p> When you try to log in to an application, you need to prove your identity. For example, if your name is Ram, you must provide some credentials (like a username and password) to prove that you are indeed Ram. If the credentials match, the system authenticates you and grants access. This process of verifying your identity is called Authentication.</p>
  
  <p> <strong> Authorization means "What are you allowed to do?"</strong> </p>
  <p> Once you're logged into the application, you have access to a database — but can you delete tables, update records, insert new data, or are you limited to just read only ? This control over what you can or cannot do within the system is called Authorization. </p>

  <p> <strong> LOGIN PROCESS </strong></p>
  <p> Login -> Username and Password -> API CALL -> In Backend match with database -> Verified -> the Provide the token - token stores in localStorage by fronted - then each request we have to provide token - backend match token that token is correct or not - than login </p>
</div>

<div class="box shadow p-2 mb-3" id="filter"> 
<h2> Filter </h2>

<pre><code>
  ng generate pipe filter
  name: 'filter'
  transform(items: any[], searchText: string): any[] {
    if (!items || !searchText) return items;
    searchText = searchText.toLowerCase();
    return items.filter(item => item.toLowerCase().includes(searchText));
  }

  -------------
  input type="text" [(ngModel)]="searchText" placeholder="Search items..." />
div *ngFor="let item of items | filter:searchText | paginate: { itemsPerPage: 10, currentPage: currentPage }">
  {{ item }}

pagination-controls (pageChange)="currentPage = $event"></pagination-controls>

</code>
</pre>

</div>

<div class="box shadow p-2 mb-3" id="pagination">
<h2> Pagination </h2>
<pre>
  <code>
    export class AppComponent implements OnInit {

      items: string[] = [];  // Store 100 items
      pagedItems: string[] = []; // Store items for current page
      pageSize = 10; // Number of items per page
      currentPage = 1; // Current active page
      totalPages = 0; // Total number of pages
    
      ngOnInit() {
        this.createItemsList();
      }
    
      createItemsList(){
        for(let i=1; i<=100; i++){
          this.items.push("Item" +' '+ i)
        }
        <!-- console.log('Check', this.items); -->
        this.totalPages = Math.ceil(this.items.length / this.pageSize);
        this.updatePage();
      }
    
      // Function to update items for the current page
      updatePage() {
        const startIndex = (this.currentPage - 1) * this.pageSize;
        const endIndex = startIndex + this.pageSize;
        this.pagedItems = this.items.slice(startIndex, endIndex);
      }
    
      // Function to change page
      goToPage(page: number) {
        if (page >= 1 && page <= this.totalPages) {
          this.currentPage = page;
          this.updatePage();
        }
      }
    }

    --------- 

    div *ngFor="let item of pagedItems">
      {{ item }}
    div
    div class="pagination">
      button (click)="goToPage(currentPage - 1)" [disabled]="currentPage === 1">Previous</button>
      button *ngFor="let page of [].constructor(totalPages); let i = index"
              (click)="goToPage(i + 1)"
              [class.active]="currentPage === i + 1">
        {{ i + 1 }}
      </button>
      button (click)="goToPage(currentPage + 1)" [disabled]="currentPage === totalPages">Next</button>
    div

  </code>
</pre>

</div>

<div class="box shadow p-2 mb-3" id="login-setup">
<h2> Login with api and username and password </h2>

<pre>
  <code>
    import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Component } from '@angular/core';
import { HttpSharedService } from '../http-shared.service';
import { Router } from '@angular/router';
import { ToastrService } from 'ngx-toastr';
import { response } from 'express';
import { LoaderComponent } from "../loader/loader.component";

@Component({
  selector: 'app-login',
  imports: [CommonModule, ReactiveFormsModule, LoaderComponent],
  templateUrl: './login.component.html',
  styleUrl: './login.component.css'
})
export class LoginComponent {

  loginForm!: FormGroup
  loading: boolean = false

constructor(
  private fb: FormBuilder,
  private http: HttpSharedService,
  private router: Router,
  private toastr: ToastrService
){
}

form_field = {
  username: ['', Validators.required],
  password: ['', Validators.minLength(6)]
}

ngOnInit(){
  this.loginForm = this.fb.group(this.form_field)
  this.login()
  this.pathFakerUser()
}

setPayload(form: any){
  return { 
  username: form.username, 
  password: form.password
}
}

pathFakerUser(){
  this.http.get('','').subscribe((response: any) => {
    this.loginForm.patchValue(
      {"username": "emilys", "password": "emilyspass"}
    )
  })
  // this.loginForm.setValue({
  //   email: 'emilys',
  //   password: 'emilyspass'
  // });
}


login() {
  this.http.post('auth/login', this.setPayload(this.loginForm.value)).subscribe((response: any) => {
    if(response.accessToken){
      sessionStorage.setItem("token", response.accessToken)
      this.toastr.success("Login is successfully.");
      this.router.navigateByUrl('dashboard')
    }  else {
      this.toastr.error("Login failed. No access token received.");
    }
    })
}

}



html 


form class="space-y-4 md:space-y-6" [formGroup]="loginForm" (ngSubmit)="login()">
  div>
      label>Your email label>
      input type="email" name="username" id="email" formControlName="username" placeholder="Username">
        div class="error-message" *ngIf="loginForm.get('username')?.touched && loginForm.get('username')?.hasError('required')"> Username is required. div>
  /div>
  div>
      label for="password">Password label>
      input type="password" name="password" id="password" formControlName="password" placeholder="••••••••" required="">
      div class="error-message" *ngIf="loginForm.get('password')?.touched && loginForm.get('password')?.invalid"> Password is required. div>
  /div>

  button type="submit" class="w-full text-white bg-gray-900 p-3 rounded" [disabled]="loginForm.invalid"> Sign in button >
/form>


  </code>
</pre>



<h2> Login page Setup </h2>
<div>
  ng generate component pages/login <br>
  ng generate component pages/dashboard <br>
  ng generate service services/auth <br>
  Auth Guard: Prevents unauthorized users from accessing Dashboard <br>
  -----------------
  Create Authentication Service ( auth.service.ts)
  <pre>
    <code>
      constructor(private router: Router) {}
  
  login(username: string, password: string): boolean {
    if (username === 'admin' && password === 'password') {
      localStorage.setItem('isLoggedIn', 'true');
      this.router.navigate(['/dashboard']);
      return true;
    }
    return false;
  }
  
  logout() {
    localStorage.removeItem('isLoggedIn');
    this.router.navigate(['/login']);
  }
  
  isAuthenticated(): boolean {
    return localStorage.getItem('isLoggedIn') === 'true';
  }
    </code>
  </pre>

  <h2> login.component.ts </h2>

<pre>
  <code>
    username: string = '';
    password: string = '';
    errorMessage: string = '';
    constructor(private authService: AuthService) {}
    login() {
      if (!this.authService.login(this.username, this.password)) {
        this.errorMessage = 'Invalid credentials!';
      }
    }
  </code>
</pre>

<h2>  login.component.html </h2>
<pre>
  <code>
    input type="text" placeholder="Username" [(ngModel)]="username" />
    input type="password" placeholder="Password" [(ngModel)]="password" />
    button (click)="login()">Login</button>
    p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>
  </code>
</pre>
 
<h2> dashboard.component.ts: </h2>    
<pre>
  <code>
    constructor(private authService: AuthService) {}
    logout() {
      this.authService.logout();
    }
  </code>
</pre>
  <h2> dashboard.html  </h2>
  <pre>
    <code>
      <div class="dashboard-container">
        <h2>Welcome to Dashboard</h2>
        button (click)="logout()">Logout</button>
      </div>
    </code>
  </pre>

  <h2> Login with DUMMY API </h2>

  <pre>
    <code>
      loginForm!: FormGroup
      show_password: boolean = false
    
      constructor(
        private fb: FormBuilder,
        private http: HttpSharedService,
        private toastr: ToastrService,
        private _common: CommonService
      ){}
    
      form_field = {
        email: ['', Validators.required],
        password: ['', Validators.required]
      }
    
      ngOnInit(){
        this.loginForm = this.fb.group(this.form_field)
    
        let domain = window.location.hostname; // e.g. "example.com"
        sessionStorage.setItem('domain', domain);
        console.log('Stored domain:', domain);
    
    
      }
      togglePassword(){ this.show_password = !this.show_password}
      setPayload(form: any){return { email: form.email, password: form.password}}
    
      login() {
    
        if(this.loginForm.value.email!="admin@yopmail.com"){
          
          this.toastr.warning("Only Admin Login is allowed here!")
          return
        }
    
        this.http.post('users/login', this.setPayload(this.loginForm.value)).subscribe((loginResponse: any) => {
          console.log(loginResponse)
          if (loginResponse.detail) {
            this.toastr.error(loginResponse.detail)
          } else {
            this._common.setSessionData(loginResponse)
          }
        }, (error: any) => {
          console.log("error", error)
          this.toastr.error("Invalid Details")
        })
      }

      ---------------

      HTML 

      form [formGroup]="loginForm" (ngSubmit)="login()" class="row g-3">
        div class="col-12">
          label for="inputEmailAddress" class="form-label">Email/label>
          input type="email" class="form-control" id="inputEmailAddress" placeholder="jhon@example.com"
            formControlName="email">
          div *ngIf="(!loginForm?.get('email')?.valid && loginForm?.get('email')?.touched )"
            class="text-danger mt-1" style="text-align: left;">
            Please enter email
          /div>
        /div>
        div class="col-12">
          label for="inputChoosePassword" class="form-label">Password /label>
          div class="input-group" id="show_hide_password">
            input [type]="show_password ? 'text' : 'password'" class="form-control border-end-0" formControlName="password"
              id="inputChoosePassword" placeholder="Enter Password">
            a (click)="togglePassword()" class="input-group-text bg-transparent">
              i class='bx bx-hide'></i>
            </a>
          /div>
          div *ngIf="(!loginForm?.get('password')?.valid && loginForm?.get('password')?.touched )"
            class="text-danger mt-1" style="text-align: left;">
            Please enter password
          /div>
        /div>
        div class="col-md-6">
          div class="form-check form-switch">
            input class="form-check-input" type="checkbox" id="flexSwitchCheckChecked">
            label class="form-check-label" for="flexSwitchCheckChecked">Remember
              Me</label>
          /div>
        /div>
        div class="col-md-6 text-end"> a routerLink="/forgot-password" class="linkbtn">Forgot
            Password ? /a>
        /div>
      div class="col-12">
          div class="d-grid">
            button [disabled]="!loginForm.valid" type="submit" class="btn btn-light">Login /button>
          /div>
        /div>
      
    /form>

    </code>
  </pre>

</div>
</div>

<div class="box shadow p-2 mb-3" id="material">
  <h2> Angular Material </h2>
  <p> Angular Material is a User Interface (UI) component library that we can use in their Angular projects to speed up the development of  consistent user interfaces.</p>
  <p> Angular Material offers you reusable and beautiful UI components like Cards, Inputs, Data Tables, Datepickers, </p>
  <pre>
    <code>
      mat-card>
        mat-card-title>SVG Line Reveal Animation /mat-card-title>
        mat-card-content>
        sfdgsdfg
        /mat-card-content>
      /mat-card>
      
    </code>
  </pre>
  </div>

  <div class="box shadow p-2 mb-3" id="json">
    <h2> Angular Material </h2>
    <p> JSON stands for JavaScript Object Notation. It’s a lightweight data format used to store and exchange data. Super common in web development, especially for APIs.</p>
    </div>

    <div class="box shadow p-2 mb-3" id="prime">
      <h2> PrimeNg </h2>
      <p> PrimeNG is a UI component library for Angular. It gives you a bunch of pre-made, beautiful, and customizable UI components—so you don’t have to build everything from scratch. </p>
      <p> <strong> What kind of components does PrimeNG have? </strong></p>
      Buttons, checkboxes, sliders, inputs <br>
      Data tables (super powerful) <br>
      Dialogs, tooltips, modals <br>
      Calendars and dropdowns <br>
      Charts and progress bars <br>
      File upload, drag-and-drop, and more <br>
      </div>




<div class="box shadow p-2 mb-3" id="dom">
  <h2 id="component"> DOM Manipulation </h2>
  Document Object Model
  <p> <strong> What is DOM Manipulation? </strong></p>
  <p> DOM Manipulation means changing elements, structure, or content of a webpage using JavaScript (or frameworks like Angular, React, etc.).
  </p>
  <p> <strong> For example, changing text, styles, adding/removing elements, etc. </strong></p>
  <pre><code>
    // Select an element
let heading = document.getElementById("title");

// Change text
heading.innerText = "New Title";

// Change style
heading.style.color = "blue";

// Create new element
let newPara = document.createElement("p");
newPara.textContent = "This is new!";
document.body.appendChild(newPara);

// Remove element
heading.remove();

  </code></pre>

  <h2> DOM Manipulation in Angular: </h2>
  <ul>
    <li> Data binding to update DOM automatically </li>
    <li> Structural directives like *ngIf, *ngFor to add/remove content </li>
    <li> Renderer2 for safe DOM access (used in services or advanced use cases) </li>
  </ul>

  </div>

  <div class="box shadow p-2 mb-3" id="test">
    <h2> Angular Test Casing  What is Jasmine? </h2>
   <p> Jasmine is a behavior-driven testing framework for JavaScript.
    and Karma Test Runner and watch
   </p>

   <ul>
    <li> <strong> describe() – </strong>  defines a test suite (group of tests) </li>
    <li> <strong> it() –  </strong>defines a single test/spec </li>
    <li> <strong> expect() – </strong> assertion to test result </li>
   </ul>

   <h2> Common Function </h2>
    <strong> describe() </strong>	Groups related test specs <br>
    <strong> it() </strong>	Defines a single test case <br>
    <strong> beforeEach() </strong>	Runs before each test <br>
    <strong> expect() </strong>	Makes an assertion <br>
    <strong> toBe() </strong>	Checks strict equality (===) <br>
    <strong> toEqual() </strong>	Checks deep equality (objects) <br>
    <strong> toContain() </strong>	Checks if a string/array contains <br>

    <pre>
      <code>
        num1 = 0;
        num2 = 0;

        result = 0;

        onAdd(){
          this.result = Number(this.num1) + Number(this.num2);
        }

        in - spec.ts 
        it("should get result onAdd", () => {
          component.num1 = 4;
          component.num2 = 5;
          component.onAdd();
          except(component.result).toBe(9)
        })

      </code>
    </pre>
    </div>


    <div class="box shadow p-2 mb-3" id="interceptor">
      <h2> Interceptor </h2>
      <p> An interceptor in Angular is a special service.  It is allows to intercept and manipulate HTTP requests and responses globally before they are sent or received. </p>
      <p> Authorization headers, Loading indicators, Logging, Error handling, Modifying requests/responses </p>
<h2> How It works </h2>
<p> Angular provides an interface called HttpInterceptor, which you can implement in a service. Then, you register that service as an HTTP interceptor in the provider’s array. </p>

<h2> Add a Token to Every Request </h2>
1. Create the interceptor service
<pre>
  <code>
    // auth.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = localStorage.getItem('authToken');

    if (token) {
      const cloned = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
      return next.handle(cloned);
    } else {
      return next.handle(req);
    }
  }
}
  </code>
</pre>
2. Provide it in you app.module.ts
<pre>
  <code>
    import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { AuthInterceptor } from './auth.interceptor';

@NgModule({
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true
    }
  ]
})
export class AppModule {}
  </code>
</pre>

<p> You Can Chain Multiple Interceptors
  Just add more entries to the providers array with multi: true. </p>

  <h2> 1. Global Error Handling Interceptor </h2>
  <p> This interceptor catches HTTP errors and lets you handle them in one place (like showing a toast, redirecting on 401, etc.) </p>

  <pre>
    <code>
      // error.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = 'An unknown error occurred!';

        if (error.status === 401) {
          errorMessage = 'Unauthorized. Redirecting to login...';
          // Optionally redirect:
          // this.router.navigate(['/login']);
        } else if (error.status === 500) {
          errorMessage = 'Internal server error!';
        } else if (error.error?.message) {
          errorMessage = error.error.message;
        }

        // Show a toast/snackbar here (example with alert)
        alert(errorMessage);

        return throwError(() => new Error(errorMessage));
      })
    );
  }
}

    </code>
  </pre>

      </div>



      <div class="box shadow p-2 mb-3" id="reusable">
<h2> Reusable Component </h2>
<h2> show more </h2>
<pre>
  <code>
// show-more.component.ts
import { Component, Input, booleanAttribute, signal } from '@angular/core';

@Component({
  selector: 'app-show-more',
  standalone: true,
  template: `
    div>
      p>{{ isExpanded() ? text : (text | slice:0:maxLength) + '...' }} /p>
      button (click)="toggle()" class="text-blue-500 hover:underline">
        {{ isExpanded() ? 'Show less' : 'Show more' }}
      /button>
    /div>
  `,
})
export class ShowMoreComponent {
  @Input({ required: true }) text = '';
  @Input({ transform: booleanAttribute }) expanded = false;
  @Input({ transform: (value: string | number) => +value }) maxLength = 100;
  
  isExpanded = signal(this.expanded);

  toggle() {
    this.isExpanded.update(v => !v);
  }
}


  <!-- ShowMore Example -->
    app-show-more 
      [text]="longText" 
      [maxLength]="50" 
      [expanded]="false"
    />

  </code>
</pre>



      </div>

    
      <div class="box shadow p-2 mb-3" id="empw-api">
        <h2> Employee crud without API </h2>

        <pre>
          <code>
            import { Component } from '@angular/core';
            import { HeaderComponent } from "../header/header.component";
            import { CommonModule } from '@angular/common';
            import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
            
            @Component({
              selector: 'app-dynamic-crud',
              imports: [HeaderComponent, CommonModule, FormsModule, ReactiveFormsModule],
              templateUrl: './dynamic-crud.component.html',
              styleUrl: './dynamic-crud.component.css'
            })
            export class DynamicCrudComponent {
            
            employee_form!: FormGroup
            employee_Toggle = false
            
            employee_details: any = []
            updateRecordId: any
            operation: any = "Add"
            
            employeeFormToggle(){
              this.employee_Toggle = !this.employee_Toggle
            }
            
              constructor( private fb: FormBuilder){}
            
              empform_fields = {
                emp_id  : [''],
                emp_name: ['', Validators.required],
                emp_email:['', Validators.required],
                emp_role :['', Validators.required]
              }
            
              ngOnInit(){ 
                this.initializeForm()
                let emp_data = localStorage.getItem('employeeData')
                if(emp_data){
                  this.employee_details = JSON.parse(emp_data)
                }
              }
            
              initializeForm(){
                this.employee_form = this.fb.group(this.empform_fields)
              }
            
              saveEmployee() {
                if (this.updateRecordId) {
                  this.updateEmployee();
                } else {
                  this.addEmployee();
                }
              }
            
              addEmployee() {
                
                const emp_id = (this.employee_details.at(-1)?.id ?? 0) + 1;
            
                this.employee_details.push({
                  "id"       : emp_id,
                  "emp_name" : this.employee_form.value.emp_name,
                  "emp_email": this.employee_form.value.emp_email,
                  "emp_role" : this.employee_form.value.emp_role
                })
            
                this.resetForm()
                this.saveToLocalStorage()
              }
            
              updateEmployee() {
                
                const found = this.employee_details.filter((empData: any) => empData.id == this.updateRecordId);
            
                if (found) {
                  found[0].emp_name = this.employee_form.value.emp_name;
                  found[0].emp_email = this.employee_form.value.emp_email;
                  found[0].emp_role = this.employee_form.value.emp_role;
                }
              
                this.saveToLocalStorage();
                this.resetForm();
              }
              
            
              getDataForEdit(emp_id: any){
                this.updateRecordId = emp_id
                let data = this.employee_details.filter((empData: any) => empData.id == emp_id)
                this.employee_form.patchValue(data[0])
                this.operation = "Update"
                this.employee_Toggle = true
              }
            
              deleteEmployee(emp_id: any){
                this.employee_details = this.employee_details.filter((empData: any) => empData.id != emp_id);
                this.saveToLocalStorage();
              }
            
              resetForm() {
                this.employee_form.reset();
                this.updateRecordId = null;
                this.operation = 'Add';
                this.employee_Toggle = false;
              }
            
              saveToLocalStorage(){
                localStorage.setItem('employeeData', JSON.stringify(this.employee_details))
              }
            
            }
            
          </code>
        </pre>
<hr>
        <pre> 
          <code>
          button (click)="employeeFormToggle()"> {{ !employee_Toggle ? 'Add Employee':'Close Form' }} button
          form [formGroup]="employee_form" (ngSubmit)="saveEmployee()" *ngIf="employee_Toggle">
          input type="text" class="form-control" formControlName="emp_name" placeholder="Employee Name">
           *ngIf="employee_form.get('emp_name')?.touched && employee_form.get('emp_name')?.hasError('required')"> Employee Name is Invalid

           button class="btn btn-primary" type="submit" [disabled]="!employee_form.valid"> {{ operation }} Employee 

          <hr>

           *ngIf="!employee_details.length"  No Data 

          table class="table table-bordered mt-3" *ngIf="employee_details.length">
              thead>
                tr>
                  th>Employee ID </th>
                  th>Employee Name</th>
                  th>Employee Email</th>
                  th>Employee Role</th>
                  th>Actions</th>
                /tr>
              /thead>
              tbody>
                tr *ngFor="let employee of employee_details">
                  td> {{employee.id}} </td>
                  td> {{employee.emp_name}} </td>
                  td> {{employee.emp_email}} </td>
                  td> {{employee.emp_role}} </td>
                  td>
                    button class="btn btn-sm btn-warning me-2" (click)="getDataForEdit(employee.id)">Edit</button>
                    button class="btn btn-sm btn-danger" (click)="deleteEmployee(employee.id)">Delete</button>
                  /td>
                /tr>
              /tbody>
            /table>

          </code>
        </pre>
      

        <h2> Only Add and Delete </h2>

        <pre>
          <code>
            import { CommonModule } from '@angular/common';
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { HeaderComponent } from "../header/header.component";

@Component({
  selector: 'app-emp-data',
  imports: [CommonModule, ReactiveFormsModule, HeaderComponent],
  templateUrl: './emp-data.component.html',
  styleUrl: './emp-data.component.css'
})
export class EmpDataComponent {

  employee_form!: FormGroup

  employee_details: any = []

  employee_fields = {
    emp_id: [''],
    emp_name: ['', Validators.required],
    emp_email: ['', Validators.required],
    emp_phone: ['', Validators.required]
  }

  constructor(private fb: FormBuilder){}

  ngOnInit(){ 
    this.initializeForm() 
    let emp_data = localStorage.getItem('employeeData')
    if(emp_data){
      this.employee_details = JSON.parse(emp_data)
    } 
  }

  initializeForm(){
    this.employee_form = this.fb.group(this.employee_fields)
  }

  saveForm(){ this.addEmployee() }

  addEmployee(){
   
    const emp_id = (this.employee_details.at(-1)?.id ?? 0) + 1;

    this.employee_details.push({
      "id": emp_id,
      "emp_name" : this.employee_form.value.emp_name,
      "emp_email" : this.employee_form.value.emp_email,
      "emp_phone" : this.employee_form.value.emp_phone
    })

    this.saveLocalStorage()

  }

  deleteEmployee(emp_id: any){
    this.employee_details = this.employee_details.filter((empData: any) => empData.id != emp_id)
    this.saveLocalStorage()
  }

  saveLocalStorage(){
    localStorage.setItem('employeeData', JSON.stringify(this.employee_details))
  }

}

HTML

form class="row" [formGroup]="employee_form" (ngSubmit)="addEmployee()">
form>
table class="table table-bordered mt-5">
  thead>
      tr> 
          th scope="col"> Employee Id </th>
          th scope="col"> Employee Name </th>
          th scope="col"> Employee Email </th>
          th scope="col"> Employee Phone </th>
      /tr>
  /thead>
  tbody>
      tr *ngFor="let employee of employee_details">
          td> {{employee.id}} </td>
          td> {{employee.emp_name}} </td>
          td> {{employee.emp_email}} </td>
          td> {{employee.emp_phone}} </td>
          td> button (click)="deleteEmployee(employee.id)" class="btn btn-danger"> Delete </button></td>
      /tr>
  /tbody>
/table>
          </code>
        </pre>

        <h2> Crud Operation with Static Data </h2>

        <pre>
          <code>
            import { Component } from '@angular/core';
import { HeaderComponent } from "../../header/header.component";
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-crud-lg-practise',
  imports: [HeaderComponent, ReactiveFormsModule, FormsModule, CommonModule],
  templateUrl: './crud-lg-practise.component.html',
  styleUrl: './crud-lg-practise.component.css'
})
export class CrudLgPractiseComponent {

  emp_form!: FormGroup;
  emp_details = [
    {
      emp_id: 1,
      emp_name: "Achyut Kadam Singh",
      emp_email: "achyut@gmail.com",
      emp_role: "WebDeveloper"
    },
    {
      emp_id: 2,
      emp_name: "Gorakh Sans",
      emp_email: "gorakh@gmail.com",
      emp_role: "Fullstack Developer"
    },
    {
      emp_id: 3,
      emp_name: "Achyut Kadam",
      emp_email: "achyut@gmail.com",
      emp_role: "Senior webDeveloper"
    }
  ];
  empUpdateid: number | null = null;

  constructor(private fb: FormBuilder) {}

  emp_fields = {
    emp_id: [''],
    emp_name: ['', Validators.required],
    emp_email: ['', Validators.required],
    emp_role: ['', Validators.required]
  };

  ngOnInit() {
    this.intializeForm();
  }

  intializeForm() {
    this.emp_form = this.fb.group(this.emp_fields);
  }

  resetForm() {
    this.intializeForm();
    this.empUpdateid = null;
  }

  saveEmployeeData() {
    if (this.empUpdateid !== null) {
      this.empUpdate();
    } else {
      this.createEmp();
    }
  }

  createEmp() {
    const newId = this.emp_details.length > 0
      ? Math.max(...this.emp_details.map(emp => emp.emp_id)) + 1
      : 1;

    this.emp_details.push({
      emp_id: newId,
      emp_name: this.emp_form.value.emp_name,
      emp_email: this.emp_form.value.emp_email,
      emp_role: this.emp_form.value.emp_role
    });

    this.resetForm();
  }

  empUpdate() {
    const index = this.emp_details.findIndex(emp => emp.emp_id === this.empUpdateid);
    if (index > -1) {
      this.emp_details[index].emp_name = this.emp_form.value.emp_name;
      this.emp_details[index].emp_email = this.emp_form.value.emp_email;
      this.emp_details[index].emp_role = this.emp_form.value.emp_role;
    }

    this.resetForm();
  }

  empUpdateEdit(emp_id: number) {
    this.empUpdateid = emp_id;
    const emp = this.emp_details.find(emp => emp.emp_id === emp_id);
    if (emp) {
      this.emp_form.patchValue(emp);
    }
  }

  deleteEmp(emp_id: number) {
    this.emp_details = this.emp_details.filter(emp => emp.emp_id !== emp_id);
    this.resetForm();
  }
}

-------------- 
HTML 
--------------- 

<div class="container">

        form [formGroup]="emp_form" (ngSubmit)="saveEmployeeData()">
          div class="row m-auto"> 
          div class="col-lg-3"> 
          input type="text" class="form-control" formControlName="emp_name" placeholder="Employee Name">
          div class="error" *ngIf="emp_form.get('emp_name')?.touched && emp_form.get('emp_name')?.hasError('required')"> Employee Name is Invalid /div>
          /div>
  
          div class="col-lg-3">  
          input type="text" class="form-control" formControlName="emp_email" placeholder="Employee Email">
          div class="error" *ngIf="emp_form.get('emp_email')?.touched && emp_form.get('emp_email')?.hasError('required')"> Employee Email is Invalid /div>
          /div>
  
          div class="col-lg-3"> 
          input type="text" class="form-control" formControlName="emp_role" placeholder="Employee Role">
          div class="error" *ngIf="emp_form.get('emp_role')?.touched && emp_form.get('emp_role')?.hasError('required')"> Employee Role is Invalid /div>
          /div>
          div class="col-lg-3">  button class="btn btn-primary" type="submit"> Employee /button>/div>
      /div>    
      /form>


    table class="table table-bordered mt-3">
        thead>
          tr>
            th>Employee ID /th>
            th>Employee Name /th>
            th>Employee Email /th>
            th>Employee Role /th>
            th>Actions /th>
          /tr>
        /thead>
      tbody>
          tr *ngFor="let emp of emp_details">
            td> {{emp.emp_id}} /td>
            td> {{emp.emp_name}} /td>
            td> {{emp.emp_email}} /td>
            td> {{emp.emp_role}} /td>
            td>
              button class="btn btn-sm btn-warning me-2" (click)="empUpdateEdit(emp.emp_id)">Edit/button>
              button class="btn btn-sm btn-danger" (click)="deleteEmp(emp.emp_id)">Delete/button>
            /td>
          /tr>
        /tbody>
      /table>
/div>


          </code>
        </pre>
  
        </div>


        <div class="box shadow p-2 mb-3" id="emp-api">
          <h2> Employee crud with API </h2>
          <pre>
            <code>
              import { Component, ElementRef, ViewChild } from '@angular/core';
import { HttpSharedService } from '../http-shared.service';
import { CommonModule } from '@angular/common';
import { FormBuilder, ReactiveFormsModule, Validators, FormGroup, FormsModule } from '@angular/forms';
import { HeaderComponent } from "../header/header.component";
import { LoaderSeriveService } from '../loader-serive.service';
import { ToastrService } from 'ngx-toastr';
import { response } from 'express';

@Component({
  selector: 'app-users',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, HeaderComponent, FormsModule],
  templateUrl: './users.component.html',
  styleUrl: './users.component.css'
})
export class UsersComponent {

  @ViewChild('close') close!: ElementRef

    users: any
    user_detail: any
    // loading: boolean = false
    user_form!: FormGroup
    user: any;
    action: string = "Add"

    user_fields = {
    username : ['', Validators.required],
    firstName: ['', Validators.required],
    lastName : ['', Validators.required],
    email    : ['', Validators.required],
    phone    : ['', Validators.required],
    address  : [''],
    }
  
    constructor( 
      private _http: HttpSharedService,
      private _fb: FormBuilder,
      public loader: LoaderSeriveService,
      private toastr: ToastrService
     ){ }

    ngOnInit(){
      this.getUsers()
      this.initializeForm()
    }

    resetForm(){
      this.action = "Add"
      this.initializeForm()
    }

    initializeForm(){this.user_form = this._fb.group(this.user_fields)}

    getUsers(){
     this._http.get('users').subscribe((response: any) => {
      this.users = response.users;
      console.log('Check-', this.users);
    })
   }

   setUser(user: any, action: string){
    this.user_detail = user;
    if(action == 'edit'){
      this.action = 'Edit'
      this.patchUser()
    }
    // this._http.get('users/'+user.id).subscribe((response: any) => {
    //   this.user_detail = response;
    //   if(action == 'edit'){
    //     this.action = 'Edit'
    //     this.patchUser()
    //   }
    // })
   }

   patchUser(){
    this.user_form.patchValue({
      username  : this.user_detail.username,
      firstName : this.user_detail.firstName,
      lastName  : this.user_detail.lastName,
      email     : this.user_detail.email,
      phone     : this.user_detail.phone
      // address   : this.users.address
    })
   }

   setPayLoad(form: any){
    return {
      username : form.username,
      firstName: form.firstName,
      lastName : form.lastName,
      email    : form.email,
      phone    : form.phone,
      address  : form.address
    }
   }

   saveForm(){ this.action === "Add" ? this.createUser() : this.updateUser()}

   createUser(){
    this._http.post('users/add', this.setPayLoad(this.user_form.value)).subscribe((response: any) => {
      this.getUsers()
      this.resetForm()
      this.close.nativeElement.click()
      this.toastr.success("User Added successfully.");
      console.log('Create Users', response);
    })
   }

   updateUser(){
    this._http.put('users/'+this.user_detail.id, this.setPayLoad(this.user_form.value)).subscribe((response: any) => {
      this.resetForm()
      this.getUsers()
      this.close.nativeElement.click()
      this.toastr.success("User Updated Successfully")
    })
   }

   deActivatedUser(user: any){
    this._http.delete('users/'+user.id).subscribe((response: any) => {
      this.getUsers()
      this.resetForm()
      console.log('DeActivate', response);
      this.toastr.success("User Deleted Successfully")
    })
   }
  
}

            </code>
          </pre>

          <hr>

          <pre>
            <code>

              div class="card">
                div class="card-body max-w-7xl m-auto">
            
                  a href="#" style="display: flex; justify-content: center; margin-left: 23px !important; background: #000; color: #fff; width: 124px; text-align: center; margin-top: 25px; padding: 5px; border-radius: 50px;" data-bs-toggle="modal" data-bs-target="#exampleModal"> Add User /a>
            
                  div class="overflow-x-auto p-4">
                    !-- {{loader.isLoading | async}} -->
                    table class="min-w-full divide-y divide-gray-200 bg-white shadow-md rounded-lg">
                      thead class="bg-gray-100 text-gray-700 uppercase text-sm font-semibold">
                        tr>
                          th class="px-4 py-3 text-left">Username/th>
                          th class="px-4 py-3 text-left">Name/th>
                          th class="px-4 py-3 text-left">Gender/th>
                          th class="px-4 py-3 text-left">Email/th>
                          th class="px-4 py-3 text-left">Phone/th>
                          th class="px-4 py-3 text-left">Address/th>
                          th class="px-4 py-3 text-center">Actions/th>
                        /tr>
                      /thead>
                      tbody class="text-gray-700 divide-y divide-gray-200">
                        !-- Row 1 -->
                        tr class="hover:bg-gray-50" *ngFor="let user of users">
                          td class="px-4 py-3">  {{user.username}} /td>
                          td class="px-4 py-3"> {{user.firstName}} {{user.lastName}} /td>
                          td class="px-4 py-3"> {{user.gender}} /td>
                          td class="px-4 py-3"> {{user.email}} /td>
                          td class="px-4 py-3"> {{user.phone}} /td>
                          td class="px-4 py-3"> {{user.address?.address}} /td>
                            td class="px-4 py-3 text-center space-x-2">
                            button class="text-blue-600 hover:underline" (click)="setUser(user, 'edit')" data-bs-toggle="modal" data-bs-target="#exampleModal">Edit/button>
                            button class="text-red-600 hover:underline" (click)="deActivatedUser(user)">Delete/button>
                          /td>
                        /tr>
                      /tbody>
                    /table>
                  /div>
                /div>
            /div>
            
            !-- Modal -->
            div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
              div class="modal-dialog modal-lg">
                div class="modal-content">
                  div class="modal-header">
                    h5 class="modal-title" id="exampleModalLabel"> {{action}} User /h5>
                    button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" #close (click)="resetForm()">/button>
                  /div>
                  div class="modal-body">
                
                    form class="mt-4" [formGroup]="user_form" (ngSubmit)="saveForm()">
                      div class="row mb-3">
                        div class="col-md-6">
                          label for="username" class="form-label">Username/label>
                          input type="text" class="form-control" id="username" placeholder="Enter username" formControlName="username">
                          div class="error-message" *ngIf="user_form.get('username')?.touched && user_form.get('username')?.hasError('required')">Username is required./div>
                        /div>
                        div class="col-md-6">
                          label for="firstName" class="form-label">First Name/label>
                          input type="text" class="form-control" id="firstName" placeholder="Enter first name" formControlName="firstName">
                          div class="error-message" *ngIf="user_form.get('firstName')?.touched && user_form.get('firstName')?.hasError('required')">First Name is required./div>
                        /div>
                      /div>
                    
                      div class="row mb-3">
                        div class="col-md-6">
                          label for="lastName" class="form-label">Last Name/label>
                          input type="text" class="form-control" id="lastName" placeholder="Enter last name" formControlName="lastName">
                          div class="error-message" *ngIf="user_form.get('lastName')?.touched && user_form.get('lastName')?.hasError('required')">Last Name is required./div>
                        /div>
                      /div>
                    
                      div class="row mb-3">
                        div class="col-md-6">
                          label for="email" class="form-label">Email/label>
                          input type="email" class="form-control" id="email" placeholder="Enter email" formControlName="email">
                          div class="error-message" *ngIf="user_form.get('email')?.touched && user_form.get('email')?.hasError('required')">Email is required./div>
                        /div>
                        div class="col-md-6">
                          label for="phone" class="form-label">Phone/label>
                          input type="tel" class="form-control" id="phone" placeholder="Enter phone number" formControlName="phone">
                          div class="error-message" *ngIf="user_form.get('phone')?.touched && user_form.get('phone')?.hasError('required')">Phone is required./div>
                        /div>
                      /div>
                    
                      div class="mb-3">
                        label for="address" class="form-label">Address/label>
                        textarea class="form-control" id="address" rows="3" placeholder="Enter address" formControlName="address">/textarea>
                        div class="error-message" *ngIf="user_form.get('address')?.touched && user_form.get('address')?.hasError('required')">Address is required./div>
                      /div>
                      button type="submit" class="btn btn-primary" [disabled]="user_form.invalid">Submit/button>
                    /form>
                  /div>
                /div>
              /div>
            /div>


            </code>
          </pre>
          </div>


          <div class="box shadow p-2 mb-3" id="class"> 
            <h2> classs </h2>
            <p> A class is a TypeScript feature (and JavaScript ES6) that allows you to create reusable objects with properties and methods.
              <br>
              In Angular, classes are used everywhere — especially with decorators like @Component, @Injectable, and @NgModule. </p>

              <h2> class in Angular </h2>
              <pre>
                <code>
                  export class User {
                    constructor(
                      public name: string,
                      public age: number
                    ) {}
                  
                    greet() {
                      return `Hello, my name is ${this.name}`;
                    }
                  }
                  
                  // usaseg 

                  let user = new User("John", 30);
console.log(user.greet());  // "Hello, my name is John"

                </code>
              </pre>
          </div>
  

    <div class="box shadow p-2 mb-3" id="git">
      <h2> GIT And GITHUB </h2>

      <h2> What is Git? </h2>
      <p> Git is a version control system that helps developers track changes in their code, collaborate with others, and manage different versions of a project. </p>

      <h2> What is GitHub? </h2>
     <p> GitHub is a cloud platform built on top of Git. It allows you to: </p> 
     <p> Store your Git repositories online </p>
     <p> Collaborate with teams </p>
     <p> Create pull requests, issues, etc. </p>

     <h2> What is Branching in Git? </h2>
     <p> A branch is like a separate copy of your code where you can make changes without affecting the main project. </p>

     <h2> What is Merging in Git? </h2>
     <p> Merging is the process of combining changes from one branch into another. </p>
     git checkout main <br> 
      git merge feature/login-page

      <h2> GIT Workflow </h2>
      <ul>
        <li>git clone – Copy repo from GitHub </li>
        <li> git checkout -b new-feature – Create a branch </li>
        <li> Make your changes and git add, git commit </li>
        <li> git push origin new-feature – Push to GitHub </li>
        <li> Open a Pull Request (PR) on GitHub </li>
        <li> Review & merge into main </li>
      </ul>
      </div>



      <div class="box shadow p-2 mb-3" id="web">
        <h2> What is Web Optimization? </h2>
        <p> Web Optimization is the process of improving a website’s performance, speed, user experience, and searchability (SEO). </p>

        <ol>
          <li> Performance Optimization <br> Minify HTML, CSS, JS, Use GZIP compression, Load critical CSS first, Avoid large JS bundles </li>
          <li> Image Optimization, Compress images (TinyPNG, ImageMagick, etc.), Use Lazy Loading </li>
          <li> Caching </li>
          <li> Responsive Design ,  use medi query </li>
          <li> Reduce HTTP Requests , CSS sprites </li>
          <li> use cdn </li>
          <li> <strong> TOOLS </strong></li>
          <li><strong> GTmetrix , Google PageSpeed Insights</strong></li>
        </ol>
        </div>

        
      <div class="box shadow p-2 mb-3" id="google">
        <h2> Google Cloud </h2>
        <p> Google Cloud = A powerful platform to run apps, store data, analyze information </p>

      <h2> Common Use Cases </h2>  
      <ul> 
        <li> Hosting websites & web apps </li>
        <li> Running backend APIs </li>
        <li> Storing and analyzing big data </li>
        <li> Deploying machine learning models </li>
        <li> Running containers with Kubernetes (GKE) </li>
      </ul>

      <h2> Why Use Google Cloud? </h2>
      <p> Fast & Scalable , Secure , Integrates well with Angular, Firebase, and other Google tools </p>

      <h2> Services Does Google Cloud Offer? </h2>
      <p> Storage, Security, Networking, Developer Tools, </p>
        </div>

        

        <div class="box shadow p-2 mb-3" id="async">
          <h2> Async | Pipe </h2>
          <p> Async/Await works on top of Promise and allows you to write async code in a synchronous </p>
          <p> async pipe is used in Angular templates to automatically subscribe to:

            Observable<T> (from RxJS)
            
            Promise<T></p>
          <pre>
            <code>
              data = new Promise(resolve => {
                setTimeout(() => resolve('Loaded from Promise!'), 1500);
              });

            p> Data: {{ data | async }} /p
          </code>
          <h2> async/await </h2>
          IN TS 
          result = '';

  async loadData() {
    const data = await this.fetchData();
    this.result = data;
  }

  fetchData(): Promise string> {
    return new Promise(resolve => {
      setTimeout(() => resolve('Data loaded with async/await!'), 1000);
    });
  }


          in html 
          p> {{ result }} /p
          button (click)="loadData()"> Load /button
        </pre>

        <pre>
          <code>
            Example with Observable (RxJS)
            import { of, delay } from 'rxjs';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [],
  template: `p>Message: {{ message$ | async }} p>`
})
export class AppComponent {
  message$ = of('Hello from Observable!').pipe(delay(1000));
}
          </code>
        </pre>


        </div>


        <div class="box shadow p-2 mb-3" id="azile">
          <h2> Azile Methodology </h2>
          <p> Agile = Delivering software in small, usable pieces — fast, flexible, and with constant feedback. </p>
          <h2>  Agile Workflow </h2>
          <ul>
            <li> Step-by-step Agile Process: </li>
            <li> Product Backlog – List of all features/tasks (To-Do list) </li>
            <li> Sprint Planning – Pick tasks for the next sprint (usually 1–2 weeks) </li>
            <li> Sprint – The team builds and tests features </li>
            <li> Daily Stand-up – Quick daily meeting to track progress </li>
            <li> Sprint Review – Demo the completed work </li>
            <li> Sprint Retrospective – Discuss what went well & what to improve </li>
          </ul>
      <h2> Just like todo app: </h2>    
        <ul>
        <li> Build the "Add Task" feature</li>
        <li> Add "Edit & Delete" </li>
        <li> Add filtering and UI improvements </li>
        </ul>
          </div>

          <div class="box shadow p-2 mb-3" id="server">
            <h2> Upload Angular Project to Server </h2>
            <p> <strong> Build the Angular Project </strong></p>
            <p>Run this command -  ng build --configuration=production </p>
            <p> <strong> Choose Your Hosting Type </strong></p>
            Shared hosting, Cloud hosting <br>
            Zip the contents of dist/your-project-name/.
            </div>

            <div class="box shadow p-2 mb-3" id="packages">
              <h2> package.json, package-lock.json and angular.json </h2>
              <h2> package.json </h2>
              <p> Lists of libraries in app needs (dependencies, devDependencies) Declares project name, version, </p>
              <p> script - "start": "ng serve",
                "build": "ng build" </p>
                <h2> package-lock.json </h2>
                <p> Automatically created/updated by npm when installing packages</p>
                <h2> angular.json </h2>
                <p> Project structure, Build options </p>
                <p> File paths (e.g. index.html, styles, assets) </p>
                <pre>
                  <code>
                    "projects": {
                      "my-angular-app": {
                        "architect": {
                          "build": {
                            "options": {
                              "outputPath": "dist/",
                              "index": "src/index.html",
                              "styles": ["src/styles.css"]
                            }
                          }
                        }
                      }
                    }
                  </code>
                </pre>
              </div>

<button id="toTopBtn" title="Go to top">↑</button>
<script src="script.js"></script>
  </body>
</html>
